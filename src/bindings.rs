#[allow(non_snake_case)]
pub mod vehicle {
    use cdds_derive::Topic;
    use cyclonedds_rs::*;
    #[doc = "State of the supply voltage of the control units (usually 12V).. This type has no unit defined"]
    #[allow(non_camel_case_types)]
    #[repr(C)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct LowVoltageSystemState {
        pub value: String,
        pub timestamp: crate::v3::Timestamp,
    }
    impl LowVoltageSystemState {
        pub fn timestamp(&self) -> &crate::v3::Timestamp {
            &self.timestamp
        }
        #[doc = r" Get the "]
        #[doc = "State of the supply voltage of the control units (usually 12V).. This type has no unit defined"]
        pub fn value(&self) -> &String {
            &self.value
        }
        #[doc = r" Set the"]
        #[doc = "State of the supply voltage of the control units (usually 12V).. This type has no unit defined"]
        #[doc = r" . Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(&mut self, value: String, maybe_timestamp: Option<crate::v3::Timestamp>) {
            assert!(Self::bounds_check(&value));
            self.value = value;
            if let Some(ts) = maybe_timestamp {
                self.timestamp = ts;
            }
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &String) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(value: String, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self {
                    value,
                    timestamp: timestamp.unwrap_or_default(),
                })
            } else {
                None
            }
        }
    }
    #[doc = "Vehicle speed.. The unit of this type is km/h"]
    #[allow(non_camel_case_types)]
    #[repr(C)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct Speed {
        pub value: crate::v3::units::KilometrePerHour<f32>,
        pub timestamp: crate::v3::Timestamp,
    }
    impl Speed {
        pub fn timestamp(&self) -> &crate::v3::Timestamp {
            &self.timestamp
        }
        #[doc = r" Get the "]
        #[doc = "Vehicle speed.. The unit of this type is km/h"]
        pub fn value(&self) -> &crate::v3::units::KilometrePerHour<f32> {
            &self.value
        }
        #[doc = r" Set the"]
        #[doc = "Vehicle speed.. The unit of this type is km/h"]
        #[doc = r" . Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(
            &mut self,
            value: crate::v3::units::KilometrePerHour<f32>,
            maybe_timestamp: Option<crate::v3::Timestamp>,
        ) {
            assert!(Self::bounds_check(&value));
            self.value = value;
            if let Some(ts) = maybe_timestamp {
                self.timestamp = ts;
            }
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &crate::v3::units::KilometrePerHour<f32>) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(
            value: crate::v3::units::KilometrePerHour<f32>,
            timestamp: Option<crate::v3::Timestamp>,
        ) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self {
                    value,
                    timestamp: timestamp.unwrap_or_default(),
                })
            } else {
                None
            }
        }
    }
    #[doc = "Odometer reading, total distance travelled during the lifetime of the vehicle.. The unit of this type is km"]
    #[allow(non_camel_case_types)]
    #[repr(C)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct TravelledDistance {
        pub value: crate::v3::units::Kilometre<f32>,
        pub timestamp: crate::v3::Timestamp,
    }
    impl TravelledDistance {
        pub fn timestamp(&self) -> &crate::v3::Timestamp {
            &self.timestamp
        }
        #[doc = r" Get the "]
        #[doc = "Odometer reading, total distance travelled during the lifetime of the vehicle.. The unit of this type is km"]
        pub fn value(&self) -> &crate::v3::units::Kilometre<f32> {
            &self.value
        }
        #[doc = r" Set the"]
        #[doc = "Odometer reading, total distance travelled during the lifetime of the vehicle.. The unit of this type is km"]
        #[doc = r" . Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(
            &mut self,
            value: crate::v3::units::Kilometre<f32>,
            maybe_timestamp: Option<crate::v3::Timestamp>,
        ) {
            assert!(Self::bounds_check(&value));
            self.value = value;
            if let Some(ts) = maybe_timestamp {
                self.timestamp = ts;
            }
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &crate::v3::units::Kilometre<f32>) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(
            value: crate::v3::units::Kilometre<f32>,
            timestamp: Option<crate::v3::Timestamp>,
        ) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self {
                    value,
                    timestamp: timestamp.unwrap_or_default(),
                })
            } else {
                None
            }
        }
    }
    #[doc = "Current trip meter reading.. The unit of this type is km"]
    #[allow(non_camel_case_types)]
    #[repr(C)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct TripMeterReading {
        pub value: crate::v3::units::Kilometre<f32>,
        pub timestamp: crate::v3::Timestamp,
    }
    impl TripMeterReading {
        pub fn timestamp(&self) -> &crate::v3::Timestamp {
            &self.timestamp
        }
        #[doc = r" Get the "]
        #[doc = "Current trip meter reading.. The unit of this type is km"]
        pub fn value(&self) -> &crate::v3::units::Kilometre<f32> {
            &self.value
        }
        #[doc = r" Set the"]
        #[doc = "Current trip meter reading.. The unit of this type is km"]
        #[doc = r" . Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(
            &mut self,
            value: crate::v3::units::Kilometre<f32>,
            maybe_timestamp: Option<crate::v3::Timestamp>,
        ) {
            assert!(Self::bounds_check(&value));
            self.value = value;
            if let Some(ts) = maybe_timestamp {
                self.timestamp = ts;
            }
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &crate::v3::units::Kilometre<f32>) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(
            value: crate::v3::units::Kilometre<f32>,
            timestamp: Option<crate::v3::Timestamp>,
        ) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self {
                    value,
                    timestamp: timestamp.unwrap_or_default(),
                })
            } else {
                None
            }
        }
    }
    #[doc = "Vehicle breakdown or any similar event causing vehicle to stop on the road, that might pose a risk to other road users. True = Vehicle broken down on the road, due to e.g. engine problems, flat tire, out of gas, brake problems. False = Vehicle not broken down.. This type has no unit defined"]
    #[allow(non_camel_case_types)]
    #[repr(C)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct IsBrokenDown {
        pub value: bool,
        pub timestamp: crate::v3::Timestamp,
    }
    impl IsBrokenDown {
        pub fn timestamp(&self) -> &crate::v3::Timestamp {
            &self.timestamp
        }
        #[doc = r" Get the "]
        #[doc = "Vehicle breakdown or any similar event causing vehicle to stop on the road, that might pose a risk to other road users. True = Vehicle broken down on the road, due to e.g. engine problems, flat tire, out of gas, brake problems. False = Vehicle not broken down.. This type has no unit defined"]
        pub fn value(&self) -> &bool {
            &self.value
        }
        #[doc = r" Set the"]
        #[doc = "Vehicle breakdown or any similar event causing vehicle to stop on the road, that might pose a risk to other road users. True = Vehicle broken down on the road, due to e.g. engine problems, flat tire, out of gas, brake problems. False = Vehicle not broken down.. This type has no unit defined"]
        #[doc = r" . Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
            assert!(Self::bounds_check(&value));
            self.value = value;
            if let Some(ts) = maybe_timestamp {
                self.timestamp = ts;
            }
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &bool) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self {
                    value,
                    timestamp: timestamp.unwrap_or_default(),
                })
            } else {
                None
            }
        }
    }
    #[doc = "Indicates whether the vehicle is stationary or moving.. This type has no unit defined"]
    #[allow(non_camel_case_types)]
    #[repr(C)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct IsMoving {
        pub value: bool,
        pub timestamp: crate::v3::Timestamp,
    }
    impl IsMoving {
        pub fn timestamp(&self) -> &crate::v3::Timestamp {
            &self.timestamp
        }
        #[doc = r" Get the "]
        #[doc = "Indicates whether the vehicle is stationary or moving.. This type has no unit defined"]
        pub fn value(&self) -> &bool {
            &self.value
        }
        #[doc = r" Set the"]
        #[doc = "Indicates whether the vehicle is stationary or moving.. This type has no unit defined"]
        #[doc = r" . Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
            assert!(Self::bounds_check(&value));
            self.value = value;
            if let Some(ts) = maybe_timestamp {
                self.timestamp = ts;
            }
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &bool) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self {
                    value,
                    timestamp: timestamp.unwrap_or_default(),
                })
            } else {
                None
            }
        }
    }
    #[doc = "Average speed for the current trip.. The unit of this type is km/h"]
    #[allow(non_camel_case_types)]
    #[repr(C)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct AverageSpeed {
        pub value: crate::v3::units::KilometrePerHour<f32>,
        pub timestamp: crate::v3::Timestamp,
    }
    impl AverageSpeed {
        pub fn timestamp(&self) -> &crate::v3::Timestamp {
            &self.timestamp
        }
        #[doc = r" Get the "]
        #[doc = "Average speed for the current trip.. The unit of this type is km/h"]
        pub fn value(&self) -> &crate::v3::units::KilometrePerHour<f32> {
            &self.value
        }
        #[doc = r" Set the"]
        #[doc = "Average speed for the current trip.. The unit of this type is km/h"]
        #[doc = r" . Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(
            &mut self,
            value: crate::v3::units::KilometrePerHour<f32>,
            maybe_timestamp: Option<crate::v3::Timestamp>,
        ) {
            assert!(Self::bounds_check(&value));
            self.value = value;
            if let Some(ts) = maybe_timestamp {
                self.timestamp = ts;
            }
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &crate::v3::units::KilometrePerHour<f32>) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(
            value: crate::v3::units::KilometrePerHour<f32>,
            timestamp: Option<crate::v3::Timestamp>,
        ) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self {
                    value,
                    timestamp: timestamp.unwrap_or_default(),
                })
            } else {
                None
            }
        }
    }
    #[doc = "The permitted total weight of cargo and installations (e.g. a roof rack) on top of the vehicle.. The unit of this type is kg"]
    #[allow(non_camel_case_types)]
    #[repr(C)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct RoofLoad {
        pub value: crate::v3::units::Kilogram<i16>,
    }
    impl RoofLoad {
        #[doc = r" Get the "]
        #[doc = "The permitted total weight of cargo and installations (e.g. a roof rack) on top of the vehicle.. The unit of this type is kg"]
        pub fn value(&self) -> &crate::v3::units::Kilogram<i16> {
            &self.value
        }
        #[doc = r" Set the"]
        #[doc = "The permitted total weight of cargo and installations (e.g. a roof rack) on top of the vehicle.. The unit of this type is kg"]
        #[doc = r" Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(&mut self, value: crate::v3::units::Kilogram<i16>) {
            assert!(Self::bounds_check(&value));
            self.value = value;
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &crate::v3::units::Kilogram<i16>) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(value: crate::v3::units::Kilogram<i16>) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self { value })
            } else {
                None
            }
        }
    }
    #[doc = "The available volume for cargo or luggage. For automobiles, this is usually the trunk volume.. The unit of this type is l"]
    #[allow(non_camel_case_types)]
    #[repr(C)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct CargoVolume {
        pub value: crate::v3::units::Litre<f32>,
    }
    impl CargoVolume {
        #[doc = r" Get the "]
        #[doc = "The available volume for cargo or luggage. For automobiles, this is usually the trunk volume.. The unit of this type is l"]
        pub fn value(&self) -> &crate::v3::units::Litre<f32> {
            &self.value
        }
        #[doc = r" Set the"]
        #[doc = "The available volume for cargo or luggage. For automobiles, this is usually the trunk volume.. The unit of this type is l"]
        #[doc = r" Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(&mut self, value: crate::v3::units::Litre<f32>) {
            assert!(Self::bounds_check(&value));
            self.value = value;
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. Return true if the value is"]
        #[doc = r"within bounds."]
        pub fn bounds_check(v: &crate::v3::units::Litre<f32>) -> bool {
            true && v.0 >= 0f32
        }
        #[doc = r" create a new instance"]
        pub fn new(value: crate::v3::units::Litre<f32>) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self { value })
            } else {
                None
            }
        }
    }
    #[doc = "The CO2 emissions.. The unit of this type is g/km"]
    #[allow(non_camel_case_types)]
    #[repr(C)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct EmissionsCO2 {
        pub value: i16,
    }
    impl EmissionsCO2 {
        #[doc = r" Get the "]
        #[doc = "The CO2 emissions.. The unit of this type is g/km"]
        pub fn value(&self) -> &i16 {
            &self.value
        }
        #[doc = r" Set the"]
        #[doc = "The CO2 emissions.. The unit of this type is g/km"]
        #[doc = r" Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(&mut self, value: i16) {
            assert!(Self::bounds_check(&value));
            self.value = value;
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &i16) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(value: i16) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self { value })
            } else {
                None
            }
        }
    }
    #[doc = "Current overall Vehicle weight. Including passengers, cargo and other load inside the car.. The unit of this type is kg"]
    #[allow(non_camel_case_types)]
    #[repr(C)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct CurrentOverallWeight {
        pub value: crate::v3::units::Kilogram<u16>,
        pub timestamp: crate::v3::Timestamp,
    }
    impl CurrentOverallWeight {
        pub fn timestamp(&self) -> &crate::v3::Timestamp {
            &self.timestamp
        }
        #[doc = r" Get the "]
        #[doc = "Current overall Vehicle weight. Including passengers, cargo and other load inside the car.. The unit of this type is kg"]
        pub fn value(&self) -> &crate::v3::units::Kilogram<u16> {
            &self.value
        }
        #[doc = r" Set the"]
        #[doc = "Current overall Vehicle weight. Including passengers, cargo and other load inside the car.. The unit of this type is kg"]
        #[doc = r" . Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(
            &mut self,
            value: crate::v3::units::Kilogram<u16>,
            maybe_timestamp: Option<crate::v3::Timestamp>,
        ) {
            assert!(Self::bounds_check(&value));
            self.value = value;
            if let Some(ts) = maybe_timestamp {
                self.timestamp = ts;
            }
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &crate::v3::units::Kilogram<u16>) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(
            value: crate::v3::units::Kilogram<u16>,
            timestamp: Option<crate::v3::Timestamp>,
        ) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self {
                    value,
                    timestamp: timestamp.unwrap_or_default(),
                })
            } else {
                None
            }
        }
    }
    #[doc = "Vehicle curb weight, including all liquids and full tank of fuel, but no cargo or passengers.. The unit of this type is kg"]
    #[allow(non_camel_case_types)]
    #[repr(C)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct CurbWeight {
        pub value: crate::v3::units::Kilogram<u16>,
    }
    impl CurbWeight {
        #[doc = r" Get the "]
        #[doc = "Vehicle curb weight, including all liquids and full tank of fuel, but no cargo or passengers.. The unit of this type is kg"]
        pub fn value(&self) -> &crate::v3::units::Kilogram<u16> {
            &self.value
        }
        #[doc = r" Set the"]
        #[doc = "Vehicle curb weight, including all liquids and full tank of fuel, but no cargo or passengers.. The unit of this type is kg"]
        #[doc = r" Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(&mut self, value: crate::v3::units::Kilogram<u16>) {
            assert!(Self::bounds_check(&value));
            self.value = value;
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &crate::v3::units::Kilogram<u16>) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(value: crate::v3::units::Kilogram<u16>) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self { value })
            } else {
                None
            }
        }
    }
    #[doc = "Curb weight of vehicle, including all liquids and full tank of fuel and full load of cargo and passengers.. The unit of this type is kg"]
    #[allow(non_camel_case_types)]
    #[repr(C)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct GrossWeight {
        pub value: crate::v3::units::Kilogram<u16>,
    }
    impl GrossWeight {
        #[doc = r" Get the "]
        #[doc = "Curb weight of vehicle, including all liquids and full tank of fuel and full load of cargo and passengers.. The unit of this type is kg"]
        pub fn value(&self) -> &crate::v3::units::Kilogram<u16> {
            &self.value
        }
        #[doc = r" Set the"]
        #[doc = "Curb weight of vehicle, including all liquids and full tank of fuel and full load of cargo and passengers.. The unit of this type is kg"]
        #[doc = r" Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(&mut self, value: crate::v3::units::Kilogram<u16>) {
            assert!(Self::bounds_check(&value));
            self.value = value;
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &crate::v3::units::Kilogram<u16>) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(value: crate::v3::units::Kilogram<u16>) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self { value })
            } else {
                None
            }
        }
    }
    #[doc = "Maximum weight of trailer.. The unit of this type is kg"]
    #[allow(non_camel_case_types)]
    #[repr(C)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct MaxTowWeight {
        pub value: crate::v3::units::Kilogram<u16>,
    }
    impl MaxTowWeight {
        #[doc = r" Get the "]
        #[doc = "Maximum weight of trailer.. The unit of this type is kg"]
        pub fn value(&self) -> &crate::v3::units::Kilogram<u16> {
            &self.value
        }
        #[doc = r" Set the"]
        #[doc = "Maximum weight of trailer.. The unit of this type is kg"]
        #[doc = r" Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(&mut self, value: crate::v3::units::Kilogram<u16>) {
            assert!(Self::bounds_check(&value));
            self.value = value;
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &crate::v3::units::Kilogram<u16>) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(value: crate::v3::units::Kilogram<u16>) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self { value })
            } else {
                None
            }
        }
    }
    #[doc = "Maximum vertical weight on the tow ball of a trailer.. The unit of this type is kg"]
    #[allow(non_camel_case_types)]
    #[repr(C)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct MaxTowBallWeight {
        pub value: crate::v3::units::Kilogram<u16>,
    }
    impl MaxTowBallWeight {
        #[doc = r" Get the "]
        #[doc = "Maximum vertical weight on the tow ball of a trailer.. The unit of this type is kg"]
        pub fn value(&self) -> &crate::v3::units::Kilogram<u16> {
            &self.value
        }
        #[doc = r" Set the"]
        #[doc = "Maximum vertical weight on the tow ball of a trailer.. The unit of this type is kg"]
        #[doc = r" Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(&mut self, value: crate::v3::units::Kilogram<u16>) {
            assert!(Self::bounds_check(&value));
            self.value = value;
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &crate::v3::units::Kilogram<u16>) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(value: crate::v3::units::Kilogram<u16>) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self { value })
            } else {
                None
            }
        }
    }
    #[doc = "Overall vehicle length.. The unit of this type is mm"]
    #[allow(non_camel_case_types)]
    #[repr(C)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct Length {
        pub value: crate::v3::units::Millimetre<u16>,
    }
    impl Length {
        #[doc = r" Get the "]
        #[doc = "Overall vehicle length.. The unit of this type is mm"]
        pub fn value(&self) -> &crate::v3::units::Millimetre<u16> {
            &self.value
        }
        #[doc = r" Set the"]
        #[doc = "Overall vehicle length.. The unit of this type is mm"]
        #[doc = r" Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(&mut self, value: crate::v3::units::Millimetre<u16>) {
            assert!(Self::bounds_check(&value));
            self.value = value;
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &crate::v3::units::Millimetre<u16>) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(value: crate::v3::units::Millimetre<u16>) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self { value })
            } else {
                None
            }
        }
    }
    #[doc = "Overall vehicle height.. The unit of this type is mm"]
    #[allow(non_camel_case_types)]
    #[repr(C)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct Height {
        pub value: crate::v3::units::Millimetre<u16>,
    }
    impl Height {
        #[doc = r" Get the "]
        #[doc = "Overall vehicle height.. The unit of this type is mm"]
        pub fn value(&self) -> &crate::v3::units::Millimetre<u16> {
            &self.value
        }
        #[doc = r" Set the"]
        #[doc = "Overall vehicle height.. The unit of this type is mm"]
        #[doc = r" Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(&mut self, value: crate::v3::units::Millimetre<u16>) {
            assert!(Self::bounds_check(&value));
            self.value = value;
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &crate::v3::units::Millimetre<u16>) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(value: crate::v3::units::Millimetre<u16>) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self { value })
            } else {
                None
            }
        }
    }
    #[doc = "Overall vehicle width.. The unit of this type is mm"]
    #[allow(non_camel_case_types)]
    #[repr(C)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct Width {
        pub value: crate::v3::units::Millimetre<u16>,
    }
    impl Width {
        #[doc = r" Get the "]
        #[doc = "Overall vehicle width.. The unit of this type is mm"]
        pub fn value(&self) -> &crate::v3::units::Millimetre<u16> {
            &self.value
        }
        #[doc = r" Set the"]
        #[doc = "Overall vehicle width.. The unit of this type is mm"]
        #[doc = r" Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(&mut self, value: crate::v3::units::Millimetre<u16>) {
            assert!(Self::bounds_check(&value));
            self.value = value;
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &crate::v3::units::Millimetre<u16>) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(value: crate::v3::units::Millimetre<u16>) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self { value })
            } else {
                None
            }
        }
    }
    #[allow(non_snake_case)]
    pub mod connectivity {
        use cdds_derive::Topic;
        use cyclonedds_rs::*;
        #[doc = "Indicates if connectivity between vehicle and cloud is available. True = Connectivity is available. False = Connectivity is not available.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct IsConnectivityAvailable {
            pub value: bool,
            pub timestamp: crate::v3::Timestamp,
        }
        impl IsConnectivityAvailable {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Indicates if connectivity between vehicle and cloud is available. True = Connectivity is available. False = Connectivity is not available.. This type has no unit defined"]
            pub fn value(&self) -> &bool {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "Indicates if connectivity between vehicle and cloud is available. True = Connectivity is available. False = Connectivity is not available.. This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &bool) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
    }
    #[allow(non_snake_case)]
    pub mod service {
        use cdds_derive::Topic;
        use cyclonedds_rs::*;
        #[doc = "Indicates if vehicle needs service (of any kind). True = Service needed now or in the near future. False = No known need for service.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct IsServiceDue {
            pub value: bool,
            pub timestamp: crate::v3::Timestamp,
        }
        impl IsServiceDue {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Indicates if vehicle needs service (of any kind). True = Service needed now or in the near future. False = No known need for service.. This type has no unit defined"]
            pub fn value(&self) -> &bool {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "Indicates if vehicle needs service (of any kind). True = Service needed now or in the near future. False = No known need for service.. This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &bool) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Remaining distance to service (of any kind). Negative values indicate service overdue.. The unit of this type is km"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct DistanceToService {
            pub value: crate::v3::units::Kilometre<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl DistanceToService {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Remaining distance to service (of any kind). Negative values indicate service overdue.. The unit of this type is km"]
            pub fn value(&self) -> &crate::v3::units::Kilometre<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "Remaining distance to service (of any kind). Negative values indicate service overdue.. The unit of this type is km"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Kilometre<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Kilometre<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Kilometre<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Remaining time to service (of any kind). Negative values indicate service overdue.. The unit of this type is s"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct TimeToService {
            pub value: crate::v3::units::Second<i32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl TimeToService {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Remaining time to service (of any kind). Negative values indicate service overdue.. The unit of this type is s"]
            pub fn value(&self) -> &crate::v3::units::Second<i32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "Remaining time to service (of any kind). Negative values indicate service overdue.. The unit of this type is s"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Second<i32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Second<i32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Second<i32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
    }
    #[allow(non_snake_case)]
    pub mod exterior {
        use cdds_derive::Topic;
        use cyclonedds_rs::*;
        #[doc = "Air temperature outside the vehicle.. The unit of this type is celsius"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct AirTemperature {
            pub value: crate::v3::units::Celsius<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl AirTemperature {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Air temperature outside the vehicle.. The unit of this type is celsius"]
            pub fn value(&self) -> &crate::v3::units::Celsius<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "Air temperature outside the vehicle.. The unit of this type is celsius"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Celsius<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Celsius<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Celsius<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Relative humidity outside the vehicle. 0 = Dry, 100 = Air fully saturated.. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Humidity {
            pub value: crate::v3::units::Percent<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl Humidity {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Relative humidity outside the vehicle. 0 = Dry, 100 = Air fully saturated.. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v3::units::Percent<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "Relative humidity outside the vehicle. 0 = Dry, 100 = Air fully saturated.. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Percent<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. Return true if the value is"]
            #[doc = r"within bounds."]
            pub fn bounds_check(v: &crate::v3::units::Percent<f32>) -> bool {
                v.0 <= 100f32 && v.0 >= 0f32
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Percent<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Light intensity outside the vehicle. 0 = No light detected, 100 = Fully lit.. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct LightIntensity {
            pub value: crate::v3::units::Percent<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl LightIntensity {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Light intensity outside the vehicle. 0 = No light detected, 100 = Fully lit.. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v3::units::Percent<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "Light intensity outside the vehicle. 0 = No light detected, 100 = Fully lit.. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Percent<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. Return true if the value is"]
            #[doc = r"within bounds."]
            pub fn bounds_check(v: &crate::v3::units::Percent<f32>) -> bool {
                v.0 <= 100f32 && v.0 >= 0f32
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Percent<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
    }
    #[allow(non_snake_case)]
    pub mod driver {
        use cdds_derive::Topic;
        use cyclonedds_rs::*;
        #[doc = "Distraction level of the driver will be the level how much the driver is distracted, by multiple factors. E.g. Driving situation, acustical or optical signales inside the cockpit, phone calls.. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct DistractionLevel {
            pub value: crate::v3::units::Percent<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl DistractionLevel {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Distraction level of the driver will be the level how much the driver is distracted, by multiple factors. E.g. Driving situation, acustical or optical signales inside the cockpit, phone calls.. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v3::units::Percent<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "Distraction level of the driver will be the level how much the driver is distracted, by multiple factors. E.g. Driving situation, acustical or optical signales inside the cockpit, phone calls.. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Percent<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. Return true if the value is"]
            #[doc = r"within bounds."]
            pub fn bounds_check(v: &crate::v3::units::Percent<f32>) -> bool {
                v.0 <= 100f32 && v.0 >= 0f32
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Percent<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Has driver the eyes on road or not?. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct IsEyesOnRoad {
            pub value: bool,
            pub timestamp: crate::v3::Timestamp,
        }
        impl IsEyesOnRoad {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Has driver the eyes on road or not?. This type has no unit defined"]
            pub fn value(&self) -> &bool {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "Has driver the eyes on road or not?. This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &bool) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Probability of attentiveness of the driver.. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct AttentiveProbability {
            pub value: crate::v3::units::Percent<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl AttentiveProbability {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Probability of attentiveness of the driver.. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v3::units::Percent<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "Probability of attentiveness of the driver.. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Percent<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. Return true if the value is"]
            #[doc = r"within bounds."]
            pub fn bounds_check(v: &crate::v3::units::Percent<f32>) -> bool {
                v.0 <= 100f32 && v.0 >= 0f32
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Percent<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Fatigueness level of driver. Evaluated by multiple factors like trip time, behaviour of steering, eye status.. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct FatigueLevel {
            pub value: crate::v3::units::Percent<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl FatigueLevel {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Fatigueness level of driver. Evaluated by multiple factors like trip time, behaviour of steering, eye status.. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v3::units::Percent<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "Fatigueness level of driver. Evaluated by multiple factors like trip time, behaviour of steering, eye status.. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Percent<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. Return true if the value is"]
            #[doc = r"within bounds."]
            pub fn bounds_check(v: &crate::v3::units::Percent<f32>) -> bool {
                v.0 <= 100f32 && v.0 >= 0f32
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Percent<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Heart rate of the driver.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct HeartRate {
            pub value: u16,
            pub timestamp: crate::v3::Timestamp,
        }
        impl HeartRate {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Heart rate of the driver.. This type has no unit defined"]
            pub fn value(&self) -> &u16 {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "Heart rate of the driver.. This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u16, maybe_timestamp: Option<crate::v3::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u16) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u16, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod identifier {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Subject for the authentication of the occupant. E.g. UserID 7331677.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Subject {
                pub value: String,
                pub timestamp: crate::v3::Timestamp,
            }
            impl Subject {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Subject for the authentication of the occupant. E.g. UserID 7331677.. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Subject for the authentication of the occupant. E.g. UserID 7331677.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: String,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Unique Issuer for the authentication of the occupant. E.g. https://accounts.funcorp.com.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Issuer {
                pub value: String,
                pub timestamp: crate::v3::Timestamp,
            }
            impl Issuer {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Unique Issuer for the authentication of the occupant. E.g. https://accounts.funcorp.com.. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Unique Issuer for the authentication of the occupant. E.g. https://accounts.funcorp.com.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: String,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
    }
    #[allow(non_snake_case)]
    pub mod obd {
        use cdds_derive::Topic;
        use cyclonedds_rs::*;
        #[doc = "PID 00 - Bit array of the supported pids 01 to 20. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct PidsA {
            pub value: u32,
            pub timestamp: crate::v3::Timestamp,
        }
        impl PidsA {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 00 - Bit array of the supported pids 01 to 20. This type has no unit defined"]
            pub fn value(&self) -> &u32 {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 00 - Bit array of the supported pids 01 to 20. This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u32, maybe_timestamp: Option<crate::v3::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u32) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u32, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "List of currently active DTCs formatted according OBD II (SAE-J2012DA_201812) standard ([P|C|B|U]XXXXX ). This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct DTCList {
            pub value: Vec<String>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl DTCList {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "List of currently active DTCs formatted according OBD II (SAE-J2012DA_201812) standard ([P|C|B|U]XXXXX ). This type has no unit defined"]
            pub fn value(&self) -> &Vec<String> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "List of currently active DTCs formatted according OBD II (SAE-J2012DA_201812) standard ([P|C|B|U]XXXXX ). This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: Vec<String>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &Vec<String>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: Vec<String>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 02 - DTC that triggered the freeze frame. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct FreezeDTC {
            pub value: String,
            pub timestamp: crate::v3::Timestamp,
        }
        impl FreezeDTC {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 02 - DTC that triggered the freeze frame. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 02 - DTC that triggered the freeze frame. This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String, maybe_timestamp: Option<crate::v3::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 03 - Fuel status. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct FuelStatus {
            pub value: String,
            pub timestamp: crate::v3::Timestamp,
        }
        impl FuelStatus {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 03 - Fuel status. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 03 - Fuel status. This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String, maybe_timestamp: Option<crate::v3::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 04 - Engine load in percent - 0 = no load, 100 = full load. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct EngineLoad {
            pub value: crate::v3::units::Percent<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl EngineLoad {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 04 - Engine load in percent - 0 = no load, 100 = full load. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v3::units::Percent<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 04 - Engine load in percent - 0 = no load, 100 = full load. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Percent<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Percent<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 05 - Coolant temperature. The unit of this type is celsius"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct CoolantTemperature {
            pub value: crate::v3::units::Celsius<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl CoolantTemperature {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 05 - Coolant temperature. The unit of this type is celsius"]
            pub fn value(&self) -> &crate::v3::units::Celsius<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 05 - Coolant temperature. The unit of this type is celsius"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Celsius<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Celsius<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Celsius<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 06 - Short Term (immediate) Fuel Trim - Bank 1 - negative percent leaner, positive percent richer. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct ShortTermFuelTrim1 {
            pub value: crate::v3::units::Percent<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl ShortTermFuelTrim1 {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 06 - Short Term (immediate) Fuel Trim - Bank 1 - negative percent leaner, positive percent richer. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v3::units::Percent<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 06 - Short Term (immediate) Fuel Trim - Bank 1 - negative percent leaner, positive percent richer. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Percent<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Percent<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 07 - Long Term (learned) Fuel Trim - Bank 1 - negative percent leaner, positive percent richer. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct LongTermFuelTrim1 {
            pub value: crate::v3::units::Percent<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl LongTermFuelTrim1 {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 07 - Long Term (learned) Fuel Trim - Bank 1 - negative percent leaner, positive percent richer. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v3::units::Percent<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 07 - Long Term (learned) Fuel Trim - Bank 1 - negative percent leaner, positive percent richer. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Percent<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Percent<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 08 - Short Term (immediate) Fuel Trim - Bank 2 - negative percent leaner, positive percent richer. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct ShortTermFuelTrim2 {
            pub value: crate::v3::units::Percent<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl ShortTermFuelTrim2 {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 08 - Short Term (immediate) Fuel Trim - Bank 2 - negative percent leaner, positive percent richer. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v3::units::Percent<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 08 - Short Term (immediate) Fuel Trim - Bank 2 - negative percent leaner, positive percent richer. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Percent<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Percent<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 09 - Long Term (learned) Fuel Trim - Bank 2 - negative percent leaner, positive percent richer. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct LongTermFuelTrim2 {
            pub value: crate::v3::units::Percent<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl LongTermFuelTrim2 {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 09 - Long Term (learned) Fuel Trim - Bank 2 - negative percent leaner, positive percent richer. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v3::units::Percent<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 09 - Long Term (learned) Fuel Trim - Bank 2 - negative percent leaner, positive percent richer. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Percent<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Percent<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 0A - Fuel pressure. The unit of this type is kPa"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct FuelPressure {
            pub value: crate::v3::units::KiloPascal<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl FuelPressure {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 0A - Fuel pressure. The unit of this type is kPa"]
            pub fn value(&self) -> &crate::v3::units::KiloPascal<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 0A - Fuel pressure. The unit of this type is kPa"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::KiloPascal<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::KiloPascal<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::KiloPascal<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 0B - Intake manifold pressure. The unit of this type is kPa"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct MAP {
            pub value: crate::v3::units::KiloPascal<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl MAP {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 0B - Intake manifold pressure. The unit of this type is kPa"]
            pub fn value(&self) -> &crate::v3::units::KiloPascal<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 0B - Intake manifold pressure. The unit of this type is kPa"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::KiloPascal<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::KiloPascal<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::KiloPascal<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 0C - Engine speed measured as rotations per minute. The unit of this type is rpm"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct EngineSpeed {
            pub value: crate::v3::units::RPM<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl EngineSpeed {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 0C - Engine speed measured as rotations per minute. The unit of this type is rpm"]
            pub fn value(&self) -> &crate::v3::units::RPM<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 0C - Engine speed measured as rotations per minute. The unit of this type is rpm"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::RPM<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::RPM<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::RPM<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 0D - Vehicle speed. The unit of this type is km/h"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Speed {
            pub value: crate::v3::units::KilometrePerHour<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl Speed {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 0D - Vehicle speed. The unit of this type is km/h"]
            pub fn value(&self) -> &crate::v3::units::KilometrePerHour<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 0D - Vehicle speed. The unit of this type is km/h"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::KilometrePerHour<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::KilometrePerHour<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::KilometrePerHour<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 0E - Time advance. The unit of this type is degrees"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct TimingAdvance {
            pub value: f32,
            pub timestamp: crate::v3::Timestamp,
        }
        impl TimingAdvance {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 0E - Time advance. The unit of this type is degrees"]
            pub fn value(&self) -> &f32 {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 0E - Time advance. The unit of this type is degrees"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: f32, maybe_timestamp: Option<crate::v3::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &f32) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: f32, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 0F - Intake temperature. The unit of this type is celsius"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct IntakeTemp {
            pub value: crate::v3::units::Celsius<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl IntakeTemp {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 0F - Intake temperature. The unit of this type is celsius"]
            pub fn value(&self) -> &crate::v3::units::Celsius<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 0F - Intake temperature. The unit of this type is celsius"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Celsius<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Celsius<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Celsius<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 10 - Grams of air drawn into engine per second. The unit of this type is g/s"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct MAF {
            pub value: crate::v3::units::GramPerSec<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl MAF {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 10 - Grams of air drawn into engine per second. The unit of this type is g/s"]
            pub fn value(&self) -> &crate::v3::units::GramPerSec<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 10 - Grams of air drawn into engine per second. The unit of this type is g/s"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::GramPerSec<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::GramPerSec<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::GramPerSec<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 11 - Throttle position - 0 = closed throttle, 100 = open throttle. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct ThrottlePosition {
            pub value: crate::v3::units::Percent<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl ThrottlePosition {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 11 - Throttle position - 0 = closed throttle, 100 = open throttle. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v3::units::Percent<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 11 - Throttle position - 0 = closed throttle, 100 = open throttle. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Percent<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Percent<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 12 - Secondary air status. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct AirStatus {
            pub value: String,
            pub timestamp: crate::v3::Timestamp,
        }
        impl AirStatus {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 12 - Secondary air status. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 12 - Secondary air status. This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String, maybe_timestamp: Option<crate::v3::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 13 - Presence of oxygen sensors in 2 banks. [A0..A3] == Bank 1, Sensors 1-4. [A4..A7] == Bank 2, Sensors 1-4. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct OxygenSensorsIn2Banks {
            pub value: u8,
            pub timestamp: crate::v3::Timestamp,
        }
        impl OxygenSensorsIn2Banks {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 13 - Presence of oxygen sensors in 2 banks. [A0..A3] == Bank 1, Sensors 1-4. [A4..A7] == Bank 2, Sensors 1-4. This type has no unit defined"]
            pub fn value(&self) -> &u8 {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 13 - Presence of oxygen sensors in 2 banks. [A0..A3] == Bank 1, Sensors 1-4. [A4..A7] == Bank 2, Sensors 1-4. This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u8, maybe_timestamp: Option<crate::v3::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u8) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u8, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 1C - OBD standards this vehicle conforms to. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct OBDStandards {
            pub value: u8,
        }
        impl OBDStandards {
            #[doc = r" Get the "]
            #[doc = "PID 1C - OBD standards this vehicle conforms to. This type has no unit defined"]
            pub fn value(&self) -> &u8 {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 1C - OBD standards this vehicle conforms to. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u8) {
                assert!(Self::bounds_check(&value));
                self.value = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u8) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u8) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { value })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 1D - Presence of oxygen sensors in 4 banks. Similar to PID 13, but [A0..A7] == [B1S1, B1S2, B2S1, B2S2, B3S1, B3S2, B4S1, B4S2]. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct OxygenSensorsIn4Banks {
            pub value: u8,
            pub timestamp: crate::v3::Timestamp,
        }
        impl OxygenSensorsIn4Banks {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 1D - Presence of oxygen sensors in 4 banks. Similar to PID 13, but [A0..A7] == [B1S1, B1S2, B2S1, B2S2, B3S1, B3S2, B4S1, B4S2]. This type has no unit defined"]
            pub fn value(&self) -> &u8 {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 1D - Presence of oxygen sensors in 4 banks. Similar to PID 13, but [A0..A7] == [B1S1, B1S2, B2S1, B2S2, B3S1, B3S2, B4S1, B4S2]. This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u8, maybe_timestamp: Option<crate::v3::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u8) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u8, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 1E - Auxiliary input status (power take off). This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct IsPTOActive {
            pub value: bool,
            pub timestamp: crate::v3::Timestamp,
        }
        impl IsPTOActive {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 1E - Auxiliary input status (power take off). This type has no unit defined"]
            pub fn value(&self) -> &bool {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 1E - Auxiliary input status (power take off). This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &bool) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 1F - Engine run time. The unit of this type is s"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct RunTime {
            pub value: crate::v3::units::Second<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl RunTime {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 1F - Engine run time. The unit of this type is s"]
            pub fn value(&self) -> &crate::v3::units::Second<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 1F - Engine run time. The unit of this type is s"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Second<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Second<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Second<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 20 - Bit array of the supported pids 21 to 40. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct PidsB {
            pub value: u32,
            pub timestamp: crate::v3::Timestamp,
        }
        impl PidsB {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 20 - Bit array of the supported pids 21 to 40. This type has no unit defined"]
            pub fn value(&self) -> &u32 {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 20 - Bit array of the supported pids 21 to 40. This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u32, maybe_timestamp: Option<crate::v3::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u32) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u32, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 21 - Distance traveled with MIL on. The unit of this type is km"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct DistanceWithMIL {
            pub value: crate::v3::units::Kilometre<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl DistanceWithMIL {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 21 - Distance traveled with MIL on. The unit of this type is km"]
            pub fn value(&self) -> &crate::v3::units::Kilometre<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 21 - Distance traveled with MIL on. The unit of this type is km"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Kilometre<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Kilometre<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Kilometre<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 22 - Fuel rail pressure relative to vacuum. The unit of this type is kPa"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct FuelRailPressureVac {
            pub value: crate::v3::units::KiloPascal<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl FuelRailPressureVac {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 22 - Fuel rail pressure relative to vacuum. The unit of this type is kPa"]
            pub fn value(&self) -> &crate::v3::units::KiloPascal<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 22 - Fuel rail pressure relative to vacuum. The unit of this type is kPa"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::KiloPascal<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::KiloPascal<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::KiloPascal<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 23 - Fuel rail pressure direct inject. The unit of this type is kPa"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct FuelRailPressureDirect {
            pub value: crate::v3::units::KiloPascal<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl FuelRailPressureDirect {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 23 - Fuel rail pressure direct inject. The unit of this type is kPa"]
            pub fn value(&self) -> &crate::v3::units::KiloPascal<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 23 - Fuel rail pressure direct inject. The unit of this type is kPa"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::KiloPascal<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::KiloPascal<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::KiloPascal<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 2C - Commanded exhaust gas recirculation (EGR). The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct CommandedEGR {
            pub value: crate::v3::units::Percent<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl CommandedEGR {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 2C - Commanded exhaust gas recirculation (EGR). The unit of this type is percent"]
            pub fn value(&self) -> &crate::v3::units::Percent<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 2C - Commanded exhaust gas recirculation (EGR). The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Percent<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Percent<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 2D - Exhaust gas recirculation (EGR) error. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct EGRError {
            pub value: crate::v3::units::Percent<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl EGRError {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 2D - Exhaust gas recirculation (EGR) error. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v3::units::Percent<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 2D - Exhaust gas recirculation (EGR) error. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Percent<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Percent<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 2E - Commanded evaporative purge (EVAP) valve. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct CommandedEVAP {
            pub value: crate::v3::units::Percent<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl CommandedEVAP {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 2E - Commanded evaporative purge (EVAP) valve. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v3::units::Percent<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 2E - Commanded evaporative purge (EVAP) valve. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Percent<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Percent<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 2F - Fuel level in the fuel tank. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct FuelLevel {
            pub value: crate::v3::units::Percent<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl FuelLevel {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 2F - Fuel level in the fuel tank. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v3::units::Percent<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 2F - Fuel level in the fuel tank. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Percent<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Percent<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 30 - Number of warm-ups since codes cleared. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct WarmupsSinceDTCClear {
            pub value: u8,
            pub timestamp: crate::v3::Timestamp,
        }
        impl WarmupsSinceDTCClear {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 30 - Number of warm-ups since codes cleared. This type has no unit defined"]
            pub fn value(&self) -> &u8 {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 30 - Number of warm-ups since codes cleared. This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u8, maybe_timestamp: Option<crate::v3::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u8) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u8, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 31 - Distance traveled since codes cleared. The unit of this type is km"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct DistanceSinceDTCClear {
            pub value: crate::v3::units::Kilometre<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl DistanceSinceDTCClear {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 31 - Distance traveled since codes cleared. The unit of this type is km"]
            pub fn value(&self) -> &crate::v3::units::Kilometre<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 31 - Distance traveled since codes cleared. The unit of this type is km"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Kilometre<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Kilometre<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Kilometre<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 32 - Evaporative purge (EVAP) system pressure. The unit of this type is Pa"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct EVAPVaporPressure {
            pub value: crate::v3::units::Pascal<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl EVAPVaporPressure {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 32 - Evaporative purge (EVAP) system pressure. The unit of this type is Pa"]
            pub fn value(&self) -> &crate::v3::units::Pascal<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 32 - Evaporative purge (EVAP) system pressure. The unit of this type is Pa"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Pascal<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Pascal<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Pascal<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 33 - Barometric pressure. The unit of this type is kPa"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct BarometricPressure {
            pub value: crate::v3::units::KiloPascal<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl BarometricPressure {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 33 - Barometric pressure. The unit of this type is kPa"]
            pub fn value(&self) -> &crate::v3::units::KiloPascal<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 33 - Barometric pressure. The unit of this type is kPa"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::KiloPascal<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::KiloPascal<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::KiloPascal<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 40 - Bit array of the supported pids 41 to 60. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct PidsC {
            pub value: u32,
            pub timestamp: crate::v3::Timestamp,
        }
        impl PidsC {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 40 - Bit array of the supported pids 41 to 60. This type has no unit defined"]
            pub fn value(&self) -> &u32 {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 40 - Bit array of the supported pids 41 to 60. This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u32, maybe_timestamp: Option<crate::v3::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u32) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u32, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 42 - Control module voltage. The unit of this type is V"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct ControlModuleVoltage {
            pub value: crate::v3::units::Volt<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl ControlModuleVoltage {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 42 - Control module voltage. The unit of this type is V"]
            pub fn value(&self) -> &crate::v3::units::Volt<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 42 - Control module voltage. The unit of this type is V"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Volt<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Volt<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Volt<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 43 - Absolute load value. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct AbsoluteLoad {
            pub value: crate::v3::units::Percent<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl AbsoluteLoad {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 43 - Absolute load value. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v3::units::Percent<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 43 - Absolute load value. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Percent<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Percent<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 44 - Commanded equivalence ratio. The unit of this type is ratio"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct CommandedEquivalenceRatio {
            pub value: crate::v3::units::Ratio<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl CommandedEquivalenceRatio {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 44 - Commanded equivalence ratio. The unit of this type is ratio"]
            pub fn value(&self) -> &crate::v3::units::Ratio<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 44 - Commanded equivalence ratio. The unit of this type is ratio"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Ratio<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Ratio<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Ratio<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 45 - Relative throttle position. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct RelativeThrottlePosition {
            pub value: crate::v3::units::Percent<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl RelativeThrottlePosition {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 45 - Relative throttle position. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v3::units::Percent<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 45 - Relative throttle position. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Percent<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Percent<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 46 - Ambient air temperature. The unit of this type is celsius"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct AmbientAirTemperature {
            pub value: crate::v3::units::Celsius<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl AmbientAirTemperature {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 46 - Ambient air temperature. The unit of this type is celsius"]
            pub fn value(&self) -> &crate::v3::units::Celsius<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 46 - Ambient air temperature. The unit of this type is celsius"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Celsius<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Celsius<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Celsius<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 47 - Absolute throttle position B. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct ThrottlePositionB {
            pub value: crate::v3::units::Percent<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl ThrottlePositionB {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 47 - Absolute throttle position B. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v3::units::Percent<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 47 - Absolute throttle position B. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Percent<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Percent<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 48 - Absolute throttle position C. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct ThrottlePositionC {
            pub value: crate::v3::units::Percent<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl ThrottlePositionC {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 48 - Absolute throttle position C. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v3::units::Percent<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 48 - Absolute throttle position C. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Percent<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Percent<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 49 - Accelerator pedal position D. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct AcceleratorPositionD {
            pub value: crate::v3::units::Percent<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl AcceleratorPositionD {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 49 - Accelerator pedal position D. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v3::units::Percent<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 49 - Accelerator pedal position D. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Percent<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Percent<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 4A - Accelerator pedal position E. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct AcceleratorPositionE {
            pub value: crate::v3::units::Percent<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl AcceleratorPositionE {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 4A - Accelerator pedal position E. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v3::units::Percent<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 4A - Accelerator pedal position E. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Percent<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Percent<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 4B - Accelerator pedal position F. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct AcceleratorPositionF {
            pub value: crate::v3::units::Percent<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl AcceleratorPositionF {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 4B - Accelerator pedal position F. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v3::units::Percent<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 4B - Accelerator pedal position F. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Percent<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Percent<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 4C - Commanded throttle actuator. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct ThrottleActuator {
            pub value: crate::v3::units::Percent<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl ThrottleActuator {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 4C - Commanded throttle actuator. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v3::units::Percent<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 4C - Commanded throttle actuator. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Percent<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Percent<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 4D - Run time with MIL on. The unit of this type is min"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct RunTimeMIL {
            pub value: crate::v3::units::Minute<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl RunTimeMIL {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 4D - Run time with MIL on. The unit of this type is min"]
            pub fn value(&self) -> &crate::v3::units::Minute<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 4D - Run time with MIL on. The unit of this type is min"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Minute<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Minute<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Minute<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 4E - Time since trouble codes cleared. The unit of this type is min"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct TimeSinceDTCCleared {
            pub value: crate::v3::units::Minute<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl TimeSinceDTCCleared {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 4E - Time since trouble codes cleared. The unit of this type is min"]
            pub fn value(&self) -> &crate::v3::units::Minute<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 4E - Time since trouble codes cleared. The unit of this type is min"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Minute<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Minute<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Minute<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 50 - Maximum flow for mass air flow sensor. The unit of this type is g/s"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct MaxMAF {
            pub value: crate::v3::units::GramPerSec<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl MaxMAF {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 50 - Maximum flow for mass air flow sensor. The unit of this type is g/s"]
            pub fn value(&self) -> &crate::v3::units::GramPerSec<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 50 - Maximum flow for mass air flow sensor. The unit of this type is g/s"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::GramPerSec<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::GramPerSec<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::GramPerSec<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 51 - Fuel type. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct FuelType {
            pub value: String,
            pub timestamp: crate::v3::Timestamp,
        }
        impl FuelType {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 51 - Fuel type. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 51 - Fuel type. This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String, maybe_timestamp: Option<crate::v3::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 52 - Percentage of ethanol in the fuel. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct EthanolPercent {
            pub value: crate::v3::units::Percent<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl EthanolPercent {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 52 - Percentage of ethanol in the fuel. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v3::units::Percent<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 52 - Percentage of ethanol in the fuel. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Percent<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Percent<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 53 - Absolute evaporative purge (EVAP) system pressure. The unit of this type is kPa"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct EVAPVaporPressureAbsolute {
            pub value: crate::v3::units::KiloPascal<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl EVAPVaporPressureAbsolute {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 53 - Absolute evaporative purge (EVAP) system pressure. The unit of this type is kPa"]
            pub fn value(&self) -> &crate::v3::units::KiloPascal<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 53 - Absolute evaporative purge (EVAP) system pressure. The unit of this type is kPa"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::KiloPascal<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::KiloPascal<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::KiloPascal<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 54 - Alternate evaporative purge (EVAP) system pressure. The unit of this type is Pa"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct EVAPVaporPressureAlternate {
            pub value: crate::v3::units::Pascal<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl EVAPVaporPressureAlternate {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 54 - Alternate evaporative purge (EVAP) system pressure. The unit of this type is Pa"]
            pub fn value(&self) -> &crate::v3::units::Pascal<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 54 - Alternate evaporative purge (EVAP) system pressure. The unit of this type is Pa"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Pascal<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Pascal<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Pascal<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 55 (byte A) - Short term secondary O2 trim - Bank 1. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct ShortTermO2Trim1 {
            pub value: crate::v3::units::Percent<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl ShortTermO2Trim1 {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 55 (byte A) - Short term secondary O2 trim - Bank 1. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v3::units::Percent<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 55 (byte A) - Short term secondary O2 trim - Bank 1. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Percent<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Percent<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 55 (byte B) - Short term secondary O2 trim - Bank 3. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct ShortTermO2Trim3 {
            pub value: crate::v3::units::Percent<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl ShortTermO2Trim3 {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 55 (byte B) - Short term secondary O2 trim - Bank 3. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v3::units::Percent<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 55 (byte B) - Short term secondary O2 trim - Bank 3. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Percent<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Percent<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 56 (byte A) - Long term secondary O2 trim - Bank 1. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct LongTermO2Trim1 {
            pub value: crate::v3::units::Percent<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl LongTermO2Trim1 {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 56 (byte A) - Long term secondary O2 trim - Bank 1. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v3::units::Percent<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 56 (byte A) - Long term secondary O2 trim - Bank 1. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Percent<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Percent<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 56 (byte B) - Long term secondary O2 trim - Bank 3. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct LongTermO2Trim3 {
            pub value: crate::v3::units::Percent<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl LongTermO2Trim3 {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 56 (byte B) - Long term secondary O2 trim - Bank 3. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v3::units::Percent<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 56 (byte B) - Long term secondary O2 trim - Bank 3. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Percent<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Percent<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 57 (byte A) - Short term secondary O2 trim - Bank 2. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct ShortTermO2Trim2 {
            pub value: crate::v3::units::Percent<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl ShortTermO2Trim2 {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 57 (byte A) - Short term secondary O2 trim - Bank 2. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v3::units::Percent<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 57 (byte A) - Short term secondary O2 trim - Bank 2. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Percent<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Percent<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 57 (byte B) - Short term secondary O2 trim - Bank 4. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct ShortTermO2Trim4 {
            pub value: crate::v3::units::Percent<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl ShortTermO2Trim4 {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 57 (byte B) - Short term secondary O2 trim - Bank 4. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v3::units::Percent<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 57 (byte B) - Short term secondary O2 trim - Bank 4. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Percent<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Percent<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 58 (byte A) - Long term secondary O2 trim - Bank 2. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct LongTermO2Trim2 {
            pub value: crate::v3::units::Percent<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl LongTermO2Trim2 {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 58 (byte A) - Long term secondary O2 trim - Bank 2. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v3::units::Percent<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 58 (byte A) - Long term secondary O2 trim - Bank 2. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Percent<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Percent<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 58 (byte B) - Long term secondary O2 trim - Bank 4. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct LongTermO2Trim4 {
            pub value: crate::v3::units::Percent<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl LongTermO2Trim4 {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 58 (byte B) - Long term secondary O2 trim - Bank 4. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v3::units::Percent<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 58 (byte B) - Long term secondary O2 trim - Bank 4. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Percent<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Percent<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 59 - Absolute fuel rail pressure. The unit of this type is kPa"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct FuelRailPressureAbsolute {
            pub value: crate::v3::units::KiloPascal<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl FuelRailPressureAbsolute {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 59 - Absolute fuel rail pressure. The unit of this type is kPa"]
            pub fn value(&self) -> &crate::v3::units::KiloPascal<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 59 - Absolute fuel rail pressure. The unit of this type is kPa"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::KiloPascal<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::KiloPascal<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::KiloPascal<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 5A - Relative accelerator pedal position. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct RelativeAcceleratorPosition {
            pub value: crate::v3::units::Percent<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl RelativeAcceleratorPosition {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 5A - Relative accelerator pedal position. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v3::units::Percent<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 5A - Relative accelerator pedal position. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Percent<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Percent<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 5B - Remaining life of hybrid battery. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct HybridBatteryRemaining {
            pub value: crate::v3::units::Percent<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl HybridBatteryRemaining {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 5B - Remaining life of hybrid battery. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v3::units::Percent<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 5B - Remaining life of hybrid battery. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Percent<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Percent<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 5C - Engine oil temperature. The unit of this type is celsius"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct OilTemperature {
            pub value: crate::v3::units::Celsius<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl OilTemperature {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 5C - Engine oil temperature. The unit of this type is celsius"]
            pub fn value(&self) -> &crate::v3::units::Celsius<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 5C - Engine oil temperature. The unit of this type is celsius"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Celsius<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Celsius<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Celsius<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 5D - Fuel injection timing. The unit of this type is degrees"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct FuelInjectionTiming {
            pub value: f32,
            pub timestamp: crate::v3::Timestamp,
        }
        impl FuelInjectionTiming {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 5D - Fuel injection timing. The unit of this type is degrees"]
            pub fn value(&self) -> &f32 {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 5D - Fuel injection timing. The unit of this type is degrees"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: f32, maybe_timestamp: Option<crate::v3::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &f32) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: f32, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 5E - Engine fuel rate. The unit of this type is l/h"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct FuelRate {
            pub value: crate::v3::units::LiterPerHour<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl FuelRate {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 5E - Engine fuel rate. The unit of this type is l/h"]
            pub fn value(&self) -> &crate::v3::units::LiterPerHour<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "PID 5E - Engine fuel rate. The unit of this type is l/h"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::LiterPerHour<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::LiterPerHour<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::LiterPerHour<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod drivecyclestatus {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Malfunction Indicator Light (MIL) - False = Off, True = On. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsMILOn {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsMILOn {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Malfunction Indicator Light (MIL) - False = Off, True = On. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Malfunction Indicator Light (MIL) - False = Off, True = On. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Number of sensor Trouble Codes (DTC). This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct DTCCount {
                pub value: u8,
                pub timestamp: crate::v3::Timestamp,
            }
            impl DTCCount {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Number of sensor Trouble Codes (DTC). This type has no unit defined"]
                pub fn value(&self) -> &u8 {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Number of sensor Trouble Codes (DTC). This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: u8, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &u8) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: u8, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Type of the ignition for ICE - spark = spark plug ignition, compression = self-igniting (Diesel engines). This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IgnitionType {
                pub value: String,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IgnitionType {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Type of the ignition for ICE - spark = spark plug ignition, compression = self-igniting (Diesel engines). This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Type of the ignition for ICE - spark = spark plug ignition, compression = self-igniting (Diesel engines). This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: String,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod catalyst {
            #[allow(non_snake_case)]
            pub mod bank2 {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "PID 3D - Catalyst temperature from bank 2, sensor 1. The unit of this type is celsius"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Temperature1 {
                    pub value: crate::v3::units::Celsius<f32>,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub bank: u8,
                }
                impl Temperature1 {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 3D - Catalyst temperature from bank 2, sensor 1. The unit of this type is celsius"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,bank)"]
                    pub fn value(&self) -> (&crate::v3::units::Celsius<f32>, &u8) {
                        (&self.value, &self.bank)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 3D - Catalyst temperature from bank 2, sensor 1. The unit of this type is celsius"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Celsius<f32>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        bank: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.bank = bank;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v3::units::Celsius<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Celsius<f32>,
                        timestamp: Option<crate::v3::Timestamp>,
                        bank: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                bank,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 3F - Catalyst temperature from bank 2, sensor 2. The unit of this type is celsius"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Temperature2 {
                    pub value: crate::v3::units::Celsius<f32>,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub bank: u8,
                }
                impl Temperature2 {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 3F - Catalyst temperature from bank 2, sensor 2. The unit of this type is celsius"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,bank)"]
                    pub fn value(&self) -> (&crate::v3::units::Celsius<f32>, &u8) {
                        (&self.value, &self.bank)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 3F - Catalyst temperature from bank 2, sensor 2. The unit of this type is celsius"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Celsius<f32>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        bank: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.bank = bank;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v3::units::Celsius<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Celsius<f32>,
                        timestamp: Option<crate::v3::Timestamp>,
                        bank: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                bank,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod bank1 {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "PID 3C - Catalyst temperature from bank 1, sensor 1. The unit of this type is celsius"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Temperature1 {
                    pub value: crate::v3::units::Celsius<f32>,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub bank: u8,
                }
                impl Temperature1 {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 3C - Catalyst temperature from bank 1, sensor 1. The unit of this type is celsius"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,bank)"]
                    pub fn value(&self) -> (&crate::v3::units::Celsius<f32>, &u8) {
                        (&self.value, &self.bank)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 3C - Catalyst temperature from bank 1, sensor 1. The unit of this type is celsius"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Celsius<f32>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        bank: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.bank = bank;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v3::units::Celsius<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Celsius<f32>,
                        timestamp: Option<crate::v3::Timestamp>,
                        bank: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                bank,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 3E - Catalyst temperature from bank 1, sensor 2. The unit of this type is celsius"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Temperature2 {
                    pub value: crate::v3::units::Celsius<f32>,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub bank: u8,
                }
                impl Temperature2 {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 3E - Catalyst temperature from bank 1, sensor 2. The unit of this type is celsius"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,bank)"]
                    pub fn value(&self) -> (&crate::v3::units::Celsius<f32>, &u8) {
                        (&self.value, &self.bank)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 3E - Catalyst temperature from bank 1, sensor 2. The unit of this type is celsius"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Celsius<f32>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        bank: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.bank = bank;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v3::units::Celsius<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Celsius<f32>,
                        timestamp: Option<crate::v3::Timestamp>,
                        bank: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                bank,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod o2wr {
            #[allow(non_snake_case)]
            pub mod sensor8 {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Lambda {
                    pub value: f32,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub sensor: u8,
                }
                impl Lambda {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&f32, &u8) {
                        (&self.value, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: f32,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &f32) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: f32,
                        timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Voltage {
                    pub value: crate::v3::units::Volt<f32>,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub sensor: u8,
                }
                impl Voltage {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v3::units::Volt<f32>, &u8) {
                        (&self.value, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Volt<f32>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v3::units::Volt<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Volt<f32>,
                        timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Current {
                    pub value: crate::v3::units::Amp<f32>,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub sensor: u8,
                }
                impl Current {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v3::units::Amp<f32>, &u8) {
                        (&self.value, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Amp<f32>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v3::units::Amp<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Amp<f32>,
                        timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod sensor7 {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Lambda {
                    pub value: f32,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub sensor: u8,
                }
                impl Lambda {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&f32, &u8) {
                        (&self.value, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: f32,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &f32) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: f32,
                        timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Voltage {
                    pub value: crate::v3::units::Volt<f32>,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub sensor: u8,
                }
                impl Voltage {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v3::units::Volt<f32>, &u8) {
                        (&self.value, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Volt<f32>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v3::units::Volt<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Volt<f32>,
                        timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Current {
                    pub value: crate::v3::units::Amp<f32>,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub sensor: u8,
                }
                impl Current {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v3::units::Amp<f32>, &u8) {
                        (&self.value, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Amp<f32>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v3::units::Amp<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Amp<f32>,
                        timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod sensor6 {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Lambda {
                    pub value: f32,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub sensor: u8,
                }
                impl Lambda {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&f32, &u8) {
                        (&self.value, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: f32,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &f32) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: f32,
                        timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Voltage {
                    pub value: crate::v3::units::Volt<f32>,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub sensor: u8,
                }
                impl Voltage {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v3::units::Volt<f32>, &u8) {
                        (&self.value, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Volt<f32>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v3::units::Volt<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Volt<f32>,
                        timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Current {
                    pub value: crate::v3::units::Amp<f32>,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub sensor: u8,
                }
                impl Current {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v3::units::Amp<f32>, &u8) {
                        (&self.value, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Amp<f32>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v3::units::Amp<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Amp<f32>,
                        timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod sensor5 {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Lambda {
                    pub value: f32,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub sensor: u8,
                }
                impl Lambda {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&f32, &u8) {
                        (&self.value, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: f32,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &f32) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: f32,
                        timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Voltage {
                    pub value: crate::v3::units::Volt<f32>,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub sensor: u8,
                }
                impl Voltage {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v3::units::Volt<f32>, &u8) {
                        (&self.value, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Volt<f32>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v3::units::Volt<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Volt<f32>,
                        timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Current {
                    pub value: crate::v3::units::Amp<f32>,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub sensor: u8,
                }
                impl Current {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v3::units::Amp<f32>, &u8) {
                        (&self.value, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Amp<f32>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v3::units::Amp<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Amp<f32>,
                        timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod sensor4 {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Lambda {
                    pub value: f32,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub sensor: u8,
                }
                impl Lambda {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&f32, &u8) {
                        (&self.value, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: f32,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &f32) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: f32,
                        timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Voltage {
                    pub value: crate::v3::units::Volt<f32>,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub sensor: u8,
                }
                impl Voltage {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v3::units::Volt<f32>, &u8) {
                        (&self.value, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Volt<f32>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v3::units::Volt<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Volt<f32>,
                        timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Current {
                    pub value: crate::v3::units::Amp<f32>,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub sensor: u8,
                }
                impl Current {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v3::units::Amp<f32>, &u8) {
                        (&self.value, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Amp<f32>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v3::units::Amp<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Amp<f32>,
                        timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod sensor3 {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Lambda {
                    pub value: f32,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub sensor: u8,
                }
                impl Lambda {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&f32, &u8) {
                        (&self.value, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: f32,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &f32) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: f32,
                        timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Voltage {
                    pub value: crate::v3::units::Volt<f32>,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub sensor: u8,
                }
                impl Voltage {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v3::units::Volt<f32>, &u8) {
                        (&self.value, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Volt<f32>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v3::units::Volt<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Volt<f32>,
                        timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Current {
                    pub value: crate::v3::units::Amp<f32>,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub sensor: u8,
                }
                impl Current {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v3::units::Amp<f32>, &u8) {
                        (&self.value, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Amp<f32>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v3::units::Amp<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Amp<f32>,
                        timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod sensor2 {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Lambda {
                    pub value: f32,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub sensor: u8,
                }
                impl Lambda {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&f32, &u8) {
                        (&self.value, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: f32,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &f32) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: f32,
                        timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Voltage {
                    pub value: crate::v3::units::Volt<f32>,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub sensor: u8,
                }
                impl Voltage {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v3::units::Volt<f32>, &u8) {
                        (&self.value, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Volt<f32>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v3::units::Volt<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Volt<f32>,
                        timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Current {
                    pub value: crate::v3::units::Amp<f32>,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub sensor: u8,
                }
                impl Current {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v3::units::Amp<f32>, &u8) {
                        (&self.value, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Amp<f32>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v3::units::Amp<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Amp<f32>,
                        timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod sensor1 {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Lambda {
                    pub value: f32,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub sensor: u8,
                }
                impl Lambda {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&f32, &u8) {
                        (&self.value, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: f32,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &f32) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: f32,
                        timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Voltage {
                    pub value: crate::v3::units::Volt<f32>,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub sensor: u8,
                }
                impl Voltage {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v3::units::Volt<f32>, &u8) {
                        (&self.value, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Volt<f32>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v3::units::Volt<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Volt<f32>,
                        timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Current {
                    pub value: crate::v3::units::Amp<f32>,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub sensor: u8,
                }
                impl Current {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v3::units::Amp<f32>, &u8) {
                        (&self.value, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Amp<f32>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v3::units::Amp<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Amp<f32>,
                        timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod o2 {
            #[allow(non_snake_case)]
            pub mod sensor8 {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "PID 1x (byte A) - Sensor voltage. The unit of this type is V"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Voltage {
                    pub value: crate::v3::units::Volt<f32>,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub sensor: u8,
                }
                impl Voltage {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 1x (byte A) - Sensor voltage. The unit of this type is V"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v3::units::Volt<f32>, &u8) {
                        (&self.value, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 1x (byte A) - Sensor voltage. The unit of this type is V"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Volt<f32>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v3::units::Volt<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Volt<f32>,
                        timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 1x (byte B) - Short term fuel trim. The unit of this type is percent"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct ShortTermFuelTrim {
                    pub value: crate::v3::units::Percent<f32>,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub sensor: u8,
                }
                impl ShortTermFuelTrim {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 1x (byte B) - Short term fuel trim. The unit of this type is percent"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v3::units::Percent<f32>, &u8) {
                        (&self.value, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 1x (byte B) - Short term fuel trim. The unit of this type is percent"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Percent<f32>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v3::units::Percent<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Percent<f32>,
                        timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod sensor7 {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "PID 1x (byte A) - Sensor voltage. The unit of this type is V"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Voltage {
                    pub value: crate::v3::units::Volt<f32>,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub sensor: u8,
                }
                impl Voltage {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 1x (byte A) - Sensor voltage. The unit of this type is V"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v3::units::Volt<f32>, &u8) {
                        (&self.value, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 1x (byte A) - Sensor voltage. The unit of this type is V"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Volt<f32>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v3::units::Volt<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Volt<f32>,
                        timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 1x (byte B) - Short term fuel trim. The unit of this type is percent"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct ShortTermFuelTrim {
                    pub value: crate::v3::units::Percent<f32>,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub sensor: u8,
                }
                impl ShortTermFuelTrim {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 1x (byte B) - Short term fuel trim. The unit of this type is percent"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v3::units::Percent<f32>, &u8) {
                        (&self.value, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 1x (byte B) - Short term fuel trim. The unit of this type is percent"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Percent<f32>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v3::units::Percent<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Percent<f32>,
                        timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod sensor6 {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "PID 1x (byte A) - Sensor voltage. The unit of this type is V"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Voltage {
                    pub value: crate::v3::units::Volt<f32>,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub sensor: u8,
                }
                impl Voltage {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 1x (byte A) - Sensor voltage. The unit of this type is V"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v3::units::Volt<f32>, &u8) {
                        (&self.value, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 1x (byte A) - Sensor voltage. The unit of this type is V"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Volt<f32>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v3::units::Volt<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Volt<f32>,
                        timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 1x (byte B) - Short term fuel trim. The unit of this type is percent"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct ShortTermFuelTrim {
                    pub value: crate::v3::units::Percent<f32>,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub sensor: u8,
                }
                impl ShortTermFuelTrim {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 1x (byte B) - Short term fuel trim. The unit of this type is percent"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v3::units::Percent<f32>, &u8) {
                        (&self.value, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 1x (byte B) - Short term fuel trim. The unit of this type is percent"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Percent<f32>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v3::units::Percent<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Percent<f32>,
                        timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod sensor5 {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "PID 1x (byte A) - Sensor voltage. The unit of this type is V"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Voltage {
                    pub value: crate::v3::units::Volt<f32>,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub sensor: u8,
                }
                impl Voltage {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 1x (byte A) - Sensor voltage. The unit of this type is V"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v3::units::Volt<f32>, &u8) {
                        (&self.value, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 1x (byte A) - Sensor voltage. The unit of this type is V"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Volt<f32>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v3::units::Volt<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Volt<f32>,
                        timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 1x (byte B) - Short term fuel trim. The unit of this type is percent"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct ShortTermFuelTrim {
                    pub value: crate::v3::units::Percent<f32>,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub sensor: u8,
                }
                impl ShortTermFuelTrim {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 1x (byte B) - Short term fuel trim. The unit of this type is percent"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v3::units::Percent<f32>, &u8) {
                        (&self.value, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 1x (byte B) - Short term fuel trim. The unit of this type is percent"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Percent<f32>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v3::units::Percent<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Percent<f32>,
                        timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod sensor4 {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "PID 1x (byte A) - Sensor voltage. The unit of this type is V"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Voltage {
                    pub value: crate::v3::units::Volt<f32>,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub sensor: u8,
                }
                impl Voltage {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 1x (byte A) - Sensor voltage. The unit of this type is V"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v3::units::Volt<f32>, &u8) {
                        (&self.value, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 1x (byte A) - Sensor voltage. The unit of this type is V"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Volt<f32>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v3::units::Volt<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Volt<f32>,
                        timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 1x (byte B) - Short term fuel trim. The unit of this type is percent"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct ShortTermFuelTrim {
                    pub value: crate::v3::units::Percent<f32>,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub sensor: u8,
                }
                impl ShortTermFuelTrim {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 1x (byte B) - Short term fuel trim. The unit of this type is percent"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v3::units::Percent<f32>, &u8) {
                        (&self.value, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 1x (byte B) - Short term fuel trim. The unit of this type is percent"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Percent<f32>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v3::units::Percent<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Percent<f32>,
                        timestamp: Option<crate::v3::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod status {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Malfunction Indicator Light (MIL) False = Off, True = On. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsMILOn {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsMILOn {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Malfunction Indicator Light (MIL) False = Off, True = On. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Malfunction Indicator Light (MIL) False = Off, True = On. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Number of sensor Trouble Codes (DTC). This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct DTCCount {
                pub value: u8,
                pub timestamp: crate::v3::Timestamp,
            }
            impl DTCCount {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Number of sensor Trouble Codes (DTC). This type has no unit defined"]
                pub fn value(&self) -> &u8 {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Number of sensor Trouble Codes (DTC). This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: u8, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &u8) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: u8, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Type of the ignition for ICE - spark = spark plug ignition, compression = self-igniting (Diesel engines). This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IgnitionType {
                pub value: String,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IgnitionType {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Type of the ignition for ICE - spark = spark plug ignition, compression = self-igniting (Diesel engines). This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Type of the ignition for ICE - spark = spark plug ignition, compression = self-igniting (Diesel engines). This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: String,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
    }
    #[allow(non_snake_case)]
    pub mod chassis {
        use cdds_derive::Topic;
        use cyclonedds_rs::*;
        #[doc = "Overall wheel base, in mm.. The unit of this type is mm"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Wheelbase {
            pub value: crate::v3::units::Millimetre<u16>,
        }
        impl Wheelbase {
            #[doc = r" Get the "]
            #[doc = "Overall wheel base, in mm.. The unit of this type is mm"]
            pub fn value(&self) -> &crate::v3::units::Millimetre<u16> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "Overall wheel base, in mm.. The unit of this type is mm"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: crate::v3::units::Millimetre<u16>) {
                assert!(Self::bounds_check(&value));
                self.value = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Millimetre<u16>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: crate::v3::units::Millimetre<u16>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { value })
                } else {
                    None
                }
            }
        }
        #[doc = "Overall wheel tracking, in mm.. The unit of this type is mm"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Track {
            pub value: crate::v3::units::Millimetre<u16>,
        }
        impl Track {
            #[doc = r" Get the "]
            #[doc = "Overall wheel tracking, in mm.. The unit of this type is mm"]
            pub fn value(&self) -> &crate::v3::units::Millimetre<u16> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "Overall wheel tracking, in mm.. The unit of this type is mm"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: crate::v3::units::Millimetre<u16>) {
                assert!(Self::bounds_check(&value));
                self.value = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Millimetre<u16>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: crate::v3::units::Millimetre<u16>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { value })
                } else {
                    None
                }
            }
        }
        #[doc = "Number of axles on the vehicle. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct AxleCount {
            pub value: u8,
        }
        impl AxleCount {
            #[doc = r" Get the "]
            #[doc = "Number of axles on the vehicle. This type has no unit defined"]
            pub fn value(&self) -> &u8 {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "Number of axles on the vehicle. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u8) {
                assert!(Self::bounds_check(&value));
                self.value = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u8) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u8) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { value })
                } else {
                    None
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod brake {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Brake pedal position as percent. 0 = Not depressed. 100 = Fully depressed.. The unit of this type is percent"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct PedalPosition {
                pub value: crate::v3::units::Percent<u8>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl PedalPosition {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Brake pedal position as percent. 0 = Not depressed. 100 = Fully depressed.. The unit of this type is percent"]
                pub fn value(&self) -> &crate::v3::units::Percent<u8> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Brake pedal position as percent. 0 = Not depressed. 100 = Fully depressed.. The unit of this type is percent"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::Percent<u8>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v3::units::Percent<u8>) -> bool {
                    v.0 <= 100u8 && v.0 >= 0u8
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::Percent<u8>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates if emergency braking initiated by driver is detected. True = Emergency braking detected. False = Emergency braking not detected.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsDriverEmergencyBrakingDetected {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsDriverEmergencyBrakingDetected {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if emergency braking initiated by driver is detected. True = Emergency braking detected. False = Emergency braking not detected.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if emergency braking initiated by driver is detected. True = Emergency braking detected. False = Emergency braking not detected.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod accelerator {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Accelerator pedal position as percent. 0 = Not depressed. 100 = Fully depressed.. The unit of this type is percent"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct PedalPosition {
                pub value: crate::v3::units::Percent<u8>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl PedalPosition {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Accelerator pedal position as percent. 0 = Not depressed. 100 = Fully depressed.. The unit of this type is percent"]
                pub fn value(&self) -> &crate::v3::units::Percent<u8> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Accelerator pedal position as percent. 0 = Not depressed. 100 = Fully depressed.. The unit of this type is percent"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::Percent<u8>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v3::units::Percent<u8>) -> bool {
                    v.0 <= 100u8 && v.0 >= 0u8
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::Percent<u8>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod steeringwheel {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Steering wheel angle. Positive = degrees to the left. Negative = degrees to the right.. The unit of this type is degrees"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Angle {
                pub value: i16,
                pub timestamp: crate::v3::Timestamp,
            }
            impl Angle {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Steering wheel angle. Positive = degrees to the left. Negative = degrees to the right.. The unit of this type is degrees"]
                pub fn value(&self) -> &i16 {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Steering wheel angle. Positive = degrees to the left. Negative = degrees to the right.. The unit of this type is degrees"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: i16, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &i16) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: i16, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Steering wheel column tilt. 0 = Lowest position. 100 = Highest position.. The unit of this type is percent"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Tilt {
                pub value: crate::v3::units::Percent<u8>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl Tilt {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Steering wheel column tilt. 0 = Lowest position. 100 = Highest position.. The unit of this type is percent"]
                pub fn value(&self) -> &crate::v3::units::Percent<u8> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Steering wheel column tilt. 0 = Lowest position. 100 = Highest position.. The unit of this type is percent"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::Percent<u8>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v3::units::Percent<u8>) -> bool {
                    v.0 <= 100u8 && v.0 >= 0u8
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::Percent<u8>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Steering wheel column extension from dashboard. 0 = Closest to dashboard. 100 = Furthest from dashboard.. The unit of this type is percent"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Extension {
                pub value: crate::v3::units::Percent<u8>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl Extension {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Steering wheel column extension from dashboard. 0 = Closest to dashboard. 100 = Furthest from dashboard.. The unit of this type is percent"]
                pub fn value(&self) -> &crate::v3::units::Percent<u8> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Steering wheel column extension from dashboard. 0 = Closest to dashboard. 100 = Furthest from dashboard.. The unit of this type is percent"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::Percent<u8>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v3::units::Percent<u8>) -> bool {
                    v.0 <= 100u8 && v.0 >= 0u8
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::Percent<u8>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Position of the steering wheel on the left or right side of the vehicle.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Position {
                pub value: String,
            }
            impl Position {
                #[doc = r" Get the "]
                #[doc = "Position of the steering wheel on the left or right side of the vehicle.. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Position of the steering wheel on the left or right side of the vehicle.. This type has no unit defined"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: String) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { value })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod parkingbrake {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Parking brake status. True = Parking Brake is Engaged. False = Parking Brake is not Engaged.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsEngaged {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsEngaged {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Parking brake status. True = Parking Brake is Engaged. False = Parking Brake is not Engaged.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Parking brake status. True = Parking Brake is Engaged. False = Parking Brake is not Engaged.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod axle {
            #[allow(non_snake_case)]
            pub mod wheel {
                #[allow(non_snake_case)]
                pub mod brake {
                    use cdds_derive::Topic;
                    use cyclonedds_rs::*;
                    #[doc = "Brake fluid level as percent. 0 = Empty. 100 = Full.. The unit of this type is percent"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct FluidLevel {
                        pub value: crate::v3::units::Percent<u8>,
                        pub timestamp: crate::v3::Timestamp,
                        #[topic_key]
                        pub row: u8,
                        #[topic_key_enum]
                        pub side: crate::v3::Side,
                    }
                    impl FluidLevel {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Brake fluid level as percent. 0 = Empty. 100 = Full.. The unit of this type is percent"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, side)"]
                        pub fn value(
                            &self,
                        ) -> (&crate::v3::units::Percent<u8>, &u8, &crate::v3::Side)
                        {
                            (&self.value, &self.row, &self.side)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Brake fluid level as percent. 0 = Empty. 100 = Full.. The unit of this type is percent"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: crate::v3::units::Percent<u8>,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                            row: u8,
                            side: crate::v3::Side,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            self.row = row;
                            self.side = side;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. Return true if the value is"]
                        #[doc = r"within bounds."]
                        pub fn bounds_check(v: &crate::v3::units::Percent<u8>) -> bool {
                            v.0 <= 100u8 && true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: crate::v3::units::Percent<u8>,
                            timestamp: Option<crate::v3::Timestamp>,
                            row: u8,
                            side: crate::v3::Side,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    side,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Brake fluid level status. True = Brake fluid level low. False = Brake fluid level OK.. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct IsFluidLevelLow {
                        pub value: bool,
                        pub timestamp: crate::v3::Timestamp,
                        #[topic_key]
                        pub row: u8,
                        #[topic_key_enum]
                        pub side: crate::v3::Side,
                    }
                    impl IsFluidLevelLow {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Brake fluid level status. True = Brake fluid level low. False = Brake fluid level OK.. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, side)"]
                        pub fn value(&self) -> (&bool, &u8, &crate::v3::Side) {
                            (&self.value, &self.row, &self.side)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Brake fluid level status. True = Brake fluid level low. False = Brake fluid level OK.. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                            row: u8,
                            side: crate::v3::Side,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            self.row = row;
                            self.side = side;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v3::Timestamp>,
                            row: u8,
                            side: crate::v3::Side,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    side,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Brake pad wear as percent. 0 = No Wear. 100 = Worn.. The unit of this type is percent"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct PadWear {
                        pub value: crate::v3::units::Percent<u8>,
                        pub timestamp: crate::v3::Timestamp,
                        #[topic_key]
                        pub row: u8,
                        #[topic_key_enum]
                        pub side: crate::v3::Side,
                    }
                    impl PadWear {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Brake pad wear as percent. 0 = No Wear. 100 = Worn.. The unit of this type is percent"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, side)"]
                        pub fn value(
                            &self,
                        ) -> (&crate::v3::units::Percent<u8>, &u8, &crate::v3::Side)
                        {
                            (&self.value, &self.row, &self.side)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Brake pad wear as percent. 0 = No Wear. 100 = Worn.. The unit of this type is percent"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: crate::v3::units::Percent<u8>,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                            row: u8,
                            side: crate::v3::Side,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            self.row = row;
                            self.side = side;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. Return true if the value is"]
                        #[doc = r"within bounds."]
                        pub fn bounds_check(v: &crate::v3::units::Percent<u8>) -> bool {
                            v.0 <= 100u8 && true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: crate::v3::units::Percent<u8>,
                            timestamp: Option<crate::v3::Timestamp>,
                            row: u8,
                            side: crate::v3::Side,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    side,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Brake pad wear status. True = Worn. False = Not Worn.. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct IsBrakesWorn {
                        pub value: bool,
                        pub timestamp: crate::v3::Timestamp,
                        #[topic_key]
                        pub row: u8,
                        #[topic_key_enum]
                        pub side: crate::v3::Side,
                    }
                    impl IsBrakesWorn {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Brake pad wear status. True = Worn. False = Not Worn.. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, side)"]
                        pub fn value(&self) -> (&bool, &u8, &crate::v3::Side) {
                            (&self.value, &self.row, &self.side)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Brake pad wear status. True = Worn. False = Not Worn.. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                            row: u8,
                            side: crate::v3::Side,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            self.row = row;
                            self.side = side;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v3::Timestamp>,
                            row: u8,
                            side: crate::v3::Side,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    side,
                                })
                            } else {
                                None
                            }
                        }
                    }
                }
                #[allow(non_snake_case)]
                pub mod tire {
                    use cdds_derive::Topic;
                    use cyclonedds_rs::*;
                    #[doc = "Tire pressure in kilo-Pascal.. The unit of this type is kPa"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Pressure {
                        pub value: crate::v3::units::KiloPascal<u16>,
                        pub timestamp: crate::v3::Timestamp,
                        #[topic_key]
                        pub row: u8,
                        #[topic_key_enum]
                        pub side: crate::v3::Side,
                    }
                    impl Pressure {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Tire pressure in kilo-Pascal.. The unit of this type is kPa"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, side)"]
                        pub fn value(
                            &self,
                        ) -> (&crate::v3::units::KiloPascal<u16>, &u8, &crate::v3::Side)
                        {
                            (&self.value, &self.row, &self.side)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Tire pressure in kilo-Pascal.. The unit of this type is kPa"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: crate::v3::units::KiloPascal<u16>,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                            row: u8,
                            side: crate::v3::Side,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            self.row = row;
                            self.side = side;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &crate::v3::units::KiloPascal<u16>) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: crate::v3::units::KiloPascal<u16>,
                            timestamp: Option<crate::v3::Timestamp>,
                            row: u8,
                            side: crate::v3::Side,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    side,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Tire Pressure Status. True = Low tire pressure. False = Good tire pressure.. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct IsPressureLow {
                        pub value: bool,
                        pub timestamp: crate::v3::Timestamp,
                        #[topic_key]
                        pub row: u8,
                        #[topic_key_enum]
                        pub side: crate::v3::Side,
                    }
                    impl IsPressureLow {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Tire Pressure Status. True = Low tire pressure. False = Good tire pressure.. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, side)"]
                        pub fn value(&self) -> (&bool, &u8, &crate::v3::Side) {
                            (&self.value, &self.row, &self.side)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Tire Pressure Status. True = Low tire pressure. False = Good tire pressure.. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                            row: u8,
                            side: crate::v3::Side,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            self.row = row;
                            self.side = side;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v3::Timestamp>,
                            row: u8,
                            side: crate::v3::Side,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    side,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Tire temperature in Celsius.. The unit of this type is celsius"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Temperature {
                        pub value: crate::v3::units::Celsius<f32>,
                        pub timestamp: crate::v3::Timestamp,
                        #[topic_key]
                        pub row: u8,
                        #[topic_key_enum]
                        pub side: crate::v3::Side,
                    }
                    impl Temperature {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Tire temperature in Celsius.. The unit of this type is celsius"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, side)"]
                        pub fn value(
                            &self,
                        ) -> (&crate::v3::units::Celsius<f32>, &u8, &crate::v3::Side)
                        {
                            (&self.value, &self.row, &self.side)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Tire temperature in Celsius.. The unit of this type is celsius"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: crate::v3::units::Celsius<f32>,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                            row: u8,
                            side: crate::v3::Side,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            self.row = row;
                            self.side = side;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &crate::v3::units::Celsius<f32>) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: crate::v3::units::Celsius<f32>,
                            timestamp: Option<crate::v3::Timestamp>,
                            row: u8,
                            side: crate::v3::Side,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    side,
                                })
                            } else {
                                None
                            }
                        }
                    }
                }
            }
        }
    }
    #[allow(non_snake_case)]
    pub mod adas {
        use cdds_derive::Topic;
        use cyclonedds_rs::*;
        #[doc = "Indicates the currently active level of autonomy according to SAE J3016 taxonomy.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct ActiveAutonomyLevel {
            pub value: String,
            pub timestamp: crate::v3::Timestamp,
        }
        impl ActiveAutonomyLevel {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Indicates the currently active level of autonomy according to SAE J3016 taxonomy.. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "Indicates the currently active level of autonomy according to SAE J3016 taxonomy.. This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String, maybe_timestamp: Option<crate::v3::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Indicates the highest level of autonomy according to SAE J3016 taxonomy the vehicle is capable of.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct SupportedAutonomyLevel {
            pub value: String,
        }
        impl SupportedAutonomyLevel {
            #[doc = r" Get the "]
            #[doc = "Indicates the highest level of autonomy according to SAE J3016 taxonomy the vehicle is capable of.. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "Indicates the highest level of autonomy according to SAE J3016 taxonomy the vehicle is capable of.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.value = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { value })
                } else {
                    None
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod eba {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Indicates if EBA is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsEnabled {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsEnabled {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if EBA is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if EBA is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates if EBA incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsError {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsError {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if EBA incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if EBA incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates if EBA is currently regulating brake pressure. True = Engaged. False = Not Engaged.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsEngaged {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsEngaged {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if EBA is currently regulating brake pressure. True = Engaged. False = Not Engaged.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if EBA is currently regulating brake pressure. True = Engaged. False = Not Engaged.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod ebd {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Indicates if EBD is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsEnabled {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsEnabled {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if EBD is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if EBD is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates if EBD incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsError {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsError {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if EBD incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if EBD incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates if EBD is currently regulating vehicle brakeforce distribution. True = Engaged. False = Not Engaged.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsEngaged {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsEngaged {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if EBD is currently regulating vehicle brakeforce distribution. True = Engaged. False = Not Engaged.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if EBD is currently regulating vehicle brakeforce distribution. True = Engaged. False = Not Engaged.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod esc {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Indicates if ESC is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsEnabled {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsEnabled {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if ESC is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if ESC is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates if ESC incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsError {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsError {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if ESC incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if ESC incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates if ESC is currently regulating vehicle stability. True = Engaged. False = Not Engaged.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsEngaged {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsEngaged {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if ESC is currently regulating vehicle stability. True = Engaged. False = Not Engaged.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if ESC is currently regulating vehicle stability. True = Engaged. False = Not Engaged.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates if the ESC system is detecting strong cross winds. True = Strong cross winds detected. False = No strong cross winds detected.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsStrongCrossWindDetected {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsStrongCrossWindDetected {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if the ESC system is detecting strong cross winds. True = Strong cross winds detected. False = No strong cross winds detected.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if the ESC system is detecting strong cross winds. True = Strong cross winds detected. False = No strong cross winds detected.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod roadfriction {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Most probable road friction, as calculated by the ESC system. Exact meaning of most probable is implementation specific. 0 = no friction, 100 = maximum friction.. The unit of this type is percent"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct MostProbable {
                    pub value: crate::v3::units::Percent<f32>,
                    pub timestamp: crate::v3::Timestamp,
                }
                impl MostProbable {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Most probable road friction, as calculated by the ESC system. Exact meaning of most probable is implementation specific. 0 = no friction, 100 = maximum friction.. The unit of this type is percent"]
                    pub fn value(&self) -> &crate::v3::units::Percent<f32> {
                        &self.value
                    }
                    #[doc = r" Set the"]
                    #[doc = "Most probable road friction, as calculated by the ESC system. Exact meaning of most probable is implementation specific. 0 = no friction, 100 = maximum friction.. The unit of this type is percent"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Percent<f32>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v3::units::Percent<f32>) -> bool {
                        v.0 <= 100f32 && v.0 >= 0f32
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Percent<f32>,
                        timestamp: Option<crate::v3::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Lower bound road friction, as calculated by the ESC system. 5% possibility that road friction is below this value. 0 = no friction, 100 = maximum friction.. The unit of this type is percent"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct LowerBound {
                    pub value: crate::v3::units::Percent<f32>,
                    pub timestamp: crate::v3::Timestamp,
                }
                impl LowerBound {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Lower bound road friction, as calculated by the ESC system. 5% possibility that road friction is below this value. 0 = no friction, 100 = maximum friction.. The unit of this type is percent"]
                    pub fn value(&self) -> &crate::v3::units::Percent<f32> {
                        &self.value
                    }
                    #[doc = r" Set the"]
                    #[doc = "Lower bound road friction, as calculated by the ESC system. 5% possibility that road friction is below this value. 0 = no friction, 100 = maximum friction.. The unit of this type is percent"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Percent<f32>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v3::units::Percent<f32>) -> bool {
                        v.0 <= 100f32 && v.0 >= 0f32
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Percent<f32>,
                        timestamp: Option<crate::v3::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Upper bound road friction, as calculated by the ESC system. 95% possibility that road friction is below this value. 0 = no friction, 100 = maximum friction.. The unit of this type is percent"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct UpperBound {
                    pub value: crate::v3::units::Percent<f32>,
                    pub timestamp: crate::v3::Timestamp,
                }
                impl UpperBound {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Upper bound road friction, as calculated by the ESC system. 95% possibility that road friction is below this value. 0 = no friction, 100 = maximum friction.. The unit of this type is percent"]
                    pub fn value(&self) -> &crate::v3::units::Percent<f32> {
                        &self.value
                    }
                    #[doc = r" Set the"]
                    #[doc = "Upper bound road friction, as calculated by the ESC system. 95% possibility that road friction is below this value. 0 = no friction, 100 = maximum friction.. The unit of this type is percent"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Percent<f32>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v3::units::Percent<f32>) -> bool {
                        v.0 <= 100f32 && v.0 >= 0f32
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Percent<f32>,
                        timestamp: Option<crate::v3::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod tcs {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Indicates if TCS is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsEnabled {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsEnabled {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if TCS is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if TCS is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates if TCS incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsError {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsError {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if TCS incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if TCS incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates if TCS is currently regulating traction. True = Engaged. False = Not Engaged.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsEngaged {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsEngaged {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if TCS is currently regulating traction. True = Engaged. False = Not Engaged.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if TCS is currently regulating traction. True = Engaged. False = Not Engaged.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod abs {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Indicates if ABS is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsEnabled {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsEnabled {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if ABS is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if ABS is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates if ABS incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsError {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsError {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if ABS incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if ABS incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates if ABS is currently regulating brake pressure. True = Engaged. False = Not Engaged.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsEngaged {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsEngaged {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if ABS is currently regulating brake pressure. True = Engaged. False = Not Engaged.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if ABS is currently regulating brake pressure. True = Engaged. False = Not Engaged.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod obstacledetection {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Indicates if obstacle sensor system is enabled (i.e. monitoring for obstacles). True = Enabled. False = Disabled.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsEnabled {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsEnabled {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if obstacle sensor system is enabled (i.e. monitoring for obstacles). True = Enabled. False = Disabled.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if obstacle sensor system is enabled (i.e. monitoring for obstacles). True = Enabled. False = Disabled.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates if obstacle sensor system registered an obstacle.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsWarning {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsWarning {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if obstacle sensor system registered an obstacle.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if obstacle sensor system registered an obstacle.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates if obstacle sensor system incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsError {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsError {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if obstacle sensor system incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if obstacle sensor system incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod lanedeparturedetection {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Indicates if lane departure detection system is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsEnabled {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsEnabled {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if lane departure detection system is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if lane departure detection system is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates if lane departure detection registered a lane departure.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsWarning {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsWarning {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if lane departure detection registered a lane departure.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if lane departure detection registered a lane departure.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates if lane departure system incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsError {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsError {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if lane departure system incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if lane departure system incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod cruisecontrol {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Indicates if cruise control system is enabled (e.g. ready to receive configurations and settings) True = Enabled. False = Disabled.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsEnabled {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsEnabled {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if cruise control system is enabled (e.g. ready to receive configurations and settings) True = Enabled. False = Disabled.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if cruise control system is enabled (e.g. ready to receive configurations and settings) True = Enabled. False = Disabled.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates if cruise control system is active (i.e. actively controls speed). True = Active. False = Inactive.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsActive {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsActive {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if cruise control system is active (i.e. actively controls speed). True = Active. False = Inactive.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if cruise control system is active (i.e. actively controls speed). True = Active. False = Inactive.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Set cruise control speed in kilometers per hour.. The unit of this type is km/h"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct SpeedSet {
                pub value: crate::v3::units::KilometrePerHour<f32>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl SpeedSet {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Set cruise control speed in kilometers per hour.. The unit of this type is km/h"]
                pub fn value(&self) -> &crate::v3::units::KilometrePerHour<f32> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Set cruise control speed in kilometers per hour.. The unit of this type is km/h"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::KilometrePerHour<f32>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v3::units::KilometrePerHour<f32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::KilometrePerHour<f32>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates if cruise control system incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsError {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsError {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if cruise control system incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if cruise control system incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
    }
    #[allow(non_snake_case)]
    pub mod cabin {
        use cdds_derive::Topic;
        use cyclonedds_rs::*;
        #[doc = "Number of doors in vehicle.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct DoorCount {
            pub value: u8,
        }
        impl DoorCount {
            #[doc = r" Get the "]
            #[doc = "Number of doors in vehicle.. This type has no unit defined"]
            pub fn value(&self) -> &u8 {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "Number of doors in vehicle.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u8) {
                assert!(Self::bounds_check(&value));
                self.value = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u8) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u8) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { value })
                } else {
                    None
                }
            }
        }
        #[doc = "The position of the driver seat in row 1.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct DriverPosition {
            pub value: u8,
        }
        impl DriverPosition {
            #[doc = r" Get the "]
            #[doc = "The position of the driver seat in row 1.. This type has no unit defined"]
            pub fn value(&self) -> &u8 {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "The position of the driver seat in row 1.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u8) {
                assert!(Self::bounds_check(&value));
                self.value = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u8) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u8) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { value })
                } else {
                    None
                }
            }
        }
        #[doc = "Number of seat rows in vehicle.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct SeatRowCount {
            pub value: u8,
        }
        impl SeatRowCount {
            #[doc = r" Get the "]
            #[doc = "Number of seat rows in vehicle.. This type has no unit defined"]
            pub fn value(&self) -> &u8 {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "Number of seat rows in vehicle.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u8) {
                assert!(Self::bounds_check(&value));
                self.value = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u8) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u8) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { value })
                } else {
                    None
                }
            }
        }
        #[doc = "Number of seats across each row from the front to the rear.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct SeatPosCount {
            pub value: Vec<u8>,
        }
        impl SeatPosCount {
            #[doc = r" Get the "]
            #[doc = "Number of seats across each row from the front to the rear.. This type has no unit defined"]
            pub fn value(&self) -> &Vec<u8> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "Number of seats across each row from the front to the rear.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: Vec<u8>) {
                assert!(Self::bounds_check(&value));
                self.value = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &Vec<u8>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: Vec<u8>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { value })
                } else {
                    None
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod convertible {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Roof status on convertible vehicles.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Status {
                pub value: String,
                pub timestamp: crate::v3::Timestamp,
            }
            impl Status {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Roof status on convertible vehicles.. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Roof status on convertible vehicles.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: String,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod seat {
            #[allow(non_snake_case)]
            pub mod occupant {
                #[allow(non_snake_case)]
                pub mod identifier {
                    use cdds_derive::Topic;
                    use cyclonedds_rs::*;
                    #[doc = "Subject for the authentication of the occupant. E.g. UserID 7331677.. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Subject {
                        pub value: String,
                        pub timestamp: crate::v3::Timestamp,
                        #[topic_key]
                        pub row: u8,
                        #[topic_key]
                        pub pos: u8,
                    }
                    impl Subject {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Subject for the authentication of the occupant. E.g. UserID 7331677.. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, pos)"]
                        pub fn value(&self) -> (&String, &u8, &u8) {
                            (&self.value, &self.row, &self.pos)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Subject for the authentication of the occupant. E.g. UserID 7331677.. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: String,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            self.row = row;
                            self.pos = pos;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &String) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: String,
                            timestamp: Option<crate::v3::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    pos,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Unique Issuer for the authentication of the occupant. E.g. https://accounts.funcorp.com.. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Issuer {
                        pub value: String,
                        pub timestamp: crate::v3::Timestamp,
                        #[topic_key]
                        pub row: u8,
                        #[topic_key]
                        pub pos: u8,
                    }
                    impl Issuer {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Unique Issuer for the authentication of the occupant. E.g. https://accounts.funcorp.com.. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, pos)"]
                        pub fn value(&self) -> (&String, &u8, &u8) {
                            (&self.value, &self.row, &self.pos)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Unique Issuer for the authentication of the occupant. E.g. https://accounts.funcorp.com.. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: String,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            self.row = row;
                            self.pos = pos;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &String) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: String,
                            timestamp: Option<crate::v3::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    pos,
                                })
                            } else {
                                None
                            }
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod backrest {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Backrest recline compared to seat z-axis (seat vertical axis). 0 degrees = Upright/Vertical backrest. Negative degrees for forward recline. Positive degrees for backward recline.. The unit of this type is degrees"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Recline {
                    pub value: f32,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub row: u8,
                    #[topic_key]
                    pub pos: u8,
                }
                impl Recline {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Backrest recline compared to seat z-axis (seat vertical axis). 0 degrees = Upright/Vertical backrest. Negative degrees for forward recline. Positive degrees for backward recline.. The unit of this type is degrees"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, pos)"]
                    pub fn value(&self) -> (&f32, &u8, &u8) {
                        (&self.value, &self.row, &self.pos)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Backrest recline compared to seat z-axis (seat vertical axis). 0 degrees = Upright/Vertical backrest. Negative degrees for forward recline. Positive degrees for backward recline.. The unit of this type is degrees"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: f32,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.row = row;
                        self.pos = pos;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &f32) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: f32,
                        timestamp: Option<crate::v3::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                pos,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[allow(non_snake_case)]
                pub mod sidebolster {
                    use cdds_derive::Topic;
                    use cyclonedds_rs::*;
                    #[doc = "Side bolster support. 0 = Minimum support (widest side bolster setting). 100 = Maximum support.. The unit of this type is percent"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Support {
                        pub value: crate::v3::units::Percent<f32>,
                        pub timestamp: crate::v3::Timestamp,
                        #[topic_key]
                        pub row: u8,
                        #[topic_key]
                        pub pos: u8,
                    }
                    impl Support {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Side bolster support. 0 = Minimum support (widest side bolster setting). 100 = Maximum support.. The unit of this type is percent"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, pos)"]
                        pub fn value(&self) -> (&crate::v3::units::Percent<f32>, &u8, &u8) {
                            (&self.value, &self.row, &self.pos)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Side bolster support. 0 = Minimum support (widest side bolster setting). 100 = Maximum support.. The unit of this type is percent"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: crate::v3::units::Percent<f32>,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            self.row = row;
                            self.pos = pos;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. Return true if the value is"]
                        #[doc = r"within bounds."]
                        pub fn bounds_check(v: &crate::v3::units::Percent<f32>) -> bool {
                            v.0 <= 100f32 && v.0 >= 0f32
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: crate::v3::units::Percent<f32>,
                            timestamp: Option<crate::v3::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    pos,
                                })
                            } else {
                                None
                            }
                        }
                    }
                }
                #[allow(non_snake_case)]
                pub mod lumbar {
                    use cdds_derive::Topic;
                    use cyclonedds_rs::*;
                    #[doc = "Lumbar support (in/out position). 0 = Innermost position. 100 = Outermost position.. The unit of this type is percent"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Support {
                        pub value: crate::v3::units::Percent<f32>,
                        pub timestamp: crate::v3::Timestamp,
                        #[topic_key]
                        pub row: u8,
                        #[topic_key]
                        pub pos: u8,
                    }
                    impl Support {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Lumbar support (in/out position). 0 = Innermost position. 100 = Outermost position.. The unit of this type is percent"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, pos)"]
                        pub fn value(&self) -> (&crate::v3::units::Percent<f32>, &u8, &u8) {
                            (&self.value, &self.row, &self.pos)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Lumbar support (in/out position). 0 = Innermost position. 100 = Outermost position.. The unit of this type is percent"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: crate::v3::units::Percent<f32>,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            self.row = row;
                            self.pos = pos;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. Return true if the value is"]
                        #[doc = r"within bounds."]
                        pub fn bounds_check(v: &crate::v3::units::Percent<f32>) -> bool {
                            v.0 <= 100f32 && v.0 >= 0f32
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: crate::v3::units::Percent<f32>,
                            timestamp: Option<crate::v3::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    pos,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Height of lumbar support. Position is relative within available movable range of the lumbar support. 0 = Lowermost position supported.. The unit of this type is mm"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Height {
                        pub value: crate::v3::units::Millimetre<u8>,
                        pub timestamp: crate::v3::Timestamp,
                        #[topic_key]
                        pub row: u8,
                        #[topic_key]
                        pub pos: u8,
                    }
                    impl Height {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Height of lumbar support. Position is relative within available movable range of the lumbar support. 0 = Lowermost position supported.. The unit of this type is mm"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, pos)"]
                        pub fn value(&self) -> (&crate::v3::units::Millimetre<u8>, &u8, &u8) {
                            (&self.value, &self.row, &self.pos)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Height of lumbar support. Position is relative within available movable range of the lumbar support. 0 = Lowermost position supported.. The unit of this type is mm"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: crate::v3::units::Millimetre<u8>,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            self.row = row;
                            self.pos = pos;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. Return true if the value is"]
                        #[doc = r"within bounds."]
                        pub fn bounds_check(v: &crate::v3::units::Millimetre<u8>) -> bool {
                            true && v.0 >= 0u8
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: crate::v3::units::Millimetre<u8>,
                            timestamp: Option<crate::v3::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    pos,
                                })
                            } else {
                                None
                            }
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod seating {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Length adjustment of seating. 0 = Adjustable part of seating in rearmost position (Shortest length of seating).. The unit of this type is mm"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Length {
                    pub value: crate::v3::units::Millimetre<u16>,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub row: u8,
                    #[topic_key]
                    pub pos: u8,
                }
                impl Length {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Length adjustment of seating. 0 = Adjustable part of seating in rearmost position (Shortest length of seating).. The unit of this type is mm"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, pos)"]
                    pub fn value(&self) -> (&crate::v3::units::Millimetre<u16>, &u8, &u8) {
                        (&self.value, &self.row, &self.pos)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Length adjustment of seating. 0 = Adjustable part of seating in rearmost position (Shortest length of seating).. The unit of this type is mm"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Millimetre<u16>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.row = row;
                        self.pos = pos;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v3::units::Millimetre<u16>) -> bool {
                        true && v.0 >= 0u16
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Millimetre<u16>,
                        timestamp: Option<crate::v3::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                pos,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod headrest {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Position of headrest relative to movable range of the head rest. 0 = Bottommost position supported.. The unit of this type is mm"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Height {
                    pub value: crate::v3::units::Millimetre<u8>,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub row: u8,
                    #[topic_key]
                    pub pos: u8,
                }
                impl Height {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Position of headrest relative to movable range of the head rest. 0 = Bottommost position supported.. The unit of this type is mm"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, pos)"]
                    pub fn value(&self) -> (&crate::v3::units::Millimetre<u8>, &u8, &u8) {
                        (&self.value, &self.row, &self.pos)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Position of headrest relative to movable range of the head rest. 0 = Bottommost position supported.. The unit of this type is mm"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Millimetre<u8>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.row = row;
                        self.pos = pos;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v3::units::Millimetre<u8>) -> bool {
                        true && v.0 >= 0u8
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Millimetre<u8>,
                        timestamp: Option<crate::v3::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                pos,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Headrest angle, relative to backrest, 0 degrees if parallel to backrest, Positive degrees = tilted forward.. The unit of this type is degrees"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Angle {
                    pub value: f32,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub row: u8,
                    #[topic_key]
                    pub pos: u8,
                }
                impl Angle {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Headrest angle, relative to backrest, 0 degrees if parallel to backrest, Positive degrees = tilted forward.. The unit of this type is degrees"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, pos)"]
                    pub fn value(&self) -> (&f32, &u8, &u8) {
                        (&self.value, &self.row, &self.pos)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Headrest angle, relative to backrest, 0 degrees if parallel to backrest, Positive degrees = tilted forward.. The unit of this type is degrees"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: f32,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.row = row;
                        self.pos = pos;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &f32) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: f32,
                        timestamp: Option<crate::v3::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                pos,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod airbag {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Airbag deployment status. True = Airbag deployed. False = Airbag not deployed.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct IsDeployed {
                    pub value: bool,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub row: u8,
                    #[topic_key]
                    pub pos: u8,
                }
                impl IsDeployed {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Airbag deployment status. True = Airbag deployed. False = Airbag not deployed.. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, pos)"]
                    pub fn value(&self) -> (&bool, &u8, &u8) {
                        (&self.value, &self.row, &self.pos)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Airbag deployment status. True = Airbag deployed. False = Airbag not deployed.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.row = row;
                        self.pos = pos;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v3::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                pos,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod switch {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Warmer switch for Seat heater (SingleSeat.Heating).. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct IsWarmerEngaged {
                    pub value: bool,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub row: u8,
                    #[topic_key]
                    pub pos: u8,
                }
                impl IsWarmerEngaged {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Warmer switch for Seat heater (SingleSeat.Heating).. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, pos)"]
                    pub fn value(&self) -> (&bool, &u8, &u8) {
                        (&self.value, &self.row, &self.pos)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Warmer switch for Seat heater (SingleSeat.Heating).. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.row = row;
                        self.pos = pos;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v3::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                pos,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Cooler switch for Seat heater (SingleSeat.Heating).. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct IsCoolerEngaged {
                    pub value: bool,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub row: u8,
                    #[topic_key]
                    pub pos: u8,
                }
                impl IsCoolerEngaged {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Cooler switch for Seat heater (SingleSeat.Heating).. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, pos)"]
                    pub fn value(&self) -> (&bool, &u8, &u8) {
                        (&self.value, &self.row, &self.pos)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Cooler switch for Seat heater (SingleSeat.Heating).. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.row = row;
                        self.pos = pos;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v3::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                pos,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Seat forward switch engaged (SingleSeat.Position).. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct IsForwardEngaged {
                    pub value: bool,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub row: u8,
                    #[topic_key]
                    pub pos: u8,
                }
                impl IsForwardEngaged {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Seat forward switch engaged (SingleSeat.Position).. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, pos)"]
                    pub fn value(&self) -> (&bool, &u8, &u8) {
                        (&self.value, &self.row, &self.pos)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Seat forward switch engaged (SingleSeat.Position).. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.row = row;
                        self.pos = pos;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v3::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                pos,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Seat backward switch engaged (SingleSeat.Position).. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct IsBackwardEngaged {
                    pub value: bool,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub row: u8,
                    #[topic_key]
                    pub pos: u8,
                }
                impl IsBackwardEngaged {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Seat backward switch engaged (SingleSeat.Position).. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, pos)"]
                    pub fn value(&self) -> (&bool, &u8, &u8) {
                        (&self.value, &self.row, &self.pos)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Seat backward switch engaged (SingleSeat.Position).. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.row = row;
                        self.pos = pos;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v3::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                pos,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Seat up switch engaged (SingleSeat.Height).. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct IsUpEngaged {
                    pub value: bool,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub row: u8,
                    #[topic_key]
                    pub pos: u8,
                }
                impl IsUpEngaged {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Seat up switch engaged (SingleSeat.Height).. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, pos)"]
                    pub fn value(&self) -> (&bool, &u8, &u8) {
                        (&self.value, &self.row, &self.pos)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Seat up switch engaged (SingleSeat.Height).. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.row = row;
                        self.pos = pos;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v3::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                pos,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Seat down switch engaged (SingleSeat.Height).. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct IsDownEngaged {
                    pub value: bool,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub row: u8,
                    #[topic_key]
                    pub pos: u8,
                }
                impl IsDownEngaged {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Seat down switch engaged (SingleSeat.Height).. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, pos)"]
                    pub fn value(&self) -> (&bool, &u8, &u8) {
                        (&self.value, &self.row, &self.pos)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Seat down switch engaged (SingleSeat.Height).. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.row = row;
                        self.pos = pos;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v3::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                pos,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Tilt forward switch engaged (SingleSeat.Tilt).. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct IsTiltForwardEngaged {
                    pub value: bool,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub row: u8,
                    #[topic_key]
                    pub pos: u8,
                }
                impl IsTiltForwardEngaged {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Tilt forward switch engaged (SingleSeat.Tilt).. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, pos)"]
                    pub fn value(&self) -> (&bool, &u8, &u8) {
                        (&self.value, &self.row, &self.pos)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Tilt forward switch engaged (SingleSeat.Tilt).. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.row = row;
                        self.pos = pos;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v3::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                pos,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Tilt backward switch engaged (SingleSeat.Tilt).. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct IsTiltBackwardEngaged {
                    pub value: bool,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub row: u8,
                    #[topic_key]
                    pub pos: u8,
                }
                impl IsTiltBackwardEngaged {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Tilt backward switch engaged (SingleSeat.Tilt).. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, pos)"]
                    pub fn value(&self) -> (&bool, &u8, &u8) {
                        (&self.value, &self.row, &self.pos)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Tilt backward switch engaged (SingleSeat.Tilt).. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.row = row;
                        self.pos = pos;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v3::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                pos,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[allow(non_snake_case)]
                pub mod massage {
                    use cdds_derive::Topic;
                    use cyclonedds_rs::*;
                    #[doc = "Increase massage level switch engaged (SingleSeat.Massage).. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct IsIncreaseEngaged {
                        pub value: bool,
                        pub timestamp: crate::v3::Timestamp,
                        #[topic_key]
                        pub row: u8,
                        #[topic_key]
                        pub pos: u8,
                    }
                    impl IsIncreaseEngaged {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Increase massage level switch engaged (SingleSeat.Massage).. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, pos)"]
                        pub fn value(&self) -> (&bool, &u8, &u8) {
                            (&self.value, &self.row, &self.pos)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Increase massage level switch engaged (SingleSeat.Massage).. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            self.row = row;
                            self.pos = pos;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v3::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    pos,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Decrease massage level switch engaged (SingleSeat.Massage).. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct IsDecreaseEngaged {
                        pub value: bool,
                        pub timestamp: crate::v3::Timestamp,
                        #[topic_key]
                        pub row: u8,
                        #[topic_key]
                        pub pos: u8,
                    }
                    impl IsDecreaseEngaged {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Decrease massage level switch engaged (SingleSeat.Massage).. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, pos)"]
                        pub fn value(&self) -> (&bool, &u8, &u8) {
                            (&self.value, &self.row, &self.pos)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Decrease massage level switch engaged (SingleSeat.Massage).. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            self.row = row;
                            self.pos = pos;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v3::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    pos,
                                })
                            } else {
                                None
                            }
                        }
                    }
                }
                #[allow(non_snake_case)]
                pub mod headrest {
                    use cdds_derive::Topic;
                    use cyclonedds_rs::*;
                    #[doc = "Head rest up switch engaged (SingleSeat.Headrest.Height).. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct IsUpEngaged {
                        pub value: bool,
                        pub timestamp: crate::v3::Timestamp,
                        #[topic_key]
                        pub row: u8,
                        #[topic_key]
                        pub pos: u8,
                    }
                    impl IsUpEngaged {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Head rest up switch engaged (SingleSeat.Headrest.Height).. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, pos)"]
                        pub fn value(&self) -> (&bool, &u8, &u8) {
                            (&self.value, &self.row, &self.pos)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Head rest up switch engaged (SingleSeat.Headrest.Height).. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            self.row = row;
                            self.pos = pos;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v3::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    pos,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Head rest down switch engaged (SingleSeat.Headrest.Height).. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct IsDownEngaged {
                        pub value: bool,
                        pub timestamp: crate::v3::Timestamp,
                        #[topic_key]
                        pub row: u8,
                        #[topic_key]
                        pub pos: u8,
                    }
                    impl IsDownEngaged {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Head rest down switch engaged (SingleSeat.Headrest.Height).. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, pos)"]
                        pub fn value(&self) -> (&bool, &u8, &u8) {
                            (&self.value, &self.row, &self.pos)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Head rest down switch engaged (SingleSeat.Headrest.Height).. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            self.row = row;
                            self.pos = pos;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v3::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    pos,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Head rest forward switch engaged (SingleSeat.Headrest.Angle).. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct IsForwardEngaged {
                        pub value: bool,
                        pub timestamp: crate::v3::Timestamp,
                        #[topic_key]
                        pub row: u8,
                        #[topic_key]
                        pub pos: u8,
                    }
                    impl IsForwardEngaged {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Head rest forward switch engaged (SingleSeat.Headrest.Angle).. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, pos)"]
                        pub fn value(&self) -> (&bool, &u8, &u8) {
                            (&self.value, &self.row, &self.pos)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Head rest forward switch engaged (SingleSeat.Headrest.Angle).. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            self.row = row;
                            self.pos = pos;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v3::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    pos,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Head rest backward switch engaged (SingleSeat.Headrest.Angle).. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct IsBackwardEngaged {
                        pub value: bool,
                        pub timestamp: crate::v3::Timestamp,
                        #[topic_key]
                        pub row: u8,
                        #[topic_key]
                        pub pos: u8,
                    }
                    impl IsBackwardEngaged {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Head rest backward switch engaged (SingleSeat.Headrest.Angle).. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, pos)"]
                        pub fn value(&self) -> (&bool, &u8, &u8) {
                            (&self.value, &self.row, &self.pos)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Head rest backward switch engaged (SingleSeat.Headrest.Angle).. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            self.row = row;
                            self.pos = pos;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v3::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    pos,
                                })
                            } else {
                                None
                            }
                        }
                    }
                }
                #[allow(non_snake_case)]
                pub mod seating {
                    use cdds_derive::Topic;
                    use cyclonedds_rs::*;
                    #[doc = "Is switch to increase seating length engaged (SingleSeat.Seating.Length).. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct IsForwardEngaged {
                        pub value: bool,
                        pub timestamp: crate::v3::Timestamp,
                        #[topic_key]
                        pub row: u8,
                        #[topic_key]
                        pub pos: u8,
                    }
                    impl IsForwardEngaged {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Is switch to increase seating length engaged (SingleSeat.Seating.Length).. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, pos)"]
                        pub fn value(&self) -> (&bool, &u8, &u8) {
                            (&self.value, &self.row, &self.pos)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Is switch to increase seating length engaged (SingleSeat.Seating.Length).. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            self.row = row;
                            self.pos = pos;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v3::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    pos,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Is switch to decrease seating length engaged (SingleSeat.Seating.Length).. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct IsBackwardEngaged {
                        pub value: bool,
                        pub timestamp: crate::v3::Timestamp,
                        #[topic_key]
                        pub row: u8,
                        #[topic_key]
                        pub pos: u8,
                    }
                    impl IsBackwardEngaged {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Is switch to decrease seating length engaged (SingleSeat.Seating.Length).. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, pos)"]
                        pub fn value(&self) -> (&bool, &u8, &u8) {
                            (&self.value, &self.row, &self.pos)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Is switch to decrease seating length engaged (SingleSeat.Seating.Length).. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            self.row = row;
                            self.pos = pos;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v3::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    pos,
                                })
                            } else {
                                None
                            }
                        }
                    }
                }
                #[allow(non_snake_case)]
                pub mod backrest {
                    use cdds_derive::Topic;
                    use cyclonedds_rs::*;
                    #[doc = "Backrest recline forward switch engaged (SingleSeat.Backrest.Recline).. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct IsReclineForwardEngaged {
                        pub value: bool,
                        pub timestamp: crate::v3::Timestamp,
                        #[topic_key]
                        pub row: u8,
                        #[topic_key]
                        pub pos: u8,
                    }
                    impl IsReclineForwardEngaged {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Backrest recline forward switch engaged (SingleSeat.Backrest.Recline).. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, pos)"]
                        pub fn value(&self) -> (&bool, &u8, &u8) {
                            (&self.value, &self.row, &self.pos)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Backrest recline forward switch engaged (SingleSeat.Backrest.Recline).. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            self.row = row;
                            self.pos = pos;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v3::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    pos,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Backrest recline backward switch engaged (SingleSeat.Backrest.Recline).. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct IsReclineBackwardEngaged {
                        pub value: bool,
                        pub timestamp: crate::v3::Timestamp,
                        #[topic_key]
                        pub row: u8,
                        #[topic_key]
                        pub pos: u8,
                    }
                    impl IsReclineBackwardEngaged {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Backrest recline backward switch engaged (SingleSeat.Backrest.Recline).. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, pos)"]
                        pub fn value(&self) -> (&bool, &u8, &u8) {
                            (&self.value, &self.row, &self.pos)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Backrest recline backward switch engaged (SingleSeat.Backrest.Recline).. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            self.row = row;
                            self.pos = pos;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v3::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    pos,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[allow(non_snake_case)]
                    pub mod sidebolster {
                        use cdds_derive::Topic;
                        use cyclonedds_rs::*;
                        #[doc = "Is switch for more side bolster support engaged (SingleSeat.Backrest.SideBolster.Support).. This type has no unit defined"]
                        #[allow(non_camel_case_types)]
                        #[repr(C)]
                        #[derive(Default, Deserialize, Serialize, Topic)]
                        pub struct IsMoreSupportEngaged {
                            pub value: bool,
                            pub timestamp: crate::v3::Timestamp,
                            #[topic_key]
                            pub row: u8,
                            #[topic_key]
                            pub pos: u8,
                        }
                        impl IsMoreSupportEngaged {
                            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                                &self.timestamp
                            }
                            #[doc = r" Get the "]
                            #[doc = "Is switch for more side bolster support engaged (SingleSeat.Backrest.SideBolster.Support).. This type has no unit defined"]
                            #[doc = r" The return value is a tuple that contains a"]
                            #[doc = r" reference to the value and the additional keys the topic"]
                            #[doc = r" may have. The value is always the first entry and is"]
                            #[doc = "(value,row, pos)"]
                            pub fn value(&self) -> (&bool, &u8, &u8) {
                                (&self.value, &self.row, &self.pos)
                            }
                            #[doc = r" Set the"]
                            #[doc = "Is switch for more side bolster support engaged (SingleSeat.Backrest.SideBolster.Support).. This type has no unit defined"]
                            #[doc = r" . Ensure that the value is within bounds as per the"]
                            #[doc = r" specification. This function will panic in case the value is out"]
                            #[doc = r" of bounds."]
                            pub fn set(
                                &mut self,
                                value: bool,
                                maybe_timestamp: Option<crate::v3::Timestamp>,
                                row: u8,
                                pos: u8,
                            ) {
                                assert!(Self::bounds_check(&value));
                                self.value = value;
                                self.row = row;
                                self.pos = pos;
                                if let Some(ts) = maybe_timestamp {
                                    self.timestamp = ts;
                                }
                            }
                            #[doc = r"check if the given value is within the limits defined"]
                            #[doc = r"in the specification. This particular type has not"]
                            #[doc = r"specified the min or max limits so the function just"]
                            #[doc = r" returns true"]
                            const fn bounds_check(_v: &bool) -> bool {
                                true
                            }
                            #[doc = r" create a new instance"]
                            pub fn new(
                                value: bool,
                                timestamp: Option<crate::v3::Timestamp>,
                                row: u8,
                                pos: u8,
                            ) -> Option<Self> {
                                if Self::bounds_check(&value) {
                                    Some(Self {
                                        value,
                                        timestamp: timestamp.unwrap_or_default(),
                                        row,
                                        pos,
                                    })
                                } else {
                                    None
                                }
                            }
                        }
                        #[doc = "Is switch for less side bolster support engaged (SingleSeat.Backrest.SideBolster.Support).. This type has no unit defined"]
                        #[allow(non_camel_case_types)]
                        #[repr(C)]
                        #[derive(Default, Deserialize, Serialize, Topic)]
                        pub struct IsLessSupportEngaged {
                            pub value: bool,
                            pub timestamp: crate::v3::Timestamp,
                            #[topic_key]
                            pub row: u8,
                            #[topic_key]
                            pub pos: u8,
                        }
                        impl IsLessSupportEngaged {
                            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                                &self.timestamp
                            }
                            #[doc = r" Get the "]
                            #[doc = "Is switch for less side bolster support engaged (SingleSeat.Backrest.SideBolster.Support).. This type has no unit defined"]
                            #[doc = r" The return value is a tuple that contains a"]
                            #[doc = r" reference to the value and the additional keys the topic"]
                            #[doc = r" may have. The value is always the first entry and is"]
                            #[doc = "(value,row, pos)"]
                            pub fn value(&self) -> (&bool, &u8, &u8) {
                                (&self.value, &self.row, &self.pos)
                            }
                            #[doc = r" Set the"]
                            #[doc = "Is switch for less side bolster support engaged (SingleSeat.Backrest.SideBolster.Support).. This type has no unit defined"]
                            #[doc = r" . Ensure that the value is within bounds as per the"]
                            #[doc = r" specification. This function will panic in case the value is out"]
                            #[doc = r" of bounds."]
                            pub fn set(
                                &mut self,
                                value: bool,
                                maybe_timestamp: Option<crate::v3::Timestamp>,
                                row: u8,
                                pos: u8,
                            ) {
                                assert!(Self::bounds_check(&value));
                                self.value = value;
                                self.row = row;
                                self.pos = pos;
                                if let Some(ts) = maybe_timestamp {
                                    self.timestamp = ts;
                                }
                            }
                            #[doc = r"check if the given value is within the limits defined"]
                            #[doc = r"in the specification. This particular type has not"]
                            #[doc = r"specified the min or max limits so the function just"]
                            #[doc = r" returns true"]
                            const fn bounds_check(_v: &bool) -> bool {
                                true
                            }
                            #[doc = r" create a new instance"]
                            pub fn new(
                                value: bool,
                                timestamp: Option<crate::v3::Timestamp>,
                                row: u8,
                                pos: u8,
                            ) -> Option<Self> {
                                if Self::bounds_check(&value) {
                                    Some(Self {
                                        value,
                                        timestamp: timestamp.unwrap_or_default(),
                                        row,
                                        pos,
                                    })
                                } else {
                                    None
                                }
                            }
                        }
                    }
                    #[allow(non_snake_case)]
                    pub mod lumbar {
                        use cdds_derive::Topic;
                        use cyclonedds_rs::*;
                        #[doc = "Is switch for more lumbar support engaged (SingleSeat.Backrest.Lumbar.Support).. This type has no unit defined"]
                        #[allow(non_camel_case_types)]
                        #[repr(C)]
                        #[derive(Default, Deserialize, Serialize, Topic)]
                        pub struct IsMoreSupportEngaged {
                            pub value: bool,
                            pub timestamp: crate::v3::Timestamp,
                            #[topic_key]
                            pub row: u8,
                            #[topic_key]
                            pub pos: u8,
                        }
                        impl IsMoreSupportEngaged {
                            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                                &self.timestamp
                            }
                            #[doc = r" Get the "]
                            #[doc = "Is switch for more lumbar support engaged (SingleSeat.Backrest.Lumbar.Support).. This type has no unit defined"]
                            #[doc = r" The return value is a tuple that contains a"]
                            #[doc = r" reference to the value and the additional keys the topic"]
                            #[doc = r" may have. The value is always the first entry and is"]
                            #[doc = "(value,row, pos)"]
                            pub fn value(&self) -> (&bool, &u8, &u8) {
                                (&self.value, &self.row, &self.pos)
                            }
                            #[doc = r" Set the"]
                            #[doc = "Is switch for more lumbar support engaged (SingleSeat.Backrest.Lumbar.Support).. This type has no unit defined"]
                            #[doc = r" . Ensure that the value is within bounds as per the"]
                            #[doc = r" specification. This function will panic in case the value is out"]
                            #[doc = r" of bounds."]
                            pub fn set(
                                &mut self,
                                value: bool,
                                maybe_timestamp: Option<crate::v3::Timestamp>,
                                row: u8,
                                pos: u8,
                            ) {
                                assert!(Self::bounds_check(&value));
                                self.value = value;
                                self.row = row;
                                self.pos = pos;
                                if let Some(ts) = maybe_timestamp {
                                    self.timestamp = ts;
                                }
                            }
                            #[doc = r"check if the given value is within the limits defined"]
                            #[doc = r"in the specification. This particular type has not"]
                            #[doc = r"specified the min or max limits so the function just"]
                            #[doc = r" returns true"]
                            const fn bounds_check(_v: &bool) -> bool {
                                true
                            }
                            #[doc = r" create a new instance"]
                            pub fn new(
                                value: bool,
                                timestamp: Option<crate::v3::Timestamp>,
                                row: u8,
                                pos: u8,
                            ) -> Option<Self> {
                                if Self::bounds_check(&value) {
                                    Some(Self {
                                        value,
                                        timestamp: timestamp.unwrap_or_default(),
                                        row,
                                        pos,
                                    })
                                } else {
                                    None
                                }
                            }
                        }
                        #[doc = "Is switch for less lumbar support engaged (SingleSeat.Backrest.Lumbar.Support).. This type has no unit defined"]
                        #[allow(non_camel_case_types)]
                        #[repr(C)]
                        #[derive(Default, Deserialize, Serialize, Topic)]
                        pub struct IsLessSupportEngaged {
                            pub value: bool,
                            pub timestamp: crate::v3::Timestamp,
                            #[topic_key]
                            pub row: u8,
                            #[topic_key]
                            pub pos: u8,
                        }
                        impl IsLessSupportEngaged {
                            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                                &self.timestamp
                            }
                            #[doc = r" Get the "]
                            #[doc = "Is switch for less lumbar support engaged (SingleSeat.Backrest.Lumbar.Support).. This type has no unit defined"]
                            #[doc = r" The return value is a tuple that contains a"]
                            #[doc = r" reference to the value and the additional keys the topic"]
                            #[doc = r" may have. The value is always the first entry and is"]
                            #[doc = "(value,row, pos)"]
                            pub fn value(&self) -> (&bool, &u8, &u8) {
                                (&self.value, &self.row, &self.pos)
                            }
                            #[doc = r" Set the"]
                            #[doc = "Is switch for less lumbar support engaged (SingleSeat.Backrest.Lumbar.Support).. This type has no unit defined"]
                            #[doc = r" . Ensure that the value is within bounds as per the"]
                            #[doc = r" specification. This function will panic in case the value is out"]
                            #[doc = r" of bounds."]
                            pub fn set(
                                &mut self,
                                value: bool,
                                maybe_timestamp: Option<crate::v3::Timestamp>,
                                row: u8,
                                pos: u8,
                            ) {
                                assert!(Self::bounds_check(&value));
                                self.value = value;
                                self.row = row;
                                self.pos = pos;
                                if let Some(ts) = maybe_timestamp {
                                    self.timestamp = ts;
                                }
                            }
                            #[doc = r"check if the given value is within the limits defined"]
                            #[doc = r"in the specification. This particular type has not"]
                            #[doc = r"specified the min or max limits so the function just"]
                            #[doc = r" returns true"]
                            const fn bounds_check(_v: &bool) -> bool {
                                true
                            }
                            #[doc = r" create a new instance"]
                            pub fn new(
                                value: bool,
                                timestamp: Option<crate::v3::Timestamp>,
                                row: u8,
                                pos: u8,
                            ) -> Option<Self> {
                                if Self::bounds_check(&value) {
                                    Some(Self {
                                        value,
                                        timestamp: timestamp.unwrap_or_default(),
                                        row,
                                        pos,
                                    })
                                } else {
                                    None
                                }
                            }
                        }
                        #[doc = "Lumbar up switch engaged (SingleSeat.Backrest.Lumbar.Support).. This type has no unit defined"]
                        #[allow(non_camel_case_types)]
                        #[repr(C)]
                        #[derive(Default, Deserialize, Serialize, Topic)]
                        pub struct IsUpEngaged {
                            pub value: bool,
                            pub timestamp: crate::v3::Timestamp,
                            #[topic_key]
                            pub row: u8,
                            #[topic_key]
                            pub pos: u8,
                        }
                        impl IsUpEngaged {
                            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                                &self.timestamp
                            }
                            #[doc = r" Get the "]
                            #[doc = "Lumbar up switch engaged (SingleSeat.Backrest.Lumbar.Support).. This type has no unit defined"]
                            #[doc = r" The return value is a tuple that contains a"]
                            #[doc = r" reference to the value and the additional keys the topic"]
                            #[doc = r" may have. The value is always the first entry and is"]
                            #[doc = "(value,row, pos)"]
                            pub fn value(&self) -> (&bool, &u8, &u8) {
                                (&self.value, &self.row, &self.pos)
                            }
                            #[doc = r" Set the"]
                            #[doc = "Lumbar up switch engaged (SingleSeat.Backrest.Lumbar.Support).. This type has no unit defined"]
                            #[doc = r" . Ensure that the value is within bounds as per the"]
                            #[doc = r" specification. This function will panic in case the value is out"]
                            #[doc = r" of bounds."]
                            pub fn set(
                                &mut self,
                                value: bool,
                                maybe_timestamp: Option<crate::v3::Timestamp>,
                                row: u8,
                                pos: u8,
                            ) {
                                assert!(Self::bounds_check(&value));
                                self.value = value;
                                self.row = row;
                                self.pos = pos;
                                if let Some(ts) = maybe_timestamp {
                                    self.timestamp = ts;
                                }
                            }
                            #[doc = r"check if the given value is within the limits defined"]
                            #[doc = r"in the specification. This particular type has not"]
                            #[doc = r"specified the min or max limits so the function just"]
                            #[doc = r" returns true"]
                            const fn bounds_check(_v: &bool) -> bool {
                                true
                            }
                            #[doc = r" create a new instance"]
                            pub fn new(
                                value: bool,
                                timestamp: Option<crate::v3::Timestamp>,
                                row: u8,
                                pos: u8,
                            ) -> Option<Self> {
                                if Self::bounds_check(&value) {
                                    Some(Self {
                                        value,
                                        timestamp: timestamp.unwrap_or_default(),
                                        row,
                                        pos,
                                    })
                                } else {
                                    None
                                }
                            }
                        }
                        #[doc = "Lumbar down switch engaged (SingleSeat.Backrest.Lumbar.Support).. This type has no unit defined"]
                        #[allow(non_camel_case_types)]
                        #[repr(C)]
                        #[derive(Default, Deserialize, Serialize, Topic)]
                        pub struct IsDownEngaged {
                            pub value: bool,
                            pub timestamp: crate::v3::Timestamp,
                            #[topic_key]
                            pub row: u8,
                            #[topic_key]
                            pub pos: u8,
                        }
                        impl IsDownEngaged {
                            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                                &self.timestamp
                            }
                            #[doc = r" Get the "]
                            #[doc = "Lumbar down switch engaged (SingleSeat.Backrest.Lumbar.Support).. This type has no unit defined"]
                            #[doc = r" The return value is a tuple that contains a"]
                            #[doc = r" reference to the value and the additional keys the topic"]
                            #[doc = r" may have. The value is always the first entry and is"]
                            #[doc = "(value,row, pos)"]
                            pub fn value(&self) -> (&bool, &u8, &u8) {
                                (&self.value, &self.row, &self.pos)
                            }
                            #[doc = r" Set the"]
                            #[doc = "Lumbar down switch engaged (SingleSeat.Backrest.Lumbar.Support).. This type has no unit defined"]
                            #[doc = r" . Ensure that the value is within bounds as per the"]
                            #[doc = r" specification. This function will panic in case the value is out"]
                            #[doc = r" of bounds."]
                            pub fn set(
                                &mut self,
                                value: bool,
                                maybe_timestamp: Option<crate::v3::Timestamp>,
                                row: u8,
                                pos: u8,
                            ) {
                                assert!(Self::bounds_check(&value));
                                self.value = value;
                                self.row = row;
                                self.pos = pos;
                                if let Some(ts) = maybe_timestamp {
                                    self.timestamp = ts;
                                }
                            }
                            #[doc = r"check if the given value is within the limits defined"]
                            #[doc = r"in the specification. This particular type has not"]
                            #[doc = r"specified the min or max limits so the function just"]
                            #[doc = r" returns true"]
                            const fn bounds_check(_v: &bool) -> bool {
                                true
                            }
                            #[doc = r" create a new instance"]
                            pub fn new(
                                value: bool,
                                timestamp: Option<crate::v3::Timestamp>,
                                row: u8,
                                pos: u8,
                            ) -> Option<Self> {
                                if Self::bounds_check(&value) {
                                    Some(Self {
                                        value,
                                        timestamp: timestamp.unwrap_or_default(),
                                        row,
                                        pos,
                                    })
                                } else {
                                    None
                                }
                            }
                        }
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod door {
            #[allow(non_snake_case)]
            pub mod window {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Is window open or closed?. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct IsOpen {
                    pub value: bool,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub row: u8,
                    #[topic_key_enum]
                    pub side: crate::v3::Side,
                }
                impl IsOpen {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Is window open or closed?. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, side)"]
                    pub fn value(&self) -> (&bool, &u8, &crate::v3::Side) {
                        (&self.value, &self.row, &self.side)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Is window open or closed?. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        row: u8,
                        side: crate::v3::Side,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.row = row;
                        self.side = side;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v3::Timestamp>,
                        row: u8,
                        side: crate::v3::Side,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                side,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Window position. 0 = Fully closed 100 = Fully opened.. The unit of this type is percent"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Position {
                    pub value: crate::v3::units::Percent<u8>,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub row: u8,
                    #[topic_key_enum]
                    pub side: crate::v3::Side,
                }
                impl Position {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Window position. 0 = Fully closed 100 = Fully opened.. The unit of this type is percent"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, side)"]
                    pub fn value(&self) -> (&crate::v3::units::Percent<u8>, &u8, &crate::v3::Side) {
                        (&self.value, &self.row, &self.side)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Window position. 0 = Fully closed 100 = Fully opened.. The unit of this type is percent"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Percent<u8>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        row: u8,
                        side: crate::v3::Side,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.row = row;
                        self.side = side;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v3::units::Percent<u8>) -> bool {
                        v.0 <= 100u8 && v.0 >= 0u8
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Percent<u8>,
                        timestamp: Option<crate::v3::Timestamp>,
                        row: u8,
                        side: crate::v3::Side,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                side,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Is window child lock engaged. True = Engaged. False = Disengaged.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct IsChildLockEngaged {
                    pub value: bool,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub row: u8,
                    #[topic_key_enum]
                    pub side: crate::v3::Side,
                }
                impl IsChildLockEngaged {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Is window child lock engaged. True = Engaged. False = Disengaged.. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, side)"]
                    pub fn value(&self) -> (&bool, &u8, &crate::v3::Side) {
                        (&self.value, &self.row, &self.side)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Is window child lock engaged. True = Engaged. False = Disengaged.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        row: u8,
                        side: crate::v3::Side,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.row = row;
                        self.side = side;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v3::Timestamp>,
                        row: u8,
                        side: crate::v3::Side,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                side,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Switch controlling sliding action such as window, sunroof, or blind.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Switch {
                    pub value: String,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub row: u8,
                    #[topic_key_enum]
                    pub side: crate::v3::Side,
                }
                impl Switch {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Switch controlling sliding action such as window, sunroof, or blind.. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, side)"]
                    pub fn value(&self) -> (&String, &u8, &crate::v3::Side) {
                        (&self.value, &self.row, &self.side)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Switch controlling sliding action such as window, sunroof, or blind.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        row: u8,
                        side: crate::v3::Side,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.row = row;
                        self.side = side;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v3::Timestamp>,
                        row: u8,
                        side: crate::v3::Side,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                side,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod shade {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Switch controlling sliding action such as window, sunroof, or blind.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Switch {
                    pub value: String,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub row: u8,
                    #[topic_key_enum]
                    pub side: crate::v3::Side,
                }
                impl Switch {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Switch controlling sliding action such as window, sunroof, or blind.. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, side)"]
                    pub fn value(&self) -> (&String, &u8, &crate::v3::Side) {
                        (&self.value, &self.row, &self.side)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Switch controlling sliding action such as window, sunroof, or blind.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        row: u8,
                        side: crate::v3::Side,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.row = row;
                        self.side = side;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v3::Timestamp>,
                        row: u8,
                        side: crate::v3::Side,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                side,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Position of window blind. 0 = Fully retracted. 100 = Fully deployed.. The unit of this type is percent"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Position {
                    pub value: crate::v3::units::Percent<u8>,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key]
                    pub row: u8,
                    #[topic_key_enum]
                    pub side: crate::v3::Side,
                }
                impl Position {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Position of window blind. 0 = Fully retracted. 100 = Fully deployed.. The unit of this type is percent"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, side)"]
                    pub fn value(&self) -> (&crate::v3::units::Percent<u8>, &u8, &crate::v3::Side) {
                        (&self.value, &self.row, &self.side)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Position of window blind. 0 = Fully retracted. 100 = Fully deployed.. The unit of this type is percent"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Percent<u8>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        row: u8,
                        side: crate::v3::Side,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.row = row;
                        self.side = side;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v3::units::Percent<u8>) -> bool {
                        v.0 <= 100u8 && v.0 >= 0u8
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Percent<u8>,
                        timestamp: Option<crate::v3::Timestamp>,
                        row: u8,
                        side: crate::v3::Side,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                side,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod lights {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Is glove box light on. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsGloveBoxOn {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsGloveBoxOn {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is glove box light on. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Is glove box light on. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Is trunk light light on. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsTrunkOn {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsTrunkOn {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is trunk light light on. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Is trunk light light on. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Is central dome light light on. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsDomeOn {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsDomeOn {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is central dome light light on. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Is central dome light light on. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "How much ambient light is detected in cabin. 0 = No ambient light. 100 = Full brightness. The unit of this type is percent"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct AmbientLight {
                pub value: crate::v3::units::Percent<u8>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl AmbientLight {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "How much ambient light is detected in cabin. 0 = No ambient light. 100 = Full brightness. The unit of this type is percent"]
                pub fn value(&self) -> &crate::v3::units::Percent<u8> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "How much ambient light is detected in cabin. 0 = No ambient light. 100 = Full brightness. The unit of this type is percent"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::Percent<u8>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v3::units::Percent<u8>) -> bool {
                    v.0 <= 100u8 && v.0 >= 0u8
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::Percent<u8>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Intensity of the interior lights. 0 = Off. 100 = Full brightness.. The unit of this type is percent"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct LightIntensity {
                pub value: crate::v3::units::Percent<u8>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl LightIntensity {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Intensity of the interior lights. 0 = Off. 100 = Full brightness.. The unit of this type is percent"]
                pub fn value(&self) -> &crate::v3::units::Percent<u8> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Intensity of the interior lights. 0 = Off. 100 = Full brightness.. The unit of this type is percent"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::Percent<u8>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v3::units::Percent<u8>) -> bool {
                    v.0 <= 100u8 && v.0 >= 0u8
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::Percent<u8>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod spotlight {}
        }
        #[allow(non_snake_case)]
        pub mod rearviewmirror {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Dimming level of rearview mirror. 0 = undimmed. 100 = fully dimmed.. The unit of this type is percent"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct DimmingLevel {
                pub value: crate::v3::units::Percent<u8>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl DimmingLevel {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Dimming level of rearview mirror. 0 = undimmed. 100 = fully dimmed.. The unit of this type is percent"]
                pub fn value(&self) -> &crate::v3::units::Percent<u8> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Dimming level of rearview mirror. 0 = undimmed. 100 = fully dimmed.. The unit of this type is percent"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::Percent<u8>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v3::units::Percent<u8>) -> bool {
                    v.0 <= 100u8 && true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::Percent<u8>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod sunroof {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Sunroof position. 0 = Fully closed 100 = Fully opened. -100 = Fully tilted.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Position {
                pub value: i8,
                pub timestamp: crate::v3::Timestamp,
            }
            impl Position {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Sunroof position. 0 = Fully closed 100 = Fully opened. -100 = Fully tilted.. This type has no unit defined"]
                pub fn value(&self) -> &i8 {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Sunroof position. 0 = Fully closed 100 = Fully opened. -100 = Fully tilted.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: i8, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &i8) -> bool {
                    *v <= 100i8 && *v >= -100i8
                }
                #[doc = r" create a new instance"]
                pub fn new(value: i8, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Switch controlling sliding action such as window, sunroof, or shade.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Switch {
                pub value: String,
                pub timestamp: crate::v3::Timestamp,
            }
            impl Switch {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Switch controlling sliding action such as window, sunroof, or shade.. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Switch controlling sliding action such as window, sunroof, or shade.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: String,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod shade {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Switch controlling sliding action such as window, sunroof, or blind.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Switch {
                    pub value: String,
                    pub timestamp: crate::v3::Timestamp,
                }
                impl Switch {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Switch controlling sliding action such as window, sunroof, or blind.. This type has no unit defined"]
                    pub fn value(&self) -> &String {
                        &self.value
                    }
                    #[doc = r" Set the"]
                    #[doc = "Switch controlling sliding action such as window, sunroof, or blind.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v3::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Position of window blind. 0 = Fully retracted. 100 = Fully deployed.. The unit of this type is percent"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Position {
                    pub value: crate::v3::units::Percent<u8>,
                    pub timestamp: crate::v3::Timestamp,
                }
                impl Position {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Position of window blind. 0 = Fully retracted. 100 = Fully deployed.. The unit of this type is percent"]
                    pub fn value(&self) -> &crate::v3::units::Percent<u8> {
                        &self.value
                    }
                    #[doc = r" Set the"]
                    #[doc = "Position of window blind. 0 = Fully retracted. 100 = Fully deployed.. The unit of this type is percent"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Percent<u8>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v3::units::Percent<u8>) -> bool {
                        v.0 <= 100u8 && v.0 >= 0u8
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Percent<u8>,
                        timestamp: Option<crate::v3::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod infotainment {
            #[allow(non_snake_case)]
            pub mod hmi {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "ISO 639-1 standard language code for the current HMI. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct CurrentLanguage {
                    pub value: String,
                    pub timestamp: crate::v3::Timestamp,
                }
                impl CurrentLanguage {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "ISO 639-1 standard language code for the current HMI. This type has no unit defined"]
                    pub fn value(&self) -> &String {
                        &self.value
                    }
                    #[doc = r" Set the"]
                    #[doc = "ISO 639-1 standard language code for the current HMI. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v3::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Date format used in the current HMI. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct DateFormat {
                    pub value: String,
                    pub timestamp: crate::v3::Timestamp,
                }
                impl DateFormat {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Date format used in the current HMI. This type has no unit defined"]
                    pub fn value(&self) -> &String {
                        &self.value
                    }
                    #[doc = r" Set the"]
                    #[doc = "Date format used in the current HMI. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v3::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Time format used in the current HMI. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct TimeFormat {
                    pub value: String,
                    pub timestamp: crate::v3::Timestamp,
                }
                impl TimeFormat {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Time format used in the current HMI. This type has no unit defined"]
                    pub fn value(&self) -> &String {
                        &self.value
                    }
                    #[doc = r" Set the"]
                    #[doc = "Time format used in the current HMI. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v3::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Distance unit used in the current HMI. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct DistanceUnit {
                    pub value: String,
                    pub timestamp: crate::v3::Timestamp,
                }
                impl DistanceUnit {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Distance unit used in the current HMI. This type has no unit defined"]
                    pub fn value(&self) -> &String {
                        &self.value
                    }
                    #[doc = r" Set the"]
                    #[doc = "Distance unit used in the current HMI. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v3::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Fuel economy unit used in the current HMI. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct FuelEconomyUnits {
                    pub value: String,
                    pub timestamp: crate::v3::Timestamp,
                }
                impl FuelEconomyUnits {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Fuel economy unit used in the current HMI. This type has no unit defined"]
                    pub fn value(&self) -> &String {
                        &self.value
                    }
                    #[doc = r" Set the"]
                    #[doc = "Fuel economy unit used in the current HMI. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v3::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "EV fuel economy unit used in the current HMI. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct EVEconomyUnits {
                    pub value: String,
                    pub timestamp: crate::v3::Timestamp,
                }
                impl EVEconomyUnits {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "EV fuel economy unit used in the current HMI. This type has no unit defined"]
                    pub fn value(&self) -> &String {
                        &self.value
                    }
                    #[doc = r" Set the"]
                    #[doc = "EV fuel economy unit used in the current HMI. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v3::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Temperature unit used in the current HMI. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct TemperatureUnit {
                    pub value: String,
                    pub timestamp: crate::v3::Timestamp,
                }
                impl TemperatureUnit {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Temperature unit used in the current HMI. This type has no unit defined"]
                    pub fn value(&self) -> &String {
                        &self.value
                    }
                    #[doc = r" Set the"]
                    #[doc = "Temperature unit used in the current HMI. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v3::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Current display theme. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct DayNightMode {
                    pub value: String,
                    pub timestamp: crate::v3::Timestamp,
                }
                impl DayNightMode {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Current display theme. This type has no unit defined"]
                    pub fn value(&self) -> &String {
                        &self.value
                    }
                    #[doc = r" Set the"]
                    #[doc = "Current display theme. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v3::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod navigation {
                #[allow(non_snake_case)]
                pub mod destinationset {
                    use cdds_derive::Topic;
                    use cyclonedds_rs::*;
                    #[doc = "Latitude of destination in WGS 84 geodetic coordinates.. The unit of this type is degrees"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Latitude {
                        pub value: f64,
                        pub timestamp: crate::v3::Timestamp,
                    }
                    impl Latitude {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Latitude of destination in WGS 84 geodetic coordinates.. The unit of this type is degrees"]
                        pub fn value(&self) -> &f64 {
                            &self.value
                        }
                        #[doc = r" Set the"]
                        #[doc = "Latitude of destination in WGS 84 geodetic coordinates.. The unit of this type is degrees"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: f64,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. Return true if the value is"]
                        #[doc = r"within bounds."]
                        pub fn bounds_check(v: &f64) -> bool {
                            *v <= 90f64 && *v >= -90f64
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: f64,
                            timestamp: Option<crate::v3::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Longitude of destination in WGS 84 geodetic coordinates.. The unit of this type is degrees"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Longitude {
                        pub value: f64,
                        pub timestamp: crate::v3::Timestamp,
                    }
                    impl Longitude {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Longitude of destination in WGS 84 geodetic coordinates.. The unit of this type is degrees"]
                        pub fn value(&self) -> &f64 {
                            &self.value
                        }
                        #[doc = r" Set the"]
                        #[doc = "Longitude of destination in WGS 84 geodetic coordinates.. The unit of this type is degrees"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: f64,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. Return true if the value is"]
                        #[doc = r"within bounds."]
                        pub fn bounds_check(v: &f64) -> bool {
                            *v <= 180f64 && *v >= -180f64
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: f64,
                            timestamp: Option<crate::v3::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod media {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Tells if the media was. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Action {
                    pub value: String,
                    pub timestamp: crate::v3::Timestamp,
                }
                impl Action {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Tells if the media was. This type has no unit defined"]
                    pub fn value(&self) -> &String {
                        &self.value
                    }
                    #[doc = r" Set the"]
                    #[doc = "Tells if the media was. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v3::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "URI of suggested media that was declined. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct DeclinedURI {
                    pub value: String,
                    pub timestamp: crate::v3::Timestamp,
                }
                impl DeclinedURI {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "URI of suggested media that was declined. This type has no unit defined"]
                    pub fn value(&self) -> &String {
                        &self.value
                    }
                    #[doc = r" Set the"]
                    #[doc = "URI of suggested media that was declined. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v3::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "URI of suggested media that was selected. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct SelectedURI {
                    pub value: String,
                    pub timestamp: crate::v3::Timestamp,
                }
                impl SelectedURI {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "URI of suggested media that was selected. This type has no unit defined"]
                    pub fn value(&self) -> &String {
                        &self.value
                    }
                    #[doc = r" Set the"]
                    #[doc = "URI of suggested media that was selected. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v3::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Current Media Volume. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Volume {
                    pub value: u8,
                    pub timestamp: crate::v3::Timestamp,
                }
                impl Volume {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Current Media Volume. This type has no unit defined"]
                    pub fn value(&self) -> &u8 {
                        &self.value
                    }
                    #[doc = r" Set the"]
                    #[doc = "Current Media Volume. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: u8,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &u8) -> bool {
                        *v <= 100u8 && *v >= 0u8
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(value: u8, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[allow(non_snake_case)]
                pub mod played {
                    use cdds_derive::Topic;
                    use cyclonedds_rs::*;
                    #[doc = "Media selected for playback. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Source {
                        pub value: String,
                        pub timestamp: crate::v3::Timestamp,
                    }
                    impl Source {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Media selected for playback. This type has no unit defined"]
                        pub fn value(&self) -> &String {
                            &self.value
                        }
                        #[doc = r" Set the"]
                        #[doc = "Media selected for playback. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: String,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &String) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: String,
                            timestamp: Option<crate::v3::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Name of artist being played. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Artist {
                        pub value: String,
                        pub timestamp: crate::v3::Timestamp,
                    }
                    impl Artist {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Name of artist being played. This type has no unit defined"]
                        pub fn value(&self) -> &String {
                            &self.value
                        }
                        #[doc = r" Set the"]
                        #[doc = "Name of artist being played. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: String,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &String) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: String,
                            timestamp: Option<crate::v3::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Name of album being played. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Album {
                        pub value: String,
                        pub timestamp: crate::v3::Timestamp,
                    }
                    impl Album {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Name of album being played. This type has no unit defined"]
                        pub fn value(&self) -> &String {
                            &self.value
                        }
                        #[doc = r" Set the"]
                        #[doc = "Name of album being played. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: String,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &String) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: String,
                            timestamp: Option<crate::v3::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Name of track being played. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Track {
                        pub value: String,
                        pub timestamp: crate::v3::Timestamp,
                    }
                    impl Track {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Name of track being played. This type has no unit defined"]
                        pub fn value(&self) -> &String {
                            &self.value
                        }
                        #[doc = r" Set the"]
                        #[doc = "Name of track being played. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: String,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &String) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: String,
                            timestamp: Option<crate::v3::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "User Resource associated with the media. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct URI {
                        pub value: String,
                        pub timestamp: crate::v3::Timestamp,
                    }
                    impl URI {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "User Resource associated with the media. This type has no unit defined"]
                        pub fn value(&self) -> &String {
                            &self.value
                        }
                        #[doc = r" Set the"]
                        #[doc = "User Resource associated with the media. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: String,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &String) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: String,
                            timestamp: Option<crate::v3::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod hvac {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Is recirculation active.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsRecirculationActive {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsRecirculationActive {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is recirculation active.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Is recirculation active.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Is front defroster active.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsFrontDefrosterActive {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsFrontDefrosterActive {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is front defroster active.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Is front defroster active.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Is rear defroster active.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsRearDefrosterActive {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsRearDefrosterActive {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is rear defroster active.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Is rear defroster active.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Is Air conditioning active.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsAirConditioningActive {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsAirConditioningActive {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is Air conditioning active.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Is Air conditioning active.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Ambient air temperature inside the vehicle.. The unit of this type is celsius"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct AmbientAirTemperature {
                pub value: crate::v3::units::Celsius<f32>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl AmbientAirTemperature {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Ambient air temperature inside the vehicle.. The unit of this type is celsius"]
                pub fn value(&self) -> &crate::v3::units::Celsius<f32> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Ambient air temperature inside the vehicle.. The unit of this type is celsius"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::Celsius<f32>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v3::units::Celsius<f32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::Celsius<f32>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod station {}
        }
        #[allow(non_snake_case)]
        pub mod rearshade {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Switch controlling sliding action such as window, sunroof, or blind.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Switch {
                pub value: String,
                pub timestamp: crate::v3::Timestamp,
            }
            impl Switch {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Switch controlling sliding action such as window, sunroof, or blind.. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Switch controlling sliding action such as window, sunroof, or blind.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: String,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Position of window blind. 0 = Fully retracted. 100 = Fully deployed.. The unit of this type is percent"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Position {
                pub value: crate::v3::units::Percent<u8>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl Position {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Position of window blind. 0 = Fully retracted. 100 = Fully deployed.. The unit of this type is percent"]
                pub fn value(&self) -> &crate::v3::units::Percent<u8> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Position of window blind. 0 = Fully retracted. 100 = Fully deployed.. The unit of this type is percent"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::Percent<u8>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v3::units::Percent<u8>) -> bool {
                    v.0 <= 100u8 && v.0 >= 0u8
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::Percent<u8>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
    }
    #[allow(non_snake_case)]
    pub mod body {
        use cdds_derive::Topic;
        use cyclonedds_rs::*;
        #[doc = "Body type code as defined by ISO 3779.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct BodyType {
            pub value: String,
        }
        impl BodyType {
            #[doc = r" Get the "]
            #[doc = "Body type code as defined by ISO 3779.. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "Body type code as defined by ISO 3779.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.value = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { value })
                } else {
                    None
                }
            }
        }
        #[doc = "Location of the fuel cap or charge port.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct RefuelPosition {
            pub value: String,
        }
        impl RefuelPosition {
            #[doc = r" Get the "]
            #[doc = "Location of the fuel cap or charge port.. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "Location of the fuel cap or charge port.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.value = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { value })
                } else {
                    None
                }
            }
        }
        #[doc = "Rear spoiler position, 0% = Spoiler fully stowed. 100% = Spoiler fully exposed.. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct RearMainSpoilerPosition {
            pub value: crate::v3::units::Percent<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl RearMainSpoilerPosition {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Rear spoiler position, 0% = Spoiler fully stowed. 100% = Spoiler fully exposed.. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v3::units::Percent<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "Rear spoiler position, 0% = Spoiler fully stowed. 100% = Spoiler fully exposed.. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Percent<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. Return true if the value is"]
            #[doc = r"within bounds."]
            pub fn bounds_check(v: &crate::v3::units::Percent<f32>) -> bool {
                v.0 <= 100f32 && v.0 >= 0f32
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Percent<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod mirrors {}
        #[allow(non_snake_case)]
        pub mod lights {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Is high beam on?. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsHighBeamOn {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsHighBeamOn {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is high beam on?. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Is high beam on?. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Is low beam on?. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsLowBeamOn {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsLowBeamOn {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is low beam on?. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Is low beam on?. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Are running lights on?. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsRunningOn {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsRunningOn {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Are running lights on?. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Are running lights on?. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Is backup (reverse) light on?. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsBackupOn {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsBackupOn {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is backup (reverse) light on?. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Is backup (reverse) light on?. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Is parking light on?. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsParkingOn {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsParkingOn {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is parking light on?. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Is parking light on?. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Is brake light on?. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsBrakeOn {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsBrakeOn {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is brake light on?. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Is brake light on?. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Is rear fog light on?. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsRearFogOn {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsRearFogOn {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is rear fog light on?. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Is rear fog light on?. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Is front fog light on?. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsFrontFogOn {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsFrontFogOn {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is front fog light on?. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Is front fog light on?. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Are hazards on?. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsHazardOn {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsHazardOn {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Are hazards on?. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Are hazards on?. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Is left indicator flashing?. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsLeftIndicatorOn {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsLeftIndicatorOn {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is left indicator flashing?. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Is left indicator flashing?. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Is right indicator flashing?. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsRightIndicatorOn {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsRightIndicatorOn {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is right indicator flashing?. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Is right indicator flashing?. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod windshield {
            #[allow(non_snake_case)]
            pub mod wiping {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Wiper mode requested by user/driver. INTERVAL indicates intermittent wiping, with fixed time interval between each wipe. RAIN_SENSOR indicates intermittent wiping based on rain intensity.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Mode {
                    pub value: String,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key_enum]
                    pub position: crate::v3::Position,
                }
                impl Mode {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Wiper mode requested by user/driver. INTERVAL indicates intermittent wiping, with fixed time interval between each wipe. RAIN_SENSOR indicates intermittent wiping based on rain intensity.. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,position)"]
                    pub fn value(&self) -> (&String, &crate::v3::Position) {
                        (&self.value, &self.position)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Wiper mode requested by user/driver. INTERVAL indicates intermittent wiping, with fixed time interval between each wipe. RAIN_SENSOR indicates intermittent wiping based on rain intensity.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        position: crate::v3::Position,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.position = position;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v3::Timestamp>,
                        position: crate::v3::Position,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                position,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Relative intensity/sensitivity for interval and rain sensor mode as requested by user/driver. Has no significance if Windshield.Wiping.Mode is OFF/SLOW/MEDIUM/FAST 0 - wipers inactive. 1 - minimum intensity (lowest frequency/sensitivity, longest interval). 2/3/4/... - higher intensity (higher frequency/sensitivity, shorter interval). Maximum value supported is vehicle specific.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Intensity {
                    pub value: u8,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key_enum]
                    pub position: crate::v3::Position,
                }
                impl Intensity {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Relative intensity/sensitivity for interval and rain sensor mode as requested by user/driver. Has no significance if Windshield.Wiping.Mode is OFF/SLOW/MEDIUM/FAST 0 - wipers inactive. 1 - minimum intensity (lowest frequency/sensitivity, longest interval). 2/3/4/... - higher intensity (higher frequency/sensitivity, shorter interval). Maximum value supported is vehicle specific.. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,position)"]
                    pub fn value(&self) -> (&u8, &crate::v3::Position) {
                        (&self.value, &self.position)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Relative intensity/sensitivity for interval and rain sensor mode as requested by user/driver. Has no significance if Windshield.Wiping.Mode is OFF/SLOW/MEDIUM/FAST 0 - wipers inactive. 1 - minimum intensity (lowest frequency/sensitivity, longest interval). 2/3/4/... - higher intensity (higher frequency/sensitivity, shorter interval). Maximum value supported is vehicle specific.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: u8,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        position: crate::v3::Position,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.position = position;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &u8) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: u8,
                        timestamp: Option<crate::v3::Timestamp>,
                        position: crate::v3::Position,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                position,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Wiper wear as percent. 0 = No Wear. 100 = Worn. Replacement required. Method for calculating or estimating wiper wear is vehicle specific. For windshields with multiple wipers the wear reported shall correspond to the most worn wiper.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct WiperWear {
                    pub value: u8,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key_enum]
                    pub position: crate::v3::Position,
                }
                impl WiperWear {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Wiper wear as percent. 0 = No Wear. 100 = Worn. Replacement required. Method for calculating or estimating wiper wear is vehicle specific. For windshields with multiple wipers the wear reported shall correspond to the most worn wiper.. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,position)"]
                    pub fn value(&self) -> (&u8, &crate::v3::Position) {
                        (&self.value, &self.position)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Wiper wear as percent. 0 = No Wear. 100 = Worn. Replacement required. Method for calculating or estimating wiper wear is vehicle specific. For windshields with multiple wipers the wear reported shall correspond to the most worn wiper.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: u8,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        position: crate::v3::Position,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.position = position;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &u8) -> bool {
                        *v <= 100u8 && true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: u8,
                        timestamp: Option<crate::v3::Timestamp>,
                        position: crate::v3::Position,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                position,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Wiper wear status. True = Worn, Replacement recommended or required. False = Not Worn.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct IsWipersWorn {
                    pub value: bool,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key_enum]
                    pub position: crate::v3::Position,
                }
                impl IsWipersWorn {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Wiper wear status. True = Worn, Replacement recommended or required. False = Not Worn.. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,position)"]
                    pub fn value(&self) -> (&bool, &crate::v3::Position) {
                        (&self.value, &self.position)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Wiper wear status. True = Worn, Replacement recommended or required. False = Not Worn.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        position: crate::v3::Position,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.position = position;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v3::Timestamp>,
                        position: crate::v3::Position,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                position,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[allow(non_snake_case)]
                pub mod system {
                    use cdds_derive::Topic;
                    use cyclonedds_rs::*;
                    #[doc = "Requested mode of wiper system. STOP_HOLD means that the wipers shall move to position given by TargetPosition and then hold the position. WIPE means that wipers shall move to the position given by TargetPosition and then hold the position if no new TargetPosition is requested. PLANT_MODE means that wiping is disabled. Exact behavior is vehicle specific. EMERGENCY_STOP means that wiping shall be immediately stopped without holding the position.. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Mode {
                        pub value: String,
                        pub timestamp: crate::v3::Timestamp,
                        #[topic_key_enum]
                        pub position: crate::v3::Position,
                    }
                    impl Mode {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Requested mode of wiper system. STOP_HOLD means that the wipers shall move to position given by TargetPosition and then hold the position. WIPE means that wipers shall move to the position given by TargetPosition and then hold the position if no new TargetPosition is requested. PLANT_MODE means that wiping is disabled. Exact behavior is vehicle specific. EMERGENCY_STOP means that wiping shall be immediately stopped without holding the position.. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,position)"]
                        pub fn value(&self) -> (&String, &crate::v3::Position) {
                            (&self.value, &self.position)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Requested mode of wiper system. STOP_HOLD means that the wipers shall move to position given by TargetPosition and then hold the position. WIPE means that wipers shall move to the position given by TargetPosition and then hold the position if no new TargetPosition is requested. PLANT_MODE means that wiping is disabled. Exact behavior is vehicle specific. EMERGENCY_STOP means that wiping shall be immediately stopped without holding the position.. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: String,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                            position: crate::v3::Position,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            self.position = position;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &String) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: String,
                            timestamp: Option<crate::v3::Timestamp>,
                            position: crate::v3::Position,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    position,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Wiping frequency/speed, measured in cycles per minute. The signal concerns the actual speed of the wiper blades when moving. Intervals/pauses are excluded, i.e. the value corresponds to the number of cycles that would be completed in 1 minute if wiping permanently over default range.. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Frequency {
                        pub value: u8,
                        pub timestamp: crate::v3::Timestamp,
                        #[topic_key_enum]
                        pub position: crate::v3::Position,
                    }
                    impl Frequency {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Wiping frequency/speed, measured in cycles per minute. The signal concerns the actual speed of the wiper blades when moving. Intervals/pauses are excluded, i.e. the value corresponds to the number of cycles that would be completed in 1 minute if wiping permanently over default range.. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,position)"]
                        pub fn value(&self) -> (&u8, &crate::v3::Position) {
                            (&self.value, &self.position)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Wiping frequency/speed, measured in cycles per minute. The signal concerns the actual speed of the wiper blades when moving. Intervals/pauses are excluded, i.e. the value corresponds to the number of cycles that would be completed in 1 minute if wiping permanently over default range.. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: u8,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                            position: crate::v3::Position,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            self.position = position;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &u8) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: u8,
                            timestamp: Option<crate::v3::Timestamp>,
                            position: crate::v3::Position,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    position,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Requested position of main wiper blade for the wiper system relative to reference position. Location of reference position (0 degrees) and direction of positive/negative degrees is vehicle specific. System behavior when receiving TargetPosition depends on Mode and IsEndingWipeCycle. Supported values are vehicle specific and might be dynamically corrected. If IsEndingWipeCycle=True then wipers will complete current movement before actuating new TargetPosition. If IsEndingWipeCycle=False then wipers will directly change destination if the TargetPosition is changed.. The unit of this type is degrees"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct TargetPosition {
                        pub value: f32,
                        pub timestamp: crate::v3::Timestamp,
                        #[topic_key_enum]
                        pub position: crate::v3::Position,
                    }
                    impl TargetPosition {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Requested position of main wiper blade for the wiper system relative to reference position. Location of reference position (0 degrees) and direction of positive/negative degrees is vehicle specific. System behavior when receiving TargetPosition depends on Mode and IsEndingWipeCycle. Supported values are vehicle specific and might be dynamically corrected. If IsEndingWipeCycle=True then wipers will complete current movement before actuating new TargetPosition. If IsEndingWipeCycle=False then wipers will directly change destination if the TargetPosition is changed.. The unit of this type is degrees"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,position)"]
                        pub fn value(&self) -> (&f32, &crate::v3::Position) {
                            (&self.value, &self.position)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Requested position of main wiper blade for the wiper system relative to reference position. Location of reference position (0 degrees) and direction of positive/negative degrees is vehicle specific. System behavior when receiving TargetPosition depends on Mode and IsEndingWipeCycle. Supported values are vehicle specific and might be dynamically corrected. If IsEndingWipeCycle=True then wipers will complete current movement before actuating new TargetPosition. If IsEndingWipeCycle=False then wipers will directly change destination if the TargetPosition is changed.. The unit of this type is degrees"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: f32,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                            position: crate::v3::Position,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            self.position = position;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &f32) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: f32,
                            timestamp: Option<crate::v3::Timestamp>,
                            position: crate::v3::Position,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    position,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Actual position of main wiper blade for the wiper system relative to reference position. Location of reference position (0 degrees) and direction of positive/negative degrees is vehicle specific.. The unit of this type is degrees"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct ActualPosition {
                        pub value: f32,
                        pub timestamp: crate::v3::Timestamp,
                        #[topic_key_enum]
                        pub position: crate::v3::Position,
                    }
                    impl ActualPosition {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Actual position of main wiper blade for the wiper system relative to reference position. Location of reference position (0 degrees) and direction of positive/negative degrees is vehicle specific.. The unit of this type is degrees"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,position)"]
                        pub fn value(&self) -> (&f32, &crate::v3::Position) {
                            (&self.value, &self.position)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Actual position of main wiper blade for the wiper system relative to reference position. Location of reference position (0 degrees) and direction of positive/negative degrees is vehicle specific.. The unit of this type is degrees"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: f32,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                            position: crate::v3::Position,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            self.position = position;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &f32) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: f32,
                            timestamp: Option<crate::v3::Timestamp>,
                            position: crate::v3::Position,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    position,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Actual current used by wiper drive.. The unit of this type is A"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct DriveCurrent {
                        pub value: crate::v3::units::Amp<f32>,
                        pub timestamp: crate::v3::Timestamp,
                        #[topic_key_enum]
                        pub position: crate::v3::Position,
                    }
                    impl DriveCurrent {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Actual current used by wiper drive.. The unit of this type is A"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,position)"]
                        pub fn value(&self) -> (&crate::v3::units::Amp<f32>, &crate::v3::Position) {
                            (&self.value, &self.position)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Actual current used by wiper drive.. The unit of this type is A"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: crate::v3::units::Amp<f32>,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                            position: crate::v3::Position,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            self.position = position;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &crate::v3::units::Amp<f32>) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: crate::v3::units::Amp<f32>,
                            timestamp: Option<crate::v3::Timestamp>,
                            position: crate::v3::Position,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    position,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Indicates wiper movement. True if wiper blades are moving. Change of direction shall be considered as IsWiping if wipers will continue to move directly after the change of direction.. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct IsWiping {
                        pub value: bool,
                        pub timestamp: crate::v3::Timestamp,
                        #[topic_key_enum]
                        pub position: crate::v3::Position,
                    }
                    impl IsWiping {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Indicates wiper movement. True if wiper blades are moving. Change of direction shall be considered as IsWiping if wipers will continue to move directly after the change of direction.. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,position)"]
                        pub fn value(&self) -> (&bool, &crate::v3::Position) {
                            (&self.value, &self.position)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Indicates wiper movement. True if wiper blades are moving. Change of direction shall be considered as IsWiping if wipers will continue to move directly after the change of direction.. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                            position: crate::v3::Position,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            self.position = position;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v3::Timestamp>,
                            position: crate::v3::Position,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    position,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Indicates if current wipe movement is completed or near completion. True = Movement is completed or near completion. Changes to RequestedPosition will be executed first after reaching previous RequestedPosition, if it has not already been reached. False = Movement is not near completion. Any change to RequestedPosition will be executed immediately. Change of direction may not be allowed.. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct IsEndingWipeCycle {
                        pub value: bool,
                        pub timestamp: crate::v3::Timestamp,
                        #[topic_key_enum]
                        pub position: crate::v3::Position,
                    }
                    impl IsEndingWipeCycle {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Indicates if current wipe movement is completed or near completion. True = Movement is completed or near completion. Changes to RequestedPosition will be executed first after reaching previous RequestedPosition, if it has not already been reached. False = Movement is not near completion. Any change to RequestedPosition will be executed immediately. Change of direction may not be allowed.. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,position)"]
                        pub fn value(&self) -> (&bool, &crate::v3::Position) {
                            (&self.value, &self.position)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Indicates if current wipe movement is completed or near completion. True = Movement is completed or near completion. Changes to RequestedPosition will be executed first after reaching previous RequestedPosition, if it has not already been reached. False = Movement is not near completion. Any change to RequestedPosition will be executed immediately. Change of direction may not be allowed.. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                            position: crate::v3::Position,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            self.position = position;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v3::Timestamp>,
                            position: crate::v3::Position,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    position,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Indicates system failure. True if wiping is disabled due to system failure.. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct IsWiperError {
                        pub value: bool,
                        pub timestamp: crate::v3::Timestamp,
                        #[topic_key_enum]
                        pub position: crate::v3::Position,
                    }
                    impl IsWiperError {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Indicates system failure. True if wiping is disabled due to system failure.. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,position)"]
                        pub fn value(&self) -> (&bool, &crate::v3::Position) {
                            (&self.value, &self.position)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Indicates system failure. True if wiping is disabled due to system failure.. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                            position: crate::v3::Position,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            self.position = position;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v3::Timestamp>,
                            position: crate::v3::Position,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    position,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Indicates if a requested position has been reached. IsPositionReached refers to the previous position in case the TargetPosition is updated while IsEndingWipeCycle=True. True = Current or Previous TargetPosition reached. False = Position not (yet) reached, or wipers have moved away from the reached position.. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct IsPositionReached {
                        pub value: bool,
                        pub timestamp: crate::v3::Timestamp,
                        #[topic_key_enum]
                        pub position: crate::v3::Position,
                    }
                    impl IsPositionReached {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Indicates if a requested position has been reached. IsPositionReached refers to the previous position in case the TargetPosition is updated while IsEndingWipeCycle=True. True = Current or Previous TargetPosition reached. False = Position not (yet) reached, or wipers have moved away from the reached position.. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,position)"]
                        pub fn value(&self) -> (&bool, &crate::v3::Position) {
                            (&self.value, &self.position)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Indicates if a requested position has been reached. IsPositionReached refers to the previous position in case the TargetPosition is updated while IsEndingWipeCycle=True. True = Current or Previous TargetPosition reached. False = Position not (yet) reached, or wipers have moved away from the reached position.. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                            position: crate::v3::Position,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            self.position = position;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v3::Timestamp>,
                            position: crate::v3::Position,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    position,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Indicates if wiper movement is blocked. True = Movement blocked. False = Movement not blocked.. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct IsBlocked {
                        pub value: bool,
                        pub timestamp: crate::v3::Timestamp,
                        #[topic_key_enum]
                        pub position: crate::v3::Position,
                    }
                    impl IsBlocked {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Indicates if wiper movement is blocked. True = Movement blocked. False = Movement not blocked.. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,position)"]
                        pub fn value(&self) -> (&bool, &crate::v3::Position) {
                            (&self.value, &self.position)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Indicates if wiper movement is blocked. True = Movement blocked. False = Movement not blocked.. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                            position: crate::v3::Position,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            self.position = position;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v3::Timestamp>,
                            position: crate::v3::Position,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    position,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Indicates if wiper system is overheated. True = Wiper system overheated. False = Wiper system not overheated.. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct IsOverheated {
                        pub value: bool,
                        pub timestamp: crate::v3::Timestamp,
                        #[topic_key_enum]
                        pub position: crate::v3::Position,
                    }
                    impl IsOverheated {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Indicates if wiper system is overheated. True = Wiper system overheated. False = Wiper system not overheated.. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,position)"]
                        pub fn value(&self) -> (&bool, &crate::v3::Position) {
                            (&self.value, &self.position)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Indicates if wiper system is overheated. True = Wiper system overheated. False = Wiper system not overheated.. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                            position: crate::v3::Position,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            self.position = position;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v3::Timestamp>,
                            position: crate::v3::Position,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    position,
                                })
                            } else {
                                None
                            }
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod washerfluid {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Low level indication for washer fluid. True = Level Low. False = Level OK.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct IsLevelLow {
                    pub value: bool,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key_enum]
                    pub position: crate::v3::Position,
                }
                impl IsLevelLow {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Low level indication for washer fluid. True = Level Low. False = Level OK.. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,position)"]
                    pub fn value(&self) -> (&bool, &crate::v3::Position) {
                        (&self.value, &self.position)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Low level indication for washer fluid. True = Level Low. False = Level OK.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        position: crate::v3::Position,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.position = position;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v3::Timestamp>,
                        position: crate::v3::Position,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                position,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Washer fluid level as a percent. 0 = Empty. 100 = Full.. The unit of this type is percent"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Level {
                    pub value: crate::v3::units::Percent<u8>,
                    pub timestamp: crate::v3::Timestamp,
                    #[topic_key_enum]
                    pub position: crate::v3::Position,
                }
                impl Level {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Washer fluid level as a percent. 0 = Empty. 100 = Full.. The unit of this type is percent"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,position)"]
                    pub fn value(&self) -> (&crate::v3::units::Percent<u8>, &crate::v3::Position) {
                        (&self.value, &self.position)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Washer fluid level as a percent. 0 = Empty. 100 = Full.. The unit of this type is percent"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Percent<u8>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                        position: crate::v3::Position,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        self.position = position;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v3::units::Percent<u8>) -> bool {
                        v.0 <= 100u8 && true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Percent<u8>,
                        timestamp: Option<crate::v3::Timestamp>,
                        position: crate::v3::Position,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                                position,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod raindetection {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Rain intensity. 0 = Dry, No Rain. 100 = Covered.. The unit of this type is percent"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Intensity {
                pub value: crate::v3::units::Percent<u8>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl Intensity {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Rain intensity. 0 = Dry, No Rain. 100 = Covered.. The unit of this type is percent"]
                pub fn value(&self) -> &crate::v3::units::Percent<u8> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Rain intensity. 0 = Dry, No Rain. 100 = Covered.. The unit of this type is percent"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::Percent<u8>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v3::units::Percent<u8>) -> bool {
                    v.0 <= 100u8 && true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::Percent<u8>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod horn {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Horn active or inactive. True = Active. False = Inactive.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsActive {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsActive {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Horn active or inactive. True = Active. False = Inactive.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Horn active or inactive. True = Active. False = Inactive.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod trunk {}
        #[allow(non_snake_case)]
        pub mod hood {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Hood open or closed. True = Open. False = Closed.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsOpen {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsOpen {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Hood open or closed. True = Open. False = Closed.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Hood open or closed. True = Open. False = Closed.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
    }
    #[allow(non_snake_case)]
    pub mod powertrain {
        use cdds_derive::Topic;
        use cyclonedds_rs::*;
        #[doc = "The accumulated energy from regenerative braking over lifetime.. The unit of this type is kWh"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct AccumulatedBrakingEnergy {
            pub value: crate::v3::units::KilowattHour<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl AccumulatedBrakingEnergy {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "The accumulated energy from regenerative braking over lifetime.. The unit of this type is kWh"]
            pub fn value(&self) -> &crate::v3::units::KilowattHour<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "The accumulated energy from regenerative braking over lifetime.. The unit of this type is kWh"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::KilowattHour<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::KilowattHour<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::KilowattHour<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Remaining range in meters using all energy sources available in the vehicle.. The unit of this type is m"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Range {
            pub value: crate::v3::units::Metre<u32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl Range {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Remaining range in meters using all energy sources available in the vehicle.. The unit of this type is m"]
            pub fn value(&self) -> &crate::v3::units::Metre<u32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "Remaining range in meters using all energy sources available in the vehicle.. The unit of this type is m"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Metre<u32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Metre<u32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Metre<u32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Defines the powertrain type of the vehicle.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Type {
            pub value: String,
        }
        impl Type {
            #[doc = r" Get the "]
            #[doc = "Defines the powertrain type of the vehicle.. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "Defines the powertrain type of the vehicle.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.value = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { value })
                } else {
                    None
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod fuelsystem {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "High level information of fuel types supported. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct SupportedFuelTypes {
                pub value: Vec<String>,
            }
            impl SupportedFuelTypes {
                #[doc = r" Get the "]
                #[doc = "High level information of fuel types supported. This type has no unit defined"]
                pub fn value(&self) -> &Vec<String> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "High level information of fuel types supported. This type has no unit defined"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: Vec<String>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &Vec<String>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: Vec<String>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Detailed information on fuels supported by the vehicle. Identifiers originating from DIN EN 16942:2021-08, appendix B, with additional suffix for octane (RON) where relevant.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct SupportedFuel {
                pub value: Vec<String>,
            }
            impl SupportedFuel {
                #[doc = r" Get the "]
                #[doc = "Detailed information on fuels supported by the vehicle. Identifiers originating from DIN EN 16942:2021-08, appendix B, with additional suffix for octane (RON) where relevant.. This type has no unit defined"]
                pub fn value(&self) -> &Vec<String> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Detailed information on fuels supported by the vehicle. Identifiers originating from DIN EN 16942:2021-08, appendix B, with additional suffix for octane (RON) where relevant.. This type has no unit defined"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: Vec<String>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &Vec<String>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: Vec<String>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Defines the hybrid type of the vehicle.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct HybridType {
                pub value: String,
            }
            impl HybridType {
                #[doc = r" Get the "]
                #[doc = "Defines the hybrid type of the vehicle.. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Defines the hybrid type of the vehicle.. This type has no unit defined"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: String) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Capacity of the fuel tank in liters.. The unit of this type is l"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct TankCapacity {
                pub value: crate::v3::units::Litre<f32>,
            }
            impl TankCapacity {
                #[doc = r" Get the "]
                #[doc = "Capacity of the fuel tank in liters.. The unit of this type is l"]
                pub fn value(&self) -> &crate::v3::units::Litre<f32> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Capacity of the fuel tank in liters.. The unit of this type is l"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: crate::v3::units::Litre<f32>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v3::units::Litre<f32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: crate::v3::units::Litre<f32>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Level in fuel tank as percent of capacity. 0 = empty. 100 = full.. The unit of this type is percent"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Level {
                pub value: crate::v3::units::Percent<u8>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl Level {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Level in fuel tank as percent of capacity. 0 = empty. 100 = full.. The unit of this type is percent"]
                pub fn value(&self) -> &crate::v3::units::Percent<u8> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Level in fuel tank as percent of capacity. 0 = empty. 100 = full.. The unit of this type is percent"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::Percent<u8>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v3::units::Percent<u8>) -> bool {
                    v.0 <= 100u8 && v.0 >= 0u8
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::Percent<u8>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Remaining range in meters using only liquid fuel.. The unit of this type is m"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Range {
                pub value: crate::v3::units::Metre<u32>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl Range {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Remaining range in meters using only liquid fuel.. The unit of this type is m"]
                pub fn value(&self) -> &crate::v3::units::Metre<u32> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Remaining range in meters using only liquid fuel.. The unit of this type is m"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::Metre<u32>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v3::units::Metre<u32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::Metre<u32>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Current consumption in liters per 100 km.. The unit of this type is l/100km"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct InstantConsumption {
                pub value: crate::v3::units::LiterPerHundredKm<f32>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl InstantConsumption {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Current consumption in liters per 100 km.. The unit of this type is l/100km"]
                pub fn value(&self) -> &crate::v3::units::LiterPerHundredKm<f32> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Current consumption in liters per 100 km.. The unit of this type is l/100km"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::LiterPerHundredKm<f32>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v3::units::LiterPerHundredKm<f32>) -> bool {
                    true && v.0 >= 0f32
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::LiterPerHundredKm<f32>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Average consumption in liters per 100 km.. The unit of this type is l/100km"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct AverageConsumption {
                pub value: crate::v3::units::LiterPerHundredKm<f32>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl AverageConsumption {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Average consumption in liters per 100 km.. The unit of this type is l/100km"]
                pub fn value(&self) -> &crate::v3::units::LiterPerHundredKm<f32> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Average consumption in liters per 100 km.. The unit of this type is l/100km"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::LiterPerHundredKm<f32>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v3::units::LiterPerHundredKm<f32>) -> bool {
                    true && v.0 >= 0f32
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::LiterPerHundredKm<f32>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Fuel amount in liters consumed since start of current trip.. The unit of this type is l"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct ConsumptionSinceStart {
                pub value: crate::v3::units::Litre<f32>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl ConsumptionSinceStart {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Fuel amount in liters consumed since start of current trip.. The unit of this type is l"]
                pub fn value(&self) -> &crate::v3::units::Litre<f32> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Fuel amount in liters consumed since start of current trip.. The unit of this type is l"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::Litre<f32>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v3::units::Litre<f32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::Litre<f32>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Time in seconds elapsed since start of current trip.. The unit of this type is s"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct TimeSinceStart {
                pub value: crate::v3::units::Second<u32>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl TimeSinceStart {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Time in seconds elapsed since start of current trip.. The unit of this type is s"]
                pub fn value(&self) -> &crate::v3::units::Second<u32> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Time in seconds elapsed since start of current trip.. The unit of this type is s"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::Second<u32>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v3::units::Second<u32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::Second<u32>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates whether eco start stop is currently enabled.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsEngineStopStartEnabled {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsEngineStopStartEnabled {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates whether eco start stop is currently enabled.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Indicates whether eco start stop is currently enabled.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates that the fuel level is low (e.g. <50km range).. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsFuelLevelLow {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsFuelLevelLow {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates that the fuel level is low (e.g. <50km range).. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Indicates that the fuel level is low (e.g. <50km range).. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod tractionbattery {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Battery Identification Number as assigned by OEM.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Id {
                pub value: String,
            }
            impl Id {
                #[doc = r" Get the "]
                #[doc = "Battery Identification Number as assigned by OEM.. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Battery Identification Number as assigned by OEM.. This type has no unit defined"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: String) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Production date of battery in ISO8601 format, e.g. YYYY-MM-DD.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct ProductionDate {
                pub value: String,
            }
            impl ProductionDate {
                #[doc = r" Get the "]
                #[doc = "Production date of battery in ISO8601 format, e.g. YYYY-MM-DD.. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Production date of battery in ISO8601 format, e.g. YYYY-MM-DD.. This type has no unit defined"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: String) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicating if the power (positive terminator) of the traction battery is connected to the powertrain.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsPowerConnected {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsPowerConnected {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicating if the power (positive terminator) of the traction battery is connected to the powertrain.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Indicating if the power (positive terminator) of the traction battery is connected to the powertrain.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicating if the ground (negative terminator) of the traction battery is connected to the powertrain.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsGroundConnected {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsGroundConnected {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicating if the ground (negative terminator) of the traction battery is connected to the powertrain.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Indicating if the ground (negative terminator) of the traction battery is connected to the powertrain.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Gross capacity of the battery.. The unit of this type is kWh"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct GrossCapacity {
                pub value: crate::v3::units::KilowattHour<u16>,
            }
            impl GrossCapacity {
                #[doc = r" Get the "]
                #[doc = "Gross capacity of the battery.. The unit of this type is kWh"]
                pub fn value(&self) -> &crate::v3::units::KilowattHour<u16> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Gross capacity of the battery.. The unit of this type is kWh"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: crate::v3::units::KilowattHour<u16>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v3::units::KilowattHour<u16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: crate::v3::units::KilowattHour<u16>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Total net capacity of the battery considering aging.. The unit of this type is kWh"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct NetCapacity {
                pub value: crate::v3::units::KilowattHour<u16>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl NetCapacity {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Total net capacity of the battery considering aging.. The unit of this type is kWh"]
                pub fn value(&self) -> &crate::v3::units::KilowattHour<u16> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Total net capacity of the battery considering aging.. The unit of this type is kWh"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::KilowattHour<u16>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v3::units::KilowattHour<u16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::KilowattHour<u16>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Calculated battery state of health at standard conditions.. The unit of this type is percent"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct StateOfHealth {
                pub value: crate::v3::units::Percent<f32>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl StateOfHealth {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Calculated battery state of health at standard conditions.. The unit of this type is percent"]
                pub fn value(&self) -> &crate::v3::units::Percent<f32> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Calculated battery state of health at standard conditions.. The unit of this type is percent"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::Percent<f32>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v3::units::Percent<f32>) -> bool {
                    v.0 <= 100f32 && v.0 >= 0f32
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::Percent<f32>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Nominal Voltage of the battery.. The unit of this type is V"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct NominalVoltage {
                pub value: crate::v3::units::Volt<u16>,
            }
            impl NominalVoltage {
                #[doc = r" Get the "]
                #[doc = "Nominal Voltage of the battery.. The unit of this type is V"]
                pub fn value(&self) -> &crate::v3::units::Volt<u16> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Nominal Voltage of the battery.. The unit of this type is V"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: crate::v3::units::Volt<u16>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v3::units::Volt<u16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: crate::v3::units::Volt<u16>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Max allowed voltage of the battery, e.g. during charging.. The unit of this type is V"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct MaxVoltage {
                pub value: crate::v3::units::Volt<u16>,
            }
            impl MaxVoltage {
                #[doc = r" Get the "]
                #[doc = "Max allowed voltage of the battery, e.g. during charging.. The unit of this type is V"]
                pub fn value(&self) -> &crate::v3::units::Volt<u16> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Max allowed voltage of the battery, e.g. during charging.. The unit of this type is V"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: crate::v3::units::Volt<u16>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v3::units::Volt<u16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: crate::v3::units::Volt<u16>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Current Voltage of the battery.. The unit of this type is V"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct CurrentVoltage {
                pub value: crate::v3::units::Volt<f32>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl CurrentVoltage {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Current Voltage of the battery.. The unit of this type is V"]
                pub fn value(&self) -> &crate::v3::units::Volt<f32> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Current Voltage of the battery.. The unit of this type is V"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::Volt<f32>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v3::units::Volt<f32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::Volt<f32>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Current current flowing in/out of battery. Positive = Current flowing in to battery, e.g. during charging. Negative = Current flowing out of battery, e.g. during driving.. The unit of this type is A"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct CurrentCurrent {
                pub value: crate::v3::units::Amp<f32>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl CurrentCurrent {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Current current flowing in/out of battery. Positive = Current flowing in to battery, e.g. during charging. Negative = Current flowing out of battery, e.g. during driving.. The unit of this type is A"]
                pub fn value(&self) -> &crate::v3::units::Amp<f32> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Current current flowing in/out of battery. Positive = Current flowing in to battery, e.g. during charging. Negative = Current flowing out of battery, e.g. during driving.. The unit of this type is A"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::Amp<f32>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v3::units::Amp<f32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::Amp<f32>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Current electrical energy flowing in/out of battery. Positive = Energy flowing in to battery, e.g. during charging. Negative = Energy flowing out of battery, e.g. during driving.. The unit of this type is W"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct CurrentPower {
                pub value: crate::v3::units::Watt<f32>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl CurrentPower {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Current electrical energy flowing in/out of battery. Positive = Energy flowing in to battery, e.g. during charging. Negative = Energy flowing out of battery, e.g. during driving.. The unit of this type is W"]
                pub fn value(&self) -> &crate::v3::units::Watt<f32> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Current electrical energy flowing in/out of battery. Positive = Energy flowing in to battery, e.g. during charging. Negative = Energy flowing out of battery, e.g. during driving.. The unit of this type is W"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::Watt<f32>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v3::units::Watt<f32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::Watt<f32>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "The accumulated energy delivered to the battery during charging over lifetime of the battery.. The unit of this type is kWh"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct AccumulatedChargedEnergy {
                pub value: crate::v3::units::KilowattHour<f32>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl AccumulatedChargedEnergy {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "The accumulated energy delivered to the battery during charging over lifetime of the battery.. The unit of this type is kWh"]
                pub fn value(&self) -> &crate::v3::units::KilowattHour<f32> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "The accumulated energy delivered to the battery during charging over lifetime of the battery.. The unit of this type is kWh"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::KilowattHour<f32>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v3::units::KilowattHour<f32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::KilowattHour<f32>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "The accumulated energy leaving HV battery for propulsion and auxiliary loads over lifetime of the battery.. The unit of this type is kWh"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct AccumulatedConsumedEnergy {
                pub value: crate::v3::units::KilowattHour<f32>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl AccumulatedConsumedEnergy {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "The accumulated energy leaving HV battery for propulsion and auxiliary loads over lifetime of the battery.. The unit of this type is kWh"]
                pub fn value(&self) -> &crate::v3::units::KilowattHour<f32> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "The accumulated energy leaving HV battery for propulsion and auxiliary loads over lifetime of the battery.. The unit of this type is kWh"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::KilowattHour<f32>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v3::units::KilowattHour<f32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::KilowattHour<f32>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "The accumulated charge throughput delivered to the battery during charging over lifetime of the battery.. The unit of this type is Ah"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct AccumulatedChargedThroughput {
                pub value: f32,
                pub timestamp: crate::v3::Timestamp,
            }
            impl AccumulatedChargedThroughput {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "The accumulated charge throughput delivered to the battery during charging over lifetime of the battery.. The unit of this type is Ah"]
                pub fn value(&self) -> &f32 {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "The accumulated charge throughput delivered to the battery during charging over lifetime of the battery.. The unit of this type is Ah"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: f32, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &f32) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: f32, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "The accumulated charge throughput leaving HV battery for propulsion and auxiliary loads over lifetime of the battery.. The unit of this type is Ah"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct AccumulatedConsumedThroughput {
                pub value: f32,
                pub timestamp: crate::v3::Timestamp,
            }
            impl AccumulatedConsumedThroughput {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "The accumulated charge throughput leaving HV battery for propulsion and auxiliary loads over lifetime of the battery.. The unit of this type is Ah"]
                pub fn value(&self) -> &f32 {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "The accumulated charge throughput leaving HV battery for propulsion and auxiliary loads over lifetime of the battery.. The unit of this type is Ah"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: f32, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &f32) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: f32, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Electrical energy lost by power dissipation to heat inside the battery.. The unit of this type is W"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct PowerLoss {
                pub value: crate::v3::units::Watt<f32>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl PowerLoss {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Electrical energy lost by power dissipation to heat inside the battery.. The unit of this type is W"]
                pub fn value(&self) -> &crate::v3::units::Watt<f32> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Electrical energy lost by power dissipation to heat inside the battery.. The unit of this type is W"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::Watt<f32>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v3::units::Watt<f32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::Watt<f32>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Remaining range in meters using only battery.. The unit of this type is m"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Range {
                pub value: crate::v3::units::Metre<u32>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl Range {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Remaining range in meters using only battery.. The unit of this type is m"]
                pub fn value(&self) -> &crate::v3::units::Metre<u32> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Remaining range in meters using only battery.. The unit of this type is m"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::Metre<u32>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v3::units::Metre<u32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::Metre<u32>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod dcdc {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Electrical energy lost by power dissipation to heat inside DC/DC converter.. The unit of this type is W"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct PowerLoss {
                    pub value: crate::v3::units::Watt<f32>,
                    pub timestamp: crate::v3::Timestamp,
                }
                impl PowerLoss {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Electrical energy lost by power dissipation to heat inside DC/DC converter.. The unit of this type is W"]
                    pub fn value(&self) -> &crate::v3::units::Watt<f32> {
                        &self.value
                    }
                    #[doc = r" Set the"]
                    #[doc = "Electrical energy lost by power dissipation to heat inside DC/DC converter.. The unit of this type is W"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Watt<f32>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v3::units::Watt<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Watt<f32>,
                        timestamp: Option<crate::v3::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Current temperature of DC/DC converter converting battery high voltage to vehicle low voltage (typically 12 Volts).. The unit of this type is celsius"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Temperature {
                    pub value: crate::v3::units::Celsius<f32>,
                    pub timestamp: crate::v3::Timestamp,
                }
                impl Temperature {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Current temperature of DC/DC converter converting battery high voltage to vehicle low voltage (typically 12 Volts).. The unit of this type is celsius"]
                    pub fn value(&self) -> &crate::v3::units::Celsius<f32> {
                        &self.value
                    }
                    #[doc = r" Set the"]
                    #[doc = "Current temperature of DC/DC converter converting battery high voltage to vehicle low voltage (typically 12 Volts).. The unit of this type is celsius"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Celsius<f32>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v3::units::Celsius<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Celsius<f32>,
                        timestamp: Option<crate::v3::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod charging {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Target charge limit (state of charge) for battery.. The unit of this type is percent"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct ChargeLimit {
                    pub value: crate::v3::units::Percent<u8>,
                    pub timestamp: crate::v3::Timestamp,
                }
                impl ChargeLimit {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Target charge limit (state of charge) for battery.. The unit of this type is percent"]
                    pub fn value(&self) -> &crate::v3::units::Percent<u8> {
                        &self.value
                    }
                    #[doc = r" Set the"]
                    #[doc = "Target charge limit (state of charge) for battery.. The unit of this type is percent"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Percent<u8>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v3::units::Percent<u8>) -> bool {
                        v.0 <= 100u8 && v.0 >= 0u8
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Percent<u8>,
                        timestamp: Option<crate::v3::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Status of the charge port cover, can potentially be controlled manually.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct ChargePortFlap {
                    pub value: String,
                    pub timestamp: crate::v3::Timestamp,
                }
                impl ChargePortFlap {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Status of the charge port cover, can potentially be controlled manually.. This type has no unit defined"]
                    pub fn value(&self) -> &String {
                        &self.value
                    }
                    #[doc = r" Set the"]
                    #[doc = "Status of the charge port cover, can potentially be controlled manually.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v3::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Indicates if a charging cable is physically connected to the vehicle or not.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct IsChargingCableConnected {
                    pub value: bool,
                    pub timestamp: crate::v3::Timestamp,
                }
                impl IsChargingCableConnected {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Indicates if a charging cable is physically connected to the vehicle or not.. This type has no unit defined"]
                    pub fn value(&self) -> &bool {
                        &self.value
                    }
                    #[doc = r" Set the"]
                    #[doc = "Indicates if a charging cable is physically connected to the vehicle or not.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v3::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Is charging cable locked to prevent removal.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct IsChargingCableLocked {
                    pub value: bool,
                    pub timestamp: crate::v3::Timestamp,
                }
                impl IsChargingCableLocked {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Is charging cable locked to prevent removal.. This type has no unit defined"]
                    pub fn value(&self) -> &bool {
                        &self.value
                    }
                    #[doc = r" Set the"]
                    #[doc = "Is charging cable locked to prevent removal.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v3::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Type of charge plug (charging inlet) available on the vehicle. IEC types refer to IEC 62196,  GBT refers to  GB/T 20234.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct ChargePlugType {
                    pub value: Vec<String>,
                }
                impl ChargePlugType {
                    #[doc = r" Get the "]
                    #[doc = "Type of charge plug (charging inlet) available on the vehicle. IEC types refer to IEC 62196,  GBT refers to  GB/T 20234.. This type has no unit defined"]
                    pub fn value(&self) -> &Vec<String> {
                        &self.value
                    }
                    #[doc = r" Set the"]
                    #[doc = "Type of charge plug (charging inlet) available on the vehicle. IEC types refer to IEC 62196,  GBT refers to  GB/T 20234.. This type has no unit defined"]
                    #[doc = r" Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(&mut self, value: Vec<String>) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &Vec<String>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(value: Vec<String>) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self { value })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Control of the charge process. MANUAL means manually initiated (plug-in event, companion app, etc). TIMER means timer-based. GRID means grid-controlled (eg ISO 15118). PROFILE means controlled by profile download to vehicle.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Mode {
                    pub value: String,
                    pub timestamp: crate::v3::Timestamp,
                }
                impl Mode {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Control of the charge process. MANUAL means manually initiated (plug-in event, companion app, etc). TIMER means timer-based. GRID means grid-controlled (eg ISO 15118). PROFILE means controlled by profile download to vehicle.. This type has no unit defined"]
                    pub fn value(&self) -> &String {
                        &self.value
                    }
                    #[doc = r" Set the"]
                    #[doc = "Control of the charge process. MANUAL means manually initiated (plug-in event, companion app, etc). TIMER means timer-based. GRID means grid-controlled (eg ISO 15118). PROFILE means controlled by profile download to vehicle.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v3::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "True if charging is ongoing. Charging is considered to be ongoing if energy is flowing from charger to vehicle.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct IsCharging {
                    pub value: bool,
                    pub timestamp: crate::v3::Timestamp,
                }
                impl IsCharging {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "True if charging is ongoing. Charging is considered to be ongoing if energy is flowing from charger to vehicle.. This type has no unit defined"]
                    pub fn value(&self) -> &bool {
                        &self.value
                    }
                    #[doc = r" Set the"]
                    #[doc = "True if charging is ongoing. Charging is considered to be ongoing if energy is flowing from charger to vehicle.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v3::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "True if discharging (vehicle to grid) is ongoing. Discharging is considered to be ongoing if energy is flowing from vehicle to charger/grid.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct IsDischarging {
                    pub value: bool,
                    pub timestamp: crate::v3::Timestamp,
                }
                impl IsDischarging {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "True if discharging (vehicle to grid) is ongoing. Discharging is considered to be ongoing if energy is flowing from vehicle to charger/grid.. This type has no unit defined"]
                    pub fn value(&self) -> &bool {
                        &self.value
                    }
                    #[doc = r" Set the"]
                    #[doc = "True if discharging (vehicle to grid) is ongoing. Discharging is considered to be ongoing if energy is flowing from vehicle to charger/grid.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v3::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Start or stop the charging process.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct StartStopCharging {
                    pub value: String,
                    pub timestamp: crate::v3::Timestamp,
                }
                impl StartStopCharging {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Start or stop the charging process.. This type has no unit defined"]
                    pub fn value(&self) -> &String {
                        &self.value
                    }
                    #[doc = r" Set the"]
                    #[doc = "Start or stop the charging process.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v3::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Electrical energy lost by power dissipation to heat inside the AC/DC converter.. The unit of this type is W"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct PowerLoss {
                    pub value: crate::v3::units::Watt<f32>,
                    pub timestamp: crate::v3::Timestamp,
                }
                impl PowerLoss {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Electrical energy lost by power dissipation to heat inside the AC/DC converter.. The unit of this type is W"]
                    pub fn value(&self) -> &crate::v3::units::Watt<f32> {
                        &self.value
                    }
                    #[doc = r" Set the"]
                    #[doc = "Electrical energy lost by power dissipation to heat inside the AC/DC converter.. The unit of this type is W"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Watt<f32>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v3::units::Watt<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Watt<f32>,
                        timestamp: Option<crate::v3::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Current temperature of AC/DC converter converting grid voltage to battery voltage.. The unit of this type is celsius"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Temperature {
                    pub value: crate::v3::units::Celsius<f32>,
                    pub timestamp: crate::v3::Timestamp,
                }
                impl Temperature {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Current temperature of AC/DC converter converting grid voltage to battery voltage.. The unit of this type is celsius"]
                    pub fn value(&self) -> &crate::v3::units::Celsius<f32> {
                        &self.value
                    }
                    #[doc = r" Set the"]
                    #[doc = "Current temperature of AC/DC converter converting grid voltage to battery voltage.. The unit of this type is celsius"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Celsius<f32>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v3::units::Celsius<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Celsius<f32>,
                        timestamp: Option<crate::v3::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Current charging rate, as in kilometers of range added per hour.. The unit of this type is km/h"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct ChargeRate {
                    pub value: crate::v3::units::KilometrePerHour<f32>,
                    pub timestamp: crate::v3::Timestamp,
                }
                impl ChargeRate {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Current charging rate, as in kilometers of range added per hour.. The unit of this type is km/h"]
                    pub fn value(&self) -> &crate::v3::units::KilometrePerHour<f32> {
                        &self.value
                    }
                    #[doc = r" Set the"]
                    #[doc = "Current charging rate, as in kilometers of range added per hour.. The unit of this type is km/h"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::KilometrePerHour<f32>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v3::units::KilometrePerHour<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::KilometrePerHour<f32>,
                        timestamp: Option<crate::v3::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "The time needed for the current charging process to reach Charging.ChargeLimit. 0 if charging is complete or no charging process is active or planned.. The unit of this type is s"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct TimeToComplete {
                    pub value: crate::v3::units::Second<u32>,
                    pub timestamp: crate::v3::Timestamp,
                }
                impl TimeToComplete {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "The time needed for the current charging process to reach Charging.ChargeLimit. 0 if charging is complete or no charging process is active or planned.. The unit of this type is s"]
                    pub fn value(&self) -> &crate::v3::units::Second<u32> {
                        &self.value
                    }
                    #[doc = r" Set the"]
                    #[doc = "The time needed for the current charging process to reach Charging.ChargeLimit. 0 if charging is complete or no charging process is active or planned.. The unit of this type is s"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Second<u32>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v3::units::Second<u32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Second<u32>,
                        timestamp: Option<crate::v3::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[allow(non_snake_case)]
                pub mod timer {
                    use cdds_derive::Topic;
                    use cyclonedds_rs::*;
                    #[doc = "Defines timer mode for charging: INACTIVE - no timer set, charging may start as soon as battery is connected to a charger. START_TIME - charging shall start at Charging.Timer.Time. END_TIME - charging shall be finished (reach Charging.ChargeLimit) at Charging.Timer.Time. When charging is completed the vehicle shall change mode to 'inactive' or set a new Charging.Timer.Time. Charging shall start immediately if mode is 'starttime' or 'endtime' and Charging.Timer.Time is a time in the past.. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Mode {
                        pub value: String,
                        pub timestamp: crate::v3::Timestamp,
                    }
                    impl Mode {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Defines timer mode for charging: INACTIVE - no timer set, charging may start as soon as battery is connected to a charger. START_TIME - charging shall start at Charging.Timer.Time. END_TIME - charging shall be finished (reach Charging.ChargeLimit) at Charging.Timer.Time. When charging is completed the vehicle shall change mode to 'inactive' or set a new Charging.Timer.Time. Charging shall start immediately if mode is 'starttime' or 'endtime' and Charging.Timer.Time is a time in the past.. This type has no unit defined"]
                        pub fn value(&self) -> &String {
                            &self.value
                        }
                        #[doc = r" Set the"]
                        #[doc = "Defines timer mode for charging: INACTIVE - no timer set, charging may start as soon as battery is connected to a charger. START_TIME - charging shall start at Charging.Timer.Time. END_TIME - charging shall be finished (reach Charging.ChargeLimit) at Charging.Timer.Time. When charging is completed the vehicle shall change mode to 'inactive' or set a new Charging.Timer.Time. Charging shall start immediately if mode is 'starttime' or 'endtime' and Charging.Timer.Time is a time in the past.. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: String,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &String) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: String,
                            timestamp: Option<crate::v3::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Time for next charging-related action, formatted according to ISO 8601 with UTC time zone. Value has no significance if Charging.Timer.Mode is 'inactive'.. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Time {
                        pub value: String,
                        pub timestamp: crate::v3::Timestamp,
                    }
                    impl Time {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Time for next charging-related action, formatted according to ISO 8601 with UTC time zone. Value has no significance if Charging.Timer.Mode is 'inactive'.. This type has no unit defined"]
                        pub fn value(&self) -> &String {
                            &self.value
                        }
                        #[doc = r" Set the"]
                        #[doc = "Time for next charging-related action, formatted according to ISO 8601 with UTC time zone. Value has no significance if Charging.Timer.Mode is 'inactive'.. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: String,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &String) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: String,
                            timestamp: Option<crate::v3::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                }
                #[allow(non_snake_case)]
                pub mod chargevoltage {
                    use cdds_derive::Topic;
                    use cyclonedds_rs::*;
                    #[doc = "Current DC charging voltage at charging inlet.. The unit of this type is V"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct DC {
                        pub value: crate::v3::units::Volt<f32>,
                        pub timestamp: crate::v3::Timestamp,
                    }
                    impl DC {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Current DC charging voltage at charging inlet.. The unit of this type is V"]
                        pub fn value(&self) -> &crate::v3::units::Volt<f32> {
                            &self.value
                        }
                        #[doc = r" Set the"]
                        #[doc = "Current DC charging voltage at charging inlet.. The unit of this type is V"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: crate::v3::units::Volt<f32>,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &crate::v3::units::Volt<f32>) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: crate::v3::units::Volt<f32>,
                            timestamp: Option<crate::v3::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Current AC charging voltage (rms) at inlet for Phase 1.. The unit of this type is V"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Phase1 {
                        pub value: crate::v3::units::Volt<f32>,
                        pub timestamp: crate::v3::Timestamp,
                    }
                    impl Phase1 {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Current AC charging voltage (rms) at inlet for Phase 1.. The unit of this type is V"]
                        pub fn value(&self) -> &crate::v3::units::Volt<f32> {
                            &self.value
                        }
                        #[doc = r" Set the"]
                        #[doc = "Current AC charging voltage (rms) at inlet for Phase 1.. The unit of this type is V"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: crate::v3::units::Volt<f32>,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &crate::v3::units::Volt<f32>) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: crate::v3::units::Volt<f32>,
                            timestamp: Option<crate::v3::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Current AC charging voltage (rms) at inlet for Phase 2.. The unit of this type is V"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Phase2 {
                        pub value: crate::v3::units::Volt<f32>,
                        pub timestamp: crate::v3::Timestamp,
                    }
                    impl Phase2 {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Current AC charging voltage (rms) at inlet for Phase 2.. The unit of this type is V"]
                        pub fn value(&self) -> &crate::v3::units::Volt<f32> {
                            &self.value
                        }
                        #[doc = r" Set the"]
                        #[doc = "Current AC charging voltage (rms) at inlet for Phase 2.. The unit of this type is V"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: crate::v3::units::Volt<f32>,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &crate::v3::units::Volt<f32>) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: crate::v3::units::Volt<f32>,
                            timestamp: Option<crate::v3::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Current AC charging voltage (rms) at inlet for Phase 3.. The unit of this type is V"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Phase3 {
                        pub value: crate::v3::units::Volt<f32>,
                        pub timestamp: crate::v3::Timestamp,
                    }
                    impl Phase3 {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Current AC charging voltage (rms) at inlet for Phase 3.. The unit of this type is V"]
                        pub fn value(&self) -> &crate::v3::units::Volt<f32> {
                            &self.value
                        }
                        #[doc = r" Set the"]
                        #[doc = "Current AC charging voltage (rms) at inlet for Phase 3.. The unit of this type is V"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: crate::v3::units::Volt<f32>,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &crate::v3::units::Volt<f32>) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: crate::v3::units::Volt<f32>,
                            timestamp: Option<crate::v3::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                }
                #[allow(non_snake_case)]
                pub mod chargecurrent {
                    use cdds_derive::Topic;
                    use cyclonedds_rs::*;
                    #[doc = "Current DC charging current at inlet. Negative if returning energy to grid.. The unit of this type is A"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct DC {
                        pub value: crate::v3::units::Amp<f32>,
                        pub timestamp: crate::v3::Timestamp,
                    }
                    impl DC {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Current DC charging current at inlet. Negative if returning energy to grid.. The unit of this type is A"]
                        pub fn value(&self) -> &crate::v3::units::Amp<f32> {
                            &self.value
                        }
                        #[doc = r" Set the"]
                        #[doc = "Current DC charging current at inlet. Negative if returning energy to grid.. The unit of this type is A"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: crate::v3::units::Amp<f32>,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &crate::v3::units::Amp<f32>) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: crate::v3::units::Amp<f32>,
                            timestamp: Option<crate::v3::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Current AC charging current (rms) at inlet for Phase 1. Negative if returning energy to grid.. The unit of this type is A"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Phase1 {
                        pub value: crate::v3::units::Amp<f32>,
                        pub timestamp: crate::v3::Timestamp,
                    }
                    impl Phase1 {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Current AC charging current (rms) at inlet for Phase 1. Negative if returning energy to grid.. The unit of this type is A"]
                        pub fn value(&self) -> &crate::v3::units::Amp<f32> {
                            &self.value
                        }
                        #[doc = r" Set the"]
                        #[doc = "Current AC charging current (rms) at inlet for Phase 1. Negative if returning energy to grid.. The unit of this type is A"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: crate::v3::units::Amp<f32>,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &crate::v3::units::Amp<f32>) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: crate::v3::units::Amp<f32>,
                            timestamp: Option<crate::v3::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Current AC charging current (rms) at inlet for Phase 2. Negative if returning energy to grid.. The unit of this type is A"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Phase2 {
                        pub value: crate::v3::units::Amp<f32>,
                        pub timestamp: crate::v3::Timestamp,
                    }
                    impl Phase2 {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Current AC charging current (rms) at inlet for Phase 2. Negative if returning energy to grid.. The unit of this type is A"]
                        pub fn value(&self) -> &crate::v3::units::Amp<f32> {
                            &self.value
                        }
                        #[doc = r" Set the"]
                        #[doc = "Current AC charging current (rms) at inlet for Phase 2. Negative if returning energy to grid.. The unit of this type is A"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: crate::v3::units::Amp<f32>,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &crate::v3::units::Amp<f32>) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: crate::v3::units::Amp<f32>,
                            timestamp: Option<crate::v3::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Current AC charging current (rms) at inlet for Phase 3. Negative if returning energy to grid.. The unit of this type is A"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Phase3 {
                        pub value: crate::v3::units::Amp<f32>,
                        pub timestamp: crate::v3::Timestamp,
                    }
                    impl Phase3 {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Current AC charging current (rms) at inlet for Phase 3. Negative if returning energy to grid.. The unit of this type is A"]
                        pub fn value(&self) -> &crate::v3::units::Amp<f32> {
                            &self.value
                        }
                        #[doc = r" Set the"]
                        #[doc = "Current AC charging current (rms) at inlet for Phase 3. Negative if returning energy to grid.. The unit of this type is A"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: crate::v3::units::Amp<f32>,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &crate::v3::units::Amp<f32>) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: crate::v3::units::Amp<f32>,
                            timestamp: Option<crate::v3::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                }
                #[allow(non_snake_case)]
                pub mod maximumchargingcurrent {
                    use cdds_derive::Topic;
                    use cyclonedds_rs::*;
                    #[doc = "Maximum DC charging current at inlet that can be accepted by the system.. The unit of this type is A"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct DC {
                        pub value: crate::v3::units::Amp<f32>,
                        pub timestamp: crate::v3::Timestamp,
                    }
                    impl DC {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Maximum DC charging current at inlet that can be accepted by the system.. The unit of this type is A"]
                        pub fn value(&self) -> &crate::v3::units::Amp<f32> {
                            &self.value
                        }
                        #[doc = r" Set the"]
                        #[doc = "Maximum DC charging current at inlet that can be accepted by the system.. The unit of this type is A"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: crate::v3::units::Amp<f32>,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &crate::v3::units::Amp<f32>) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: crate::v3::units::Amp<f32>,
                            timestamp: Option<crate::v3::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Maximum AC charging current (rms) at inlet for Phase 1 that can be accepted by the system.. The unit of this type is A"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Phase1 {
                        pub value: crate::v3::units::Amp<f32>,
                        pub timestamp: crate::v3::Timestamp,
                    }
                    impl Phase1 {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Maximum AC charging current (rms) at inlet for Phase 1 that can be accepted by the system.. The unit of this type is A"]
                        pub fn value(&self) -> &crate::v3::units::Amp<f32> {
                            &self.value
                        }
                        #[doc = r" Set the"]
                        #[doc = "Maximum AC charging current (rms) at inlet for Phase 1 that can be accepted by the system.. The unit of this type is A"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: crate::v3::units::Amp<f32>,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &crate::v3::units::Amp<f32>) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: crate::v3::units::Amp<f32>,
                            timestamp: Option<crate::v3::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Maximum AC charging current (rms) at inlet for Phase 2 that can be accepted by the system.. The unit of this type is A"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Phase2 {
                        pub value: crate::v3::units::Amp<f32>,
                        pub timestamp: crate::v3::Timestamp,
                    }
                    impl Phase2 {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Maximum AC charging current (rms) at inlet for Phase 2 that can be accepted by the system.. The unit of this type is A"]
                        pub fn value(&self) -> &crate::v3::units::Amp<f32> {
                            &self.value
                        }
                        #[doc = r" Set the"]
                        #[doc = "Maximum AC charging current (rms) at inlet for Phase 2 that can be accepted by the system.. The unit of this type is A"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: crate::v3::units::Amp<f32>,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &crate::v3::units::Amp<f32>) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: crate::v3::units::Amp<f32>,
                            timestamp: Option<crate::v3::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Maximum AC charging current (rms) at inlet for Phase 3 that can be accepted by the system.. The unit of this type is A"]
                    #[allow(non_camel_case_types)]
                    #[repr(C)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Phase3 {
                        pub value: crate::v3::units::Amp<f32>,
                        pub timestamp: crate::v3::Timestamp,
                    }
                    impl Phase3 {
                        pub fn timestamp(&self) -> &crate::v3::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Maximum AC charging current (rms) at inlet for Phase 3 that can be accepted by the system.. The unit of this type is A"]
                        pub fn value(&self) -> &crate::v3::units::Amp<f32> {
                            &self.value
                        }
                        #[doc = r" Set the"]
                        #[doc = "Maximum AC charging current (rms) at inlet for Phase 3 that can be accepted by the system.. The unit of this type is A"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: crate::v3::units::Amp<f32>,
                            maybe_timestamp: Option<crate::v3::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.value = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &crate::v3::units::Amp<f32>) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: crate::v3::units::Amp<f32>,
                            timestamp: Option<crate::v3::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod stateofcharge {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Physical state of charge of the high voltage battery, relative to net capacity. This is not necessarily the state of charge being displayed to the customer.. The unit of this type is percent"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Current {
                    pub value: crate::v3::units::Percent<f32>,
                    pub timestamp: crate::v3::Timestamp,
                }
                impl Current {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Physical state of charge of the high voltage battery, relative to net capacity. This is not necessarily the state of charge being displayed to the customer.. The unit of this type is percent"]
                    pub fn value(&self) -> &crate::v3::units::Percent<f32> {
                        &self.value
                    }
                    #[doc = r" Set the"]
                    #[doc = "Physical state of charge of the high voltage battery, relative to net capacity. This is not necessarily the state of charge being displayed to the customer.. The unit of this type is percent"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Percent<f32>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v3::units::Percent<f32>) -> bool {
                        v.0 <= 100.0f32 && v.0 >= 0f32
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Percent<f32>,
                        timestamp: Option<crate::v3::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "State of charge displayed to the customer.. The unit of this type is percent"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Displayed {
                    pub value: crate::v3::units::Percent<f32>,
                    pub timestamp: crate::v3::Timestamp,
                }
                impl Displayed {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "State of charge displayed to the customer.. The unit of this type is percent"]
                    pub fn value(&self) -> &crate::v3::units::Percent<f32> {
                        &self.value
                    }
                    #[doc = r" Set the"]
                    #[doc = "State of charge displayed to the customer.. The unit of this type is percent"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Percent<f32>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v3::units::Percent<f32>) -> bool {
                        v.0 <= 100.0f32 && v.0 >= 0f32
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Percent<f32>,
                        timestamp: Option<crate::v3::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod temperature {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Current average temperature of the battery cells.. The unit of this type is celsius"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Average {
                    pub value: crate::v3::units::Celsius<f32>,
                    pub timestamp: crate::v3::Timestamp,
                }
                impl Average {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Current average temperature of the battery cells.. The unit of this type is celsius"]
                    pub fn value(&self) -> &crate::v3::units::Celsius<f32> {
                        &self.value
                    }
                    #[doc = r" Set the"]
                    #[doc = "Current average temperature of the battery cells.. The unit of this type is celsius"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Celsius<f32>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v3::units::Celsius<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Celsius<f32>,
                        timestamp: Option<crate::v3::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Current minimum temperature of the battery cells, i.e. temperature of the coldest cell.. The unit of this type is celsius"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Min {
                    pub value: crate::v3::units::Celsius<f32>,
                    pub timestamp: crate::v3::Timestamp,
                }
                impl Min {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Current minimum temperature of the battery cells, i.e. temperature of the coldest cell.. The unit of this type is celsius"]
                    pub fn value(&self) -> &crate::v3::units::Celsius<f32> {
                        &self.value
                    }
                    #[doc = r" Set the"]
                    #[doc = "Current minimum temperature of the battery cells, i.e. temperature of the coldest cell.. The unit of this type is celsius"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Celsius<f32>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v3::units::Celsius<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Celsius<f32>,
                        timestamp: Option<crate::v3::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Current maximum temperature of the battery cells, i.e. temperature of the hottest cell.. The unit of this type is celsius"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Max {
                    pub value: crate::v3::units::Celsius<f32>,
                    pub timestamp: crate::v3::Timestamp,
                }
                impl Max {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Current maximum temperature of the battery cells, i.e. temperature of the hottest cell.. The unit of this type is celsius"]
                    pub fn value(&self) -> &crate::v3::units::Celsius<f32> {
                        &self.value
                    }
                    #[doc = r" Set the"]
                    #[doc = "Current maximum temperature of the battery cells, i.e. temperature of the hottest cell.. The unit of this type is celsius"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Celsius<f32>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v3::units::Celsius<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Celsius<f32>,
                        timestamp: Option<crate::v3::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod electricmotor {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Engine code designation, as specified by vehicle manufacturer.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct EngineCode {
                pub value: String,
            }
            impl EngineCode {
                #[doc = r" Get the "]
                #[doc = "Engine code designation, as specified by vehicle manufacturer.. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Engine code designation, as specified by vehicle manufacturer.. This type has no unit defined"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: String) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Peak power, in kilowatts, that motor(s) can generate.. The unit of this type is kW"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct MaxPower {
                pub value: crate::v3::units::Kilowatt<u16>,
            }
            impl MaxPower {
                #[doc = r" Get the "]
                #[doc = "Peak power, in kilowatts, that motor(s) can generate.. The unit of this type is kW"]
                pub fn value(&self) -> &crate::v3::units::Kilowatt<u16> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Peak power, in kilowatts, that motor(s) can generate.. The unit of this type is kW"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: crate::v3::units::Kilowatt<u16>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v3::units::Kilowatt<u16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: crate::v3::units::Kilowatt<u16>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Peak power, in newton meter, that the motor(s) can generate.. The unit of this type is Nm"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct MaxTorque {
                pub value: crate::v3::units::NewtonMetre<u16>,
            }
            impl MaxTorque {
                #[doc = r" Get the "]
                #[doc = "Peak power, in newton meter, that the motor(s) can generate.. The unit of this type is Nm"]
                pub fn value(&self) -> &crate::v3::units::NewtonMetre<u16> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Peak power, in newton meter, that the motor(s) can generate.. The unit of this type is Nm"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: crate::v3::units::NewtonMetre<u16>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v3::units::NewtonMetre<u16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: crate::v3::units::NewtonMetre<u16>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Peak regen/brake power, in kilowatts, that motor(s) can generate.. The unit of this type is kW"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct MaxRegenPower {
                pub value: crate::v3::units::Kilowatt<u16>,
            }
            impl MaxRegenPower {
                #[doc = r" Get the "]
                #[doc = "Peak regen/brake power, in kilowatts, that motor(s) can generate.. The unit of this type is kW"]
                pub fn value(&self) -> &crate::v3::units::Kilowatt<u16> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Peak regen/brake power, in kilowatts, that motor(s) can generate.. The unit of this type is kW"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: crate::v3::units::Kilowatt<u16>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v3::units::Kilowatt<u16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: crate::v3::units::Kilowatt<u16>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Peak regen/brake torque, in newton meter, that the motor(s) can generate.. The unit of this type is Nm"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct MaxRegenTorque {
                pub value: crate::v3::units::NewtonMetre<u16>,
            }
            impl MaxRegenTorque {
                #[doc = r" Get the "]
                #[doc = "Peak regen/brake torque, in newton meter, that the motor(s) can generate.. The unit of this type is Nm"]
                pub fn value(&self) -> &crate::v3::units::NewtonMetre<u16> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Peak regen/brake torque, in newton meter, that the motor(s) can generate.. The unit of this type is Nm"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: crate::v3::units::NewtonMetre<u16>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v3::units::NewtonMetre<u16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: crate::v3::units::NewtonMetre<u16>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Motor rotational speed measured as rotations per minute. Negative values indicate reverse driving mode.. The unit of this type is rpm"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Speed {
                pub value: crate::v3::units::RPM<i32>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl Speed {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Motor rotational speed measured as rotations per minute. Negative values indicate reverse driving mode.. The unit of this type is rpm"]
                pub fn value(&self) -> &crate::v3::units::RPM<i32> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Motor rotational speed measured as rotations per minute. Negative values indicate reverse driving mode.. The unit of this type is rpm"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::RPM<i32>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v3::units::RPM<i32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::RPM<i32>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Motor temperature.. The unit of this type is celsius"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Temperature {
                pub value: crate::v3::units::Celsius<i16>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl Temperature {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Motor temperature.. The unit of this type is celsius"]
                pub fn value(&self) -> &crate::v3::units::Celsius<i16> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Motor temperature.. The unit of this type is celsius"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::Celsius<i16>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v3::units::Celsius<i16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::Celsius<i16>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Motor coolant temperature (if applicable).. The unit of this type is celsius"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct CoolantTemperature {
                pub value: crate::v3::units::Celsius<i16>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl CoolantTemperature {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Motor coolant temperature (if applicable).. The unit of this type is celsius"]
                pub fn value(&self) -> &crate::v3::units::Celsius<i16> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Motor coolant temperature (if applicable).. The unit of this type is celsius"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::Celsius<i16>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v3::units::Celsius<i16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::Celsius<i16>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Current motor power output. Negative values indicate regen mode.. The unit of this type is kW"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Power {
                pub value: crate::v3::units::Kilowatt<i16>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl Power {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Current motor power output. Negative values indicate regen mode.. The unit of this type is kW"]
                pub fn value(&self) -> &crate::v3::units::Kilowatt<i16> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Current motor power output. Negative values indicate regen mode.. The unit of this type is kW"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::Kilowatt<i16>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v3::units::Kilowatt<i16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::Kilowatt<i16>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Current motor torque. Negative values indicate regen mode.. The unit of this type is Nm"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Torque {
                pub value: crate::v3::units::NewtonMetre<i16>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl Torque {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Current motor torque. Negative values indicate regen mode.. The unit of this type is Nm"]
                pub fn value(&self) -> &crate::v3::units::NewtonMetre<i16> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Current motor torque. Negative values indicate regen mode.. The unit of this type is Nm"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::NewtonMetre<i16>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v3::units::NewtonMetre<i16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::NewtonMetre<i16>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod transmission {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Transmission type.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Type {
                pub value: String,
            }
            impl Type {
                #[doc = r" Get the "]
                #[doc = "Transmission type.. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Transmission type.. This type has no unit defined"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: String) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Number of forward gears in the transmission. -1 = CVT.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct GearCount {
                pub value: i8,
            }
            impl GearCount {
                #[doc = r" Get the "]
                #[doc = "Number of forward gears in the transmission. -1 = CVT.. This type has no unit defined"]
                pub fn value(&self) -> &i8 {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Number of forward gears in the transmission. -1 = CVT.. This type has no unit defined"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: i8) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &i8) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: i8) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Drive type.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct DriveType {
                pub value: String,
            }
            impl DriveType {
                #[doc = r" Get the "]
                #[doc = "Drive type.. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Drive type.. This type has no unit defined"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: String) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Odometer reading, total distance travelled during the lifetime of the transmission.. The unit of this type is km"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct TravelledDistance {
                pub value: crate::v3::units::Kilometre<f32>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl TravelledDistance {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Odometer reading, total distance travelled during the lifetime of the transmission.. The unit of this type is km"]
                pub fn value(&self) -> &crate::v3::units::Kilometre<f32> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Odometer reading, total distance travelled during the lifetime of the transmission.. The unit of this type is km"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::Kilometre<f32>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v3::units::Kilometre<f32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::Kilometre<f32>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "The current gear. 0=Neutral, 1/2/..=Forward, -1/-2/..=Reverse.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct CurrentGear {
                pub value: i8,
                pub timestamp: crate::v3::Timestamp,
            }
            impl CurrentGear {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "The current gear. 0=Neutral, 1/2/..=Forward, -1/-2/..=Reverse.. This type has no unit defined"]
                pub fn value(&self) -> &i8 {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "The current gear. 0=Neutral, 1/2/..=Forward, -1/-2/..=Reverse.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: i8, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &i8) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: i8, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "The selected gear. 0=Neutral, 1/2/..=Forward, -1/-2/..=Reverse, 126=Park, 127=Drive.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct SelectedGear {
                pub value: i8,
                pub timestamp: crate::v3::Timestamp,
            }
            impl SelectedGear {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "The selected gear. 0=Neutral, 1/2/..=Forward, -1/-2/..=Reverse, 126=Park, 127=Drive.. This type has no unit defined"]
                pub fn value(&self) -> &i8 {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "The selected gear. 0=Neutral, 1/2/..=Forward, -1/-2/..=Reverse, 126=Park, 127=Drive.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: i8, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &i8) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: i8, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Is the transmission park lock engaged or not. False = Disengaged. True = Engaged.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsParkLockEngaged {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsParkLockEngaged {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is the transmission park lock engaged or not. False = Disengaged. True = Engaged.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Is the transmission park lock engaged or not. False = Disengaged. True = Engaged.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Is gearbox in low range mode or not. False = Normal/High range engaged. True = Low range engaged.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsLowRangeEngaged {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsLowRangeEngaged {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is gearbox in low range mode or not. False = Normal/High range engaged. True = Low range engaged.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Is gearbox in low range mode or not. False = Normal/High range engaged. True = Low range engaged.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Is electrical powertrain mechanically connected/engaged to the drivetrain or not. False = Disconnected/Disengaged. True = Connected/Engaged.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsElectricalPowertrainEngaged {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsElectricalPowertrainEngaged {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is electrical powertrain mechanically connected/engaged to the drivetrain or not. False = Disconnected/Disengaged. True = Connected/Engaged.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Is electrical powertrain mechanically connected/engaged to the drivetrain or not. False = Disconnected/Disengaged. True = Connected/Engaged.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Current gearbox performance mode.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct PerformanceMode {
                pub value: String,
                pub timestamp: crate::v3::Timestamp,
            }
            impl PerformanceMode {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Current gearbox performance mode.. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Current gearbox performance mode.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: String,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Is the gearbox in automatic or manual (paddle) mode.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct GearChangeMode {
                pub value: String,
                pub timestamp: crate::v3::Timestamp,
            }
            impl GearChangeMode {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is the gearbox in automatic or manual (paddle) mode.. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Is the gearbox in automatic or manual (paddle) mode.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: String,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "The current gearbox temperature.. The unit of this type is celsius"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Temperature {
                pub value: crate::v3::units::Celsius<i16>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl Temperature {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "The current gearbox temperature.. The unit of this type is celsius"]
                pub fn value(&self) -> &crate::v3::units::Celsius<i16> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "The current gearbox temperature.. The unit of this type is celsius"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::Celsius<i16>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v3::units::Celsius<i16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::Celsius<i16>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Clutch engagement. 0% = Clutch fully disengaged. 100% = Clutch fully engaged.. The unit of this type is percent"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct ClutchEngagement {
                pub value: crate::v3::units::Percent<f32>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl ClutchEngagement {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Clutch engagement. 0% = Clutch fully disengaged. 100% = Clutch fully engaged.. The unit of this type is percent"]
                pub fn value(&self) -> &crate::v3::units::Percent<f32> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Clutch engagement. 0% = Clutch fully disengaged. 100% = Clutch fully engaged.. The unit of this type is percent"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::Percent<f32>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v3::units::Percent<f32>) -> bool {
                    v.0 <= 100f32 && v.0 >= 0f32
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::Percent<f32>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Clutch wear as a percent. 0 = no wear. 100 = worn.. The unit of this type is percent"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct ClutchWear {
                pub value: crate::v3::units::Percent<u8>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl ClutchWear {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Clutch wear as a percent. 0 = no wear. 100 = worn.. The unit of this type is percent"]
                pub fn value(&self) -> &crate::v3::units::Percent<u8> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Clutch wear as a percent. 0 = no wear. 100 = worn.. The unit of this type is percent"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::Percent<u8>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v3::units::Percent<u8>) -> bool {
                    v.0 <= 100u8 && true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::Percent<u8>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Front Diff Lock engagement. 0% = Diff lock fully disengaged. 100% = Diff lock fully engaged.. The unit of this type is percent"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct DiffLockFrontEngagement {
                pub value: crate::v3::units::Percent<f32>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl DiffLockFrontEngagement {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Front Diff Lock engagement. 0% = Diff lock fully disengaged. 100% = Diff lock fully engaged.. The unit of this type is percent"]
                pub fn value(&self) -> &crate::v3::units::Percent<f32> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Front Diff Lock engagement. 0% = Diff lock fully disengaged. 100% = Diff lock fully engaged.. The unit of this type is percent"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::Percent<f32>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v3::units::Percent<f32>) -> bool {
                    v.0 <= 100f32 && v.0 >= 0f32
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::Percent<f32>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Rear Diff Lock engagement. 0% = Diff lock fully disengaged. 100% = Diff lock fully engaged.. The unit of this type is percent"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct DiffLockRearEngagement {
                pub value: crate::v3::units::Percent<f32>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl DiffLockRearEngagement {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Rear Diff Lock engagement. 0% = Diff lock fully disengaged. 100% = Diff lock fully engaged.. The unit of this type is percent"]
                pub fn value(&self) -> &crate::v3::units::Percent<f32> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Rear Diff Lock engagement. 0% = Diff lock fully disengaged. 100% = Diff lock fully engaged.. The unit of this type is percent"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::Percent<f32>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v3::units::Percent<f32>) -> bool {
                    v.0 <= 100f32 && v.0 >= 0f32
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::Percent<f32>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Torque distribution between front and rear axle in percent. -100% = Full torque to front axle, 0% = 50:50 Front/Rear, 100% = Full torque to rear axle.. The unit of this type is percent"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct TorqueDistribution {
                pub value: crate::v3::units::Percent<f32>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl TorqueDistribution {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Torque distribution between front and rear axle in percent. -100% = Full torque to front axle, 0% = 50:50 Front/Rear, 100% = Full torque to rear axle.. The unit of this type is percent"]
                pub fn value(&self) -> &crate::v3::units::Percent<f32> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Torque distribution between front and rear axle in percent. -100% = Full torque to front axle, 0% = 50:50 Front/Rear, 100% = Full torque to rear axle.. The unit of this type is percent"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::Percent<f32>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v3::units::Percent<f32>) -> bool {
                    v.0 <= 100f32 && v.0 >= -100f32
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::Percent<f32>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod combustionengine {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Engine code designation, as specified by vehicle manufacturer.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct EngineCode {
                pub value: String,
            }
            impl EngineCode {
                #[doc = r" Get the "]
                #[doc = "Engine code designation, as specified by vehicle manufacturer.. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Engine code designation, as specified by vehicle manufacturer.. This type has no unit defined"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: String) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Displacement in cubic centimetres.. The unit of this type is cm^3"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Displacement {
                pub value: u16,
            }
            impl Displacement {
                #[doc = r" Get the "]
                #[doc = "Displacement in cubic centimetres.. The unit of this type is cm^3"]
                pub fn value(&self) -> &u16 {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Displacement in cubic centimetres.. The unit of this type is cm^3"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: u16) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &u16) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: u16) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Stroke length in millimetres.. The unit of this type is mm"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct StrokeLength {
                pub value: crate::v3::units::Millimetre<f32>,
            }
            impl StrokeLength {
                #[doc = r" Get the "]
                #[doc = "Stroke length in millimetres.. The unit of this type is mm"]
                pub fn value(&self) -> &crate::v3::units::Millimetre<f32> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Stroke length in millimetres.. The unit of this type is mm"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: crate::v3::units::Millimetre<f32>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v3::units::Millimetre<f32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: crate::v3::units::Millimetre<f32>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Bore in millimetres.. The unit of this type is mm"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Bore {
                pub value: crate::v3::units::Millimetre<f32>,
            }
            impl Bore {
                #[doc = r" Get the "]
                #[doc = "Bore in millimetres.. The unit of this type is mm"]
                pub fn value(&self) -> &crate::v3::units::Millimetre<f32> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Bore in millimetres.. The unit of this type is mm"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: crate::v3::units::Millimetre<f32>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v3::units::Millimetre<f32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: crate::v3::units::Millimetre<f32>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Engine configuration.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Configuration {
                pub value: String,
            }
            impl Configuration {
                #[doc = r" Get the "]
                #[doc = "Engine configuration.. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Engine configuration.. This type has no unit defined"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: String) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Number of cylinders.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct NumberOfCylinders {
                pub value: u16,
            }
            impl NumberOfCylinders {
                #[doc = r" Get the "]
                #[doc = "Number of cylinders.. This type has no unit defined"]
                pub fn value(&self) -> &u16 {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Number of cylinders.. This type has no unit defined"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: u16) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &u16) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: u16) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Number of valves per cylinder.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct NumberOfValvesPerCylinder {
                pub value: u16,
            }
            impl NumberOfValvesPerCylinder {
                #[doc = r" Get the "]
                #[doc = "Number of valves per cylinder.. This type has no unit defined"]
                pub fn value(&self) -> &u16 {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Number of valves per cylinder.. This type has no unit defined"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: u16) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &u16) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: u16) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Engine compression ratio, specified in the format 'X:1', e.g. '9.2:1'.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct CompressionRatio {
                pub value: String,
            }
            impl CompressionRatio {
                #[doc = r" Get the "]
                #[doc = "Engine compression ratio, specified in the format 'X:1', e.g. '9.2:1'.. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Engine compression ratio, specified in the format 'X:1', e.g. '9.2:1'.. This type has no unit defined"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: String) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Engine oil capacity in liters.. The unit of this type is l"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct EngineOilCapacity {
                pub value: crate::v3::units::Litre<f32>,
            }
            impl EngineOilCapacity {
                #[doc = r" Get the "]
                #[doc = "Engine oil capacity in liters.. The unit of this type is l"]
                pub fn value(&self) -> &crate::v3::units::Litre<f32> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Engine oil capacity in liters.. The unit of this type is l"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: crate::v3::units::Litre<f32>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v3::units::Litre<f32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: crate::v3::units::Litre<f32>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Engine coolant capacity in liters.. The unit of this type is l"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct EngineCoolantCapacity {
                pub value: crate::v3::units::Litre<f32>,
            }
            impl EngineCoolantCapacity {
                #[doc = r" Get the "]
                #[doc = "Engine coolant capacity in liters.. The unit of this type is l"]
                pub fn value(&self) -> &crate::v3::units::Litre<f32> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Engine coolant capacity in liters.. The unit of this type is l"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: crate::v3::units::Litre<f32>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v3::units::Litre<f32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: crate::v3::units::Litre<f32>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Peak power, in kilowatts, that engine can generate.. The unit of this type is kW"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct MaxPower {
                pub value: crate::v3::units::Kilowatt<u16>,
            }
            impl MaxPower {
                #[doc = r" Get the "]
                #[doc = "Peak power, in kilowatts, that engine can generate.. The unit of this type is kW"]
                pub fn value(&self) -> &crate::v3::units::Kilowatt<u16> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Peak power, in kilowatts, that engine can generate.. The unit of this type is kW"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: crate::v3::units::Kilowatt<u16>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v3::units::Kilowatt<u16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: crate::v3::units::Kilowatt<u16>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Peak torque, in newton meter, that the engine can generate.. The unit of this type is Nm"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct MaxTorque {
                pub value: crate::v3::units::NewtonMetre<u16>,
            }
            impl MaxTorque {
                #[doc = r" Get the "]
                #[doc = "Peak torque, in newton meter, that the engine can generate.. The unit of this type is Nm"]
                pub fn value(&self) -> &crate::v3::units::NewtonMetre<u16> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Peak torque, in newton meter, that the engine can generate.. The unit of this type is Nm"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: crate::v3::units::NewtonMetre<u16>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v3::units::NewtonMetre<u16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: crate::v3::units::NewtonMetre<u16>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Type of aspiration (natural, turbocharger, supercharger etc).. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct AspirationType {
                pub value: String,
            }
            impl AspirationType {
                #[doc = r" Get the "]
                #[doc = "Type of aspiration (natural, turbocharger, supercharger etc).. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Type of aspiration (natural, turbocharger, supercharger etc).. This type has no unit defined"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: String) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Engine oil level.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct EngineOilLevel {
                pub value: String,
                pub timestamp: crate::v3::Timestamp,
            }
            impl EngineOilLevel {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Engine oil level.. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Engine oil level.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: String,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Remaining engine oil life in seconds. Negative values can be used to indicate that lifetime has been exceeded.. The unit of this type is s"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct OilLifeRemaining {
                pub value: crate::v3::units::Second<i32>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl OilLifeRemaining {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Remaining engine oil life in seconds. Negative values can be used to indicate that lifetime has been exceeded.. The unit of this type is s"]
                pub fn value(&self) -> &crate::v3::units::Second<i32> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Remaining engine oil life in seconds. Negative values can be used to indicate that lifetime has been exceeded.. The unit of this type is s"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::Second<i32>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v3::units::Second<i32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::Second<i32>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Engine Running. True if engine is rotating (Speed > 0).. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsRunning {
                pub value: bool,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IsRunning {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Engine Running. True if engine is rotating (Speed > 0).. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Engine Running. True if engine is rotating (Speed > 0).. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Engine speed measured as rotations per minute.. The unit of this type is rpm"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Speed {
                pub value: crate::v3::units::RPM<u16>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl Speed {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Engine speed measured as rotations per minute.. The unit of this type is rpm"]
                pub fn value(&self) -> &crate::v3::units::RPM<u16> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Engine speed measured as rotations per minute.. The unit of this type is rpm"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::RPM<u16>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v3::units::RPM<u16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::RPM<u16>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Accumulated time during engine lifetime with 'engine speed (rpm) > 0'.. The unit of this type is h"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct EngineHours {
                pub value: crate::v3::units::Hour<f32>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl EngineHours {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Accumulated time during engine lifetime with 'engine speed (rpm) > 0'.. The unit of this type is h"]
                pub fn value(&self) -> &crate::v3::units::Hour<f32> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Accumulated time during engine lifetime with 'engine speed (rpm) > 0'.. The unit of this type is h"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::Hour<f32>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v3::units::Hour<f32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::Hour<f32>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Accumulated idling time during engine lifetime. Definition of idling is not standardized.. The unit of this type is h"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IdleHours {
                pub value: crate::v3::units::Hour<f32>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl IdleHours {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Accumulated idling time during engine lifetime. Definition of idling is not standardized.. The unit of this type is h"]
                pub fn value(&self) -> &crate::v3::units::Hour<f32> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Accumulated idling time during engine lifetime. Definition of idling is not standardized.. The unit of this type is h"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::Hour<f32>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v3::units::Hour<f32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::Hour<f32>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Engine coolant temperature.. The unit of this type is celsius"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct ECT {
                pub value: crate::v3::units::Celsius<i16>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl ECT {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Engine coolant temperature.. The unit of this type is celsius"]
                pub fn value(&self) -> &crate::v3::units::Celsius<i16> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Engine coolant temperature.. The unit of this type is celsius"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::Celsius<i16>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v3::units::Celsius<i16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::Celsius<i16>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Engine oil temperature.. The unit of this type is celsius"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct EOT {
                pub value: crate::v3::units::Celsius<i16>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl EOT {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Engine oil temperature.. The unit of this type is celsius"]
                pub fn value(&self) -> &crate::v3::units::Celsius<i16> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Engine oil temperature.. The unit of this type is celsius"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::Celsius<i16>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v3::units::Celsius<i16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::Celsius<i16>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Manifold absolute pressure possibly boosted using forced induction.. The unit of this type is kPa"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct MAP {
                pub value: crate::v3::units::KiloPascal<u16>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl MAP {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Manifold absolute pressure possibly boosted using forced induction.. The unit of this type is kPa"]
                pub fn value(&self) -> &crate::v3::units::KiloPascal<u16> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Manifold absolute pressure possibly boosted using forced induction.. The unit of this type is kPa"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::KiloPascal<u16>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v3::units::KiloPascal<u16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::KiloPascal<u16>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Grams of air drawn into engine per second.. The unit of this type is g/s"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct MAF {
                pub value: crate::v3::units::GramPerSec<u16>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl MAF {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Grams of air drawn into engine per second.. The unit of this type is g/s"]
                pub fn value(&self) -> &crate::v3::units::GramPerSec<u16> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Grams of air drawn into engine per second.. The unit of this type is g/s"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::GramPerSec<u16>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v3::units::GramPerSec<u16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::GramPerSec<u16>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Current throttle position.. The unit of this type is percent"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct TPS {
                pub value: crate::v3::units::Percent<u8>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl TPS {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Current throttle position.. The unit of this type is percent"]
                pub fn value(&self) -> &crate::v3::units::Percent<u8> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Current throttle position.. The unit of this type is percent"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::Percent<u8>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v3::units::Percent<u8>) -> bool {
                    v.0 <= 100u8 && true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::Percent<u8>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Engine oil pressure.. The unit of this type is kPa"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct EOP {
                pub value: crate::v3::units::KiloPascal<u16>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl EOP {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Engine oil pressure.. The unit of this type is kPa"]
                pub fn value(&self) -> &crate::v3::units::KiloPascal<u16> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Engine oil pressure.. The unit of this type is kPa"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::KiloPascal<u16>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v3::units::KiloPascal<u16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::KiloPascal<u16>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Current engine power output. Shall be reported as 0 during engine breaking.. The unit of this type is kW"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Power {
                pub value: crate::v3::units::Kilowatt<u16>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl Power {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Current engine power output. Shall be reported as 0 during engine breaking.. The unit of this type is kW"]
                pub fn value(&self) -> &crate::v3::units::Kilowatt<u16> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Current engine power output. Shall be reported as 0 during engine breaking.. The unit of this type is kW"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::Kilowatt<u16>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v3::units::Kilowatt<u16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::Kilowatt<u16>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Current engine torque. Shall be reported as 0 during engine breaking.. The unit of this type is Nm"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Torque {
                pub value: crate::v3::units::NewtonMetre<u16>,
                pub timestamp: crate::v3::Timestamp,
            }
            impl Torque {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Current engine torque. Shall be reported as 0 during engine breaking.. The unit of this type is Nm"]
                pub fn value(&self) -> &crate::v3::units::NewtonMetre<u16> {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Current engine torque. Shall be reported as 0 during engine breaking.. The unit of this type is Nm"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v3::units::NewtonMetre<u16>,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v3::units::NewtonMetre<u16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v3::units::NewtonMetre<u16>,
                    timestamp: Option<crate::v3::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod dieselparticulatefilter {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Inlet temperature of Diesel Particulate Filter.. The unit of this type is celsius"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct InletTemperature {
                    pub value: crate::v3::units::Celsius<f32>,
                    pub timestamp: crate::v3::Timestamp,
                }
                impl InletTemperature {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Inlet temperature of Diesel Particulate Filter.. The unit of this type is celsius"]
                    pub fn value(&self) -> &crate::v3::units::Celsius<f32> {
                        &self.value
                    }
                    #[doc = r" Set the"]
                    #[doc = "Inlet temperature of Diesel Particulate Filter.. The unit of this type is celsius"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Celsius<f32>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v3::units::Celsius<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Celsius<f32>,
                        timestamp: Option<crate::v3::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Outlet temperature of Diesel Particulate Filter.. The unit of this type is celsius"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct OutletTemperature {
                    pub value: crate::v3::units::Celsius<f32>,
                    pub timestamp: crate::v3::Timestamp,
                }
                impl OutletTemperature {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Outlet temperature of Diesel Particulate Filter.. The unit of this type is celsius"]
                    pub fn value(&self) -> &crate::v3::units::Celsius<f32> {
                        &self.value
                    }
                    #[doc = r" Set the"]
                    #[doc = "Outlet temperature of Diesel Particulate Filter.. The unit of this type is celsius"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Celsius<f32>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v3::units::Celsius<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Celsius<f32>,
                        timestamp: Option<crate::v3::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Delta Pressure of Diesel Particulate Filter.. The unit of this type is Pa"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct DeltaPressure {
                    pub value: crate::v3::units::Pascal<f32>,
                    pub timestamp: crate::v3::Timestamp,
                }
                impl DeltaPressure {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Delta Pressure of Diesel Particulate Filter.. The unit of this type is Pa"]
                    pub fn value(&self) -> &crate::v3::units::Pascal<f32> {
                        &self.value
                    }
                    #[doc = r" Set the"]
                    #[doc = "Delta Pressure of Diesel Particulate Filter.. The unit of this type is Pa"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Pascal<f32>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v3::units::Pascal<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Pascal<f32>,
                        timestamp: Option<crate::v3::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod dieselexhaustfluid {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Capacity in liters of the Diesel Exhaust Fluid Tank.. The unit of this type is l"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Capacity {
                    pub value: crate::v3::units::Litre<f32>,
                }
                impl Capacity {
                    #[doc = r" Get the "]
                    #[doc = "Capacity in liters of the Diesel Exhaust Fluid Tank.. The unit of this type is l"]
                    pub fn value(&self) -> &crate::v3::units::Litre<f32> {
                        &self.value
                    }
                    #[doc = r" Set the"]
                    #[doc = "Capacity in liters of the Diesel Exhaust Fluid Tank.. The unit of this type is l"]
                    #[doc = r" Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(&mut self, value: crate::v3::units::Litre<f32>) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v3::units::Litre<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(value: crate::v3::units::Litre<f32>) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self { value })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Level of the Diesel Exhaust Fluid tank as percent of capacity. 0 = empty. 100 = full.. The unit of this type is percent"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Level {
                    pub value: crate::v3::units::Percent<u8>,
                    pub timestamp: crate::v3::Timestamp,
                }
                impl Level {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Level of the Diesel Exhaust Fluid tank as percent of capacity. 0 = empty. 100 = full.. The unit of this type is percent"]
                    pub fn value(&self) -> &crate::v3::units::Percent<u8> {
                        &self.value
                    }
                    #[doc = r" Set the"]
                    #[doc = "Level of the Diesel Exhaust Fluid tank as percent of capacity. 0 = empty. 100 = full.. The unit of this type is percent"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Percent<u8>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v3::units::Percent<u8>) -> bool {
                        v.0 <= 100u8 && v.0 >= 0u8
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Percent<u8>,
                        timestamp: Option<crate::v3::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Remaining range in meters of the Diesel Exhaust Fluid present in the vehicle.. The unit of this type is m"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Range {
                    pub value: crate::v3::units::Metre<u32>,
                    pub timestamp: crate::v3::Timestamp,
                }
                impl Range {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Remaining range in meters of the Diesel Exhaust Fluid present in the vehicle.. The unit of this type is m"]
                    pub fn value(&self) -> &crate::v3::units::Metre<u32> {
                        &self.value
                    }
                    #[doc = r" Set the"]
                    #[doc = "Remaining range in meters of the Diesel Exhaust Fluid present in the vehicle.. The unit of this type is m"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v3::units::Metre<u32>,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v3::units::Metre<u32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v3::units::Metre<u32>,
                        timestamp: Option<crate::v3::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Indicates if the Diesel Exhaust Fluid level is low. True if level is low. Definition of low is vehicle dependent.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct IsLevelLow {
                    pub value: bool,
                    pub timestamp: crate::v3::Timestamp,
                }
                impl IsLevelLow {
                    pub fn timestamp(&self) -> &crate::v3::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Indicates if the Diesel Exhaust Fluid level is low. True if level is low. Definition of low is vehicle dependent.. This type has no unit defined"]
                    pub fn value(&self) -> &bool {
                        &self.value
                    }
                    #[doc = r" Set the"]
                    #[doc = "Indicates if the Diesel Exhaust Fluid level is low. True if level is low. Definition of low is vehicle dependent.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v3::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v3::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
            }
        }
    }
    #[allow(non_snake_case)]
    pub mod currentlocation {
        use cdds_derive::Topic;
        use cyclonedds_rs::*;
        #[doc = "Timestamp from GNSS system for current location, formatted according to ISO 8601 with UTC time zone.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Timestamp {
            pub value: String,
            pub timestamp: crate::v3::Timestamp,
        }
        impl Timestamp {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Timestamp from GNSS system for current location, formatted according to ISO 8601 with UTC time zone.. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "Timestamp from GNSS system for current location, formatted according to ISO 8601 with UTC time zone.. This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String, maybe_timestamp: Option<crate::v3::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Current latitude of vehicle in WGS 84 geodetic coordinates, as measured at the position of GNSS receiver antenna.. The unit of this type is degrees"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Latitude {
            pub value: f64,
            pub timestamp: crate::v3::Timestamp,
        }
        impl Latitude {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Current latitude of vehicle in WGS 84 geodetic coordinates, as measured at the position of GNSS receiver antenna.. The unit of this type is degrees"]
            pub fn value(&self) -> &f64 {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "Current latitude of vehicle in WGS 84 geodetic coordinates, as measured at the position of GNSS receiver antenna.. The unit of this type is degrees"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: f64, maybe_timestamp: Option<crate::v3::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. Return true if the value is"]
            #[doc = r"within bounds."]
            pub fn bounds_check(v: &f64) -> bool {
                *v <= 90f64 && *v >= -90f64
            }
            #[doc = r" create a new instance"]
            pub fn new(value: f64, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Current longitude of vehicle in WGS 84 geodetic coordinates, as measured at the position of GNSS receiver antenna.. The unit of this type is degrees"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Longitude {
            pub value: f64,
            pub timestamp: crate::v3::Timestamp,
        }
        impl Longitude {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Current longitude of vehicle in WGS 84 geodetic coordinates, as measured at the position of GNSS receiver antenna.. The unit of this type is degrees"]
            pub fn value(&self) -> &f64 {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "Current longitude of vehicle in WGS 84 geodetic coordinates, as measured at the position of GNSS receiver antenna.. The unit of this type is degrees"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: f64, maybe_timestamp: Option<crate::v3::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. Return true if the value is"]
            #[doc = r"within bounds."]
            pub fn bounds_check(v: &f64) -> bool {
                *v <= 180f64 && *v >= -180f64
            }
            #[doc = r" create a new instance"]
            pub fn new(value: f64, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Current heading relative to geographic north. 0 = North, 90 = East, 180 = South, 270 = West.. The unit of this type is degrees"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Heading {
            pub value: f64,
            pub timestamp: crate::v3::Timestamp,
        }
        impl Heading {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Current heading relative to geographic north. 0 = North, 90 = East, 180 = South, 270 = West.. The unit of this type is degrees"]
            pub fn value(&self) -> &f64 {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "Current heading relative to geographic north. 0 = North, 90 = East, 180 = South, 270 = West.. The unit of this type is degrees"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: f64, maybe_timestamp: Option<crate::v3::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. Return true if the value is"]
            #[doc = r"within bounds."]
            pub fn bounds_check(v: &f64) -> bool {
                *v <= 360f64 && *v >= 0f64
            }
            #[doc = r" create a new instance"]
            pub fn new(value: f64, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Accuracy of the latitude and longitude coordinates.. The unit of this type is m"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct HorizontalAccuracy {
            pub value: crate::v3::units::Metre<f64>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl HorizontalAccuracy {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Accuracy of the latitude and longitude coordinates.. The unit of this type is m"]
            pub fn value(&self) -> &crate::v3::units::Metre<f64> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "Accuracy of the latitude and longitude coordinates.. The unit of this type is m"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Metre<f64>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Metre<f64>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Metre<f64>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Current altitude relative to WGS 84 reference ellipsoid, as measured at the position of GNSS receiver antenna.. The unit of this type is m"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Altitude {
            pub value: crate::v3::units::Metre<f64>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl Altitude {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Current altitude relative to WGS 84 reference ellipsoid, as measured at the position of GNSS receiver antenna.. The unit of this type is m"]
            pub fn value(&self) -> &crate::v3::units::Metre<f64> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "Current altitude relative to WGS 84 reference ellipsoid, as measured at the position of GNSS receiver antenna.. The unit of this type is m"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Metre<f64>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Metre<f64>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Metre<f64>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Accuracy of altitude.. The unit of this type is m"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct VerticalAccuracy {
            pub value: crate::v3::units::Metre<f64>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl VerticalAccuracy {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Accuracy of altitude.. The unit of this type is m"]
            pub fn value(&self) -> &crate::v3::units::Metre<f64> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "Accuracy of altitude.. The unit of this type is m"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::Metre<f64>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::Metre<f64>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::Metre<f64>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod gnssreceiver {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Fix status of GNSS receiver.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[repr(C)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct FixType {
                pub value: String,
                pub timestamp: crate::v3::Timestamp,
            }
            impl FixType {
                pub fn timestamp(&self) -> &crate::v3::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Fix status of GNSS receiver.. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.value
                }
                #[doc = r" Set the"]
                #[doc = "Fix status of GNSS receiver.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: String,
                    maybe_timestamp: Option<crate::v3::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.value = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod mountingposition {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Mounting position of GNSS receiver antenna relative to vehicle coordinate system. Axis definitions according to ISO 8855. Origin at center of (first) rear axle. Positive values = forward of rear axle. Negative values = backward of rear axle.. The unit of this type is mm"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct X {
                    pub value: crate::v3::units::Millimetre<i16>,
                }
                impl X {
                    #[doc = r" Get the "]
                    #[doc = "Mounting position of GNSS receiver antenna relative to vehicle coordinate system. Axis definitions according to ISO 8855. Origin at center of (first) rear axle. Positive values = forward of rear axle. Negative values = backward of rear axle.. The unit of this type is mm"]
                    pub fn value(&self) -> &crate::v3::units::Millimetre<i16> {
                        &self.value
                    }
                    #[doc = r" Set the"]
                    #[doc = "Mounting position of GNSS receiver antenna relative to vehicle coordinate system. Axis definitions according to ISO 8855. Origin at center of (first) rear axle. Positive values = forward of rear axle. Negative values = backward of rear axle.. The unit of this type is mm"]
                    #[doc = r" Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(&mut self, value: crate::v3::units::Millimetre<i16>) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v3::units::Millimetre<i16>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(value: crate::v3::units::Millimetre<i16>) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self { value })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Mounting position of GNSS receiver antenna relative to vehicle coordinate system. Axis definitions according to ISO 8855. Origin at center of (first) rear axle. Positive values = left of origin. Negative values = right of origin. Left/Right is as seen from driver perspective, i.e. by a person looking forward.. The unit of this type is mm"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Y {
                    pub value: crate::v3::units::Millimetre<i16>,
                }
                impl Y {
                    #[doc = r" Get the "]
                    #[doc = "Mounting position of GNSS receiver antenna relative to vehicle coordinate system. Axis definitions according to ISO 8855. Origin at center of (first) rear axle. Positive values = left of origin. Negative values = right of origin. Left/Right is as seen from driver perspective, i.e. by a person looking forward.. The unit of this type is mm"]
                    pub fn value(&self) -> &crate::v3::units::Millimetre<i16> {
                        &self.value
                    }
                    #[doc = r" Set the"]
                    #[doc = "Mounting position of GNSS receiver antenna relative to vehicle coordinate system. Axis definitions according to ISO 8855. Origin at center of (first) rear axle. Positive values = left of origin. Negative values = right of origin. Left/Right is as seen from driver perspective, i.e. by a person looking forward.. The unit of this type is mm"]
                    #[doc = r" Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(&mut self, value: crate::v3::units::Millimetre<i16>) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v3::units::Millimetre<i16>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(value: crate::v3::units::Millimetre<i16>) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self { value })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Mounting position of GNSS receiver on Z-axis. Axis definitions according to ISO 8855. Origin at center of (first) rear axle. Positive values = above center of rear axle. Negative values = below center of rear axle.. The unit of this type is mm"]
                #[allow(non_camel_case_types)]
                #[repr(C)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Z {
                    pub value: crate::v3::units::Millimetre<i16>,
                }
                impl Z {
                    #[doc = r" Get the "]
                    #[doc = "Mounting position of GNSS receiver on Z-axis. Axis definitions according to ISO 8855. Origin at center of (first) rear axle. Positive values = above center of rear axle. Negative values = below center of rear axle.. The unit of this type is mm"]
                    pub fn value(&self) -> &crate::v3::units::Millimetre<i16> {
                        &self.value
                    }
                    #[doc = r" Set the"]
                    #[doc = "Mounting position of GNSS receiver on Z-axis. Axis definitions according to ISO 8855. Origin at center of (first) rear axle. Positive values = above center of rear axle. Negative values = below center of rear axle.. The unit of this type is mm"]
                    #[doc = r" Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(&mut self, value: crate::v3::units::Millimetre<i16>) {
                        assert!(Self::bounds_check(&value));
                        self.value = value;
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v3::units::Millimetre<i16>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(value: crate::v3::units::Millimetre<i16>) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self { value })
                        } else {
                            None
                        }
                    }
                }
            }
        }
    }
    #[allow(non_snake_case)]
    pub mod trailer {
        use cdds_derive::Topic;
        use cyclonedds_rs::*;
        #[doc = "Signal indicating if trailer is connected or not.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct IsConnected {
            pub value: bool,
            pub timestamp: crate::v3::Timestamp,
        }
        impl IsConnected {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Signal indicating if trailer is connected or not.. This type has no unit defined"]
            pub fn value(&self) -> &bool {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "Signal indicating if trailer is connected or not.. This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v3::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &bool) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: bool, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
    }
    #[allow(non_snake_case)]
    pub mod angularvelocity {
        use cdds_derive::Topic;
        use cyclonedds_rs::*;
        #[doc = "Vehicle rotation rate along X (longitudinal).. The unit of this type is degrees/s"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Roll {
            pub value: f32,
            pub timestamp: crate::v3::Timestamp,
        }
        impl Roll {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Vehicle rotation rate along X (longitudinal).. The unit of this type is degrees/s"]
            pub fn value(&self) -> &f32 {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "Vehicle rotation rate along X (longitudinal).. The unit of this type is degrees/s"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: f32, maybe_timestamp: Option<crate::v3::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &f32) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: f32, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Vehicle rotation rate along Y (lateral).. The unit of this type is degrees/s"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Pitch {
            pub value: f32,
            pub timestamp: crate::v3::Timestamp,
        }
        impl Pitch {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Vehicle rotation rate along Y (lateral).. The unit of this type is degrees/s"]
            pub fn value(&self) -> &f32 {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "Vehicle rotation rate along Y (lateral).. The unit of this type is degrees/s"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: f32, maybe_timestamp: Option<crate::v3::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &f32) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: f32, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Vehicle rotation rate along Z (vertical).. The unit of this type is degrees/s"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Yaw {
            pub value: f32,
            pub timestamp: crate::v3::Timestamp,
        }
        impl Yaw {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Vehicle rotation rate along Z (vertical).. The unit of this type is degrees/s"]
            pub fn value(&self) -> &f32 {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "Vehicle rotation rate along Z (vertical).. The unit of this type is degrees/s"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: f32, maybe_timestamp: Option<crate::v3::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &f32) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: f32, timestamp: Option<crate::v3::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
    }
    #[allow(non_snake_case)]
    pub mod acceleration {
        use cdds_derive::Topic;
        use cyclonedds_rs::*;
        #[doc = "Vehicle acceleration in X (longitudinal acceleration).. The unit of this type is m/s^2"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Longitudinal {
            pub value: crate::v3::units::MeterPerSecondSq<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl Longitudinal {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Vehicle acceleration in X (longitudinal acceleration).. The unit of this type is m/s^2"]
            pub fn value(&self) -> &crate::v3::units::MeterPerSecondSq<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "Vehicle acceleration in X (longitudinal acceleration).. The unit of this type is m/s^2"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::MeterPerSecondSq<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::MeterPerSecondSq<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::MeterPerSecondSq<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Vehicle acceleration in Y (lateral acceleration).. The unit of this type is m/s^2"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Lateral {
            pub value: crate::v3::units::MeterPerSecondSq<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl Lateral {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Vehicle acceleration in Y (lateral acceleration).. The unit of this type is m/s^2"]
            pub fn value(&self) -> &crate::v3::units::MeterPerSecondSq<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "Vehicle acceleration in Y (lateral acceleration).. The unit of this type is m/s^2"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::MeterPerSecondSq<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::MeterPerSecondSq<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::MeterPerSecondSq<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Vehicle acceleration in Z (vertical acceleration).. The unit of this type is m/s^2"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Vertical {
            pub value: crate::v3::units::MeterPerSecondSq<f32>,
            pub timestamp: crate::v3::Timestamp,
        }
        impl Vertical {
            pub fn timestamp(&self) -> &crate::v3::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Vehicle acceleration in Z (vertical acceleration).. The unit of this type is m/s^2"]
            pub fn value(&self) -> &crate::v3::units::MeterPerSecondSq<f32> {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "Vehicle acceleration in Z (vertical acceleration).. The unit of this type is m/s^2"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v3::units::MeterPerSecondSq<f32>,
                maybe_timestamp: Option<crate::v3::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.value = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v3::units::MeterPerSecondSq<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v3::units::MeterPerSecondSq<f32>,
                timestamp: Option<crate::v3::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
    }
    #[allow(non_snake_case)]
    pub mod vehicleidentification {
        use cdds_derive::Topic;
        use cyclonedds_rs::*;
        #[doc = "17-character Vehicle Identification Number (VIN) as defined by ISO 3779.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct VIN {
            pub value: String,
        }
        impl VIN {
            #[doc = r" Get the "]
            #[doc = "17-character Vehicle Identification Number (VIN) as defined by ISO 3779.. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "17-character Vehicle Identification Number (VIN) as defined by ISO 3779.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.value = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { value })
                } else {
                    None
                }
            }
        }
        #[doc = "3-character World Manufacturer Identification (WMI) as defined by ISO 3780.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct WMI {
            pub value: String,
        }
        impl WMI {
            #[doc = r" Get the "]
            #[doc = "3-character World Manufacturer Identification (WMI) as defined by ISO 3780.. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "3-character World Manufacturer Identification (WMI) as defined by ISO 3780.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.value = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { value })
                } else {
                    None
                }
            }
        }
        #[doc = "Vehicle brand or manufacturer.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Brand {
            pub value: String,
        }
        impl Brand {
            #[doc = r" Get the "]
            #[doc = "Vehicle brand or manufacturer.. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "Vehicle brand or manufacturer.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.value = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { value })
                } else {
                    None
                }
            }
        }
        #[doc = "Vehicle model.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Model {
            pub value: String,
        }
        impl Model {
            #[doc = r" Get the "]
            #[doc = "Vehicle model.. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "Vehicle model.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.value = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { value })
                } else {
                    None
                }
            }
        }
        #[doc = "Model year of the vehicle.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Year {
            pub value: u16,
        }
        impl Year {
            #[doc = r" Get the "]
            #[doc = "Model year of the vehicle.. This type has no unit defined"]
            pub fn value(&self) -> &u16 {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "Model year of the vehicle.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u16) {
                assert!(Self::bounds_check(&value));
                self.value = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u16) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u16) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { value })
                } else {
                    None
                }
            }
        }
        #[doc = "The ACRISS Car Classification Code is a code used by many car rental companies.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct AcrissCode {
            pub value: String,
        }
        impl AcrissCode {
            #[doc = r" Get the "]
            #[doc = "The ACRISS Car Classification Code is a code used by many car rental companies.. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "The ACRISS Car Classification Code is a code used by many car rental companies.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.value = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { value })
                } else {
                    None
                }
            }
        }
        #[doc = "Indicates the design and body style of the vehicle (e.g. station wagon, hatchback, etc.).. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct BodyType {
            pub value: String,
        }
        impl BodyType {
            #[doc = r" Get the "]
            #[doc = "Indicates the design and body style of the vehicle (e.g. station wagon, hatchback, etc.).. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "Indicates the design and body style of the vehicle (e.g. station wagon, hatchback, etc.).. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.value = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { value })
                } else {
                    None
                }
            }
        }
        #[doc = "The date in ISO 8601 format of the first registration of the vehicle with the respective public authorities.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct DateVehicleFirstRegistered {
            pub value: String,
        }
        impl DateVehicleFirstRegistered {
            #[doc = r" Get the "]
            #[doc = "The date in ISO 8601 format of the first registration of the vehicle with the respective public authorities.. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "The date in ISO 8601 format of the first registration of the vehicle with the respective public authorities.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.value = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { value })
                } else {
                    None
                }
            }
        }
        #[doc = "Indicates that the vehicle meets the respective emission standard.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct MeetsEmissionStandard {
            pub value: String,
        }
        impl MeetsEmissionStandard {
            #[doc = r" Get the "]
            #[doc = "Indicates that the vehicle meets the respective emission standard.. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "Indicates that the vehicle meets the respective emission standard.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.value = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { value })
                } else {
                    None
                }
            }
        }
        #[doc = "The date in ISO 8601 format of production of the item, e.g. vehicle.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct ProductionDate {
            pub value: String,
        }
        impl ProductionDate {
            #[doc = r" Get the "]
            #[doc = "The date in ISO 8601 format of production of the item, e.g. vehicle.. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "The date in ISO 8601 format of production of the item, e.g. vehicle.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.value = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { value })
                } else {
                    None
                }
            }
        }
        #[doc = "The date in ISO 8601 format of the item e.g. vehicle was purchased by the current owner.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct PurchaseDate {
            pub value: String,
        }
        impl PurchaseDate {
            #[doc = r" Get the "]
            #[doc = "The date in ISO 8601 format of the item e.g. vehicle was purchased by the current owner.. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "The date in ISO 8601 format of the item e.g. vehicle was purchased by the current owner.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.value = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { value })
                } else {
                    None
                }
            }
        }
        #[doc = "The release date in ISO 8601 format of a vehicle model (often used to differentiate versions of the same make and model).. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct VehicleModelDate {
            pub value: String,
        }
        impl VehicleModelDate {
            #[doc = r" Get the "]
            #[doc = "The release date in ISO 8601 format of a vehicle model (often used to differentiate versions of the same make and model).. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "The release date in ISO 8601 format of a vehicle model (often used to differentiate versions of the same make and model).. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.value = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { value })
                } else {
                    None
                }
            }
        }
        #[doc = "A short text indicating the configuration of the vehicle, e.g. '5dr hatchback ST 2.5 MT 225 hp' or 'limited edition'.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct VehicleConfiguration {
            pub value: String,
        }
        impl VehicleConfiguration {
            #[doc = r" Get the "]
            #[doc = "A short text indicating the configuration of the vehicle, e.g. '5dr hatchback ST 2.5 MT 225 hp' or 'limited edition'.. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "A short text indicating the configuration of the vehicle, e.g. '5dr hatchback ST 2.5 MT 225 hp' or 'limited edition'.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.value = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { value })
                } else {
                    None
                }
            }
        }
        #[doc = "The number of passengers that can be seated in the vehicle, both in terms of the physical space available, and in terms of limitations set by law.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct VehicleSeatingCapacity {
            pub value: u16,
        }
        impl VehicleSeatingCapacity {
            #[doc = r" Get the "]
            #[doc = "The number of passengers that can be seated in the vehicle, both in terms of the physical space available, and in terms of limitations set by law.. This type has no unit defined"]
            pub fn value(&self) -> &u16 {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "The number of passengers that can be seated in the vehicle, both in terms of the physical space available, and in terms of limitations set by law.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u16) {
                assert!(Self::bounds_check(&value));
                self.value = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u16) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u16) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { value })
                } else {
                    None
                }
            }
        }
        #[doc = "Indicates whether the vehicle has been used for special purposes, like commercial rental, driving school.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct VehicleSpecialUsage {
            pub value: String,
        }
        impl VehicleSpecialUsage {
            #[doc = r" Get the "]
            #[doc = "Indicates whether the vehicle has been used for special purposes, like commercial rental, driving school.. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "Indicates whether the vehicle has been used for special purposes, like commercial rental, driving school.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.value = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { value })
                } else {
                    None
                }
            }
        }
        #[doc = "The color or color combination of the interior of the vehicle.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct VehicleInteriorColor {
            pub value: String,
        }
        impl VehicleInteriorColor {
            #[doc = r" Get the "]
            #[doc = "The color or color combination of the interior of the vehicle.. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "The color or color combination of the interior of the vehicle.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.value = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { value })
                } else {
                    None
                }
            }
        }
        #[doc = "The type or material of the interior of the vehicle (e.g. synthetic fabric, leather, wood, etc.).. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct VehicleInteriorType {
            pub value: String,
        }
        impl VehicleInteriorType {
            #[doc = r" Get the "]
            #[doc = "The type or material of the interior of the vehicle (e.g. synthetic fabric, leather, wood, etc.).. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "The type or material of the interior of the vehicle (e.g. synthetic fabric, leather, wood, etc.).. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.value = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { value })
                } else {
                    None
                }
            }
        }
        #[doc = "A textual description of known damages, both repaired and unrepaired.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct KnownVehicleDamages {
            pub value: String,
        }
        impl KnownVehicleDamages {
            #[doc = r" Get the "]
            #[doc = "A textual description of known damages, both repaired and unrepaired.. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "A textual description of known damages, both repaired and unrepaired.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.value = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { value })
                } else {
                    None
                }
            }
        }
    }
    #[allow(non_snake_case)]
    pub mod versionvss {
        use cdds_derive::Topic;
        use cyclonedds_rs::*;
        #[doc = "Supported Version of VSS - Major version.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Major {
            pub value: u32,
        }
        impl Major {
            #[doc = r" Get the "]
            #[doc = "Supported Version of VSS - Major version.. This type has no unit defined"]
            pub fn value(&self) -> &u32 {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "Supported Version of VSS - Major version.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u32) {
                assert!(Self::bounds_check(&value));
                self.value = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u32) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u32) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { value })
                } else {
                    None
                }
            }
        }
        #[doc = "Supported Version of VSS - Minor version.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Minor {
            pub value: u32,
        }
        impl Minor {
            #[doc = r" Get the "]
            #[doc = "Supported Version of VSS - Minor version.. This type has no unit defined"]
            pub fn value(&self) -> &u32 {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "Supported Version of VSS - Minor version.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u32) {
                assert!(Self::bounds_check(&value));
                self.value = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u32) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u32) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { value })
                } else {
                    None
                }
            }
        }
        #[doc = "Supported Version of VSS - Patch version.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Patch {
            pub value: u32,
        }
        impl Patch {
            #[doc = r" Get the "]
            #[doc = "Supported Version of VSS - Patch version.. This type has no unit defined"]
            pub fn value(&self) -> &u32 {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "Supported Version of VSS - Patch version.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u32) {
                assert!(Self::bounds_check(&value));
                self.value = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u32) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u32) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { value })
                } else {
                    None
                }
            }
        }
        #[doc = "Label to further describe the version.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[repr(C)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Label {
            pub value: String,
        }
        impl Label {
            #[doc = r" Get the "]
            #[doc = "Label to further describe the version.. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.value
            }
            #[doc = r" Set the"]
            #[doc = "Label to further describe the version.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.value = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { value })
                } else {
                    None
                }
            }
        }
    }
}
