#[allow(non_snake_case)]
pub mod vehicle {
    use cdds_derive::Topic;
    use cyclonedds_rs::*;
    #[doc = "State of the supply voltage of the control units (usually 12V).. This type has no unit defined"]
    #[allow(non_camel_case_types)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct LowVoltageSystemState {
        v: String,
        timestamp: crate::v2::Timestamp,
    }
    impl LowVoltageSystemState {
        pub fn timestamp(&self) -> &crate::v2::Timestamp {
            &self.timestamp
        }
        #[doc = r" Get the "]
        #[doc = "State of the supply voltage of the control units (usually 12V).. This type has no unit defined"]
        pub fn value(&self) -> &String {
            &self.v
        }
        #[doc = r" Set the"]
        #[doc = "State of the supply voltage of the control units (usually 12V).. This type has no unit defined"]
        #[doc = r" . Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(&mut self, value: String, maybe_timestamp: Option<crate::v2::Timestamp>) {
            assert!(Self::bounds_check(&value));
            self.v = value;
            if let Some(ts) = maybe_timestamp {
                self.timestamp = ts;
            }
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &String) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(value: String, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self {
                    v: value,
                    timestamp: timestamp.unwrap_or_default(),
                })
            } else {
                None
            }
        }
    }
    #[doc = "Indicates whether the vehicle ignition is on or off.. This type has no unit defined"]
    #[allow(non_camel_case_types)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct IgnitionOn {
        v: bool,
        timestamp: crate::v2::Timestamp,
    }
    impl IgnitionOn {
        pub fn timestamp(&self) -> &crate::v2::Timestamp {
            &self.timestamp
        }
        #[doc = r" Get the "]
        #[doc = "Indicates whether the vehicle ignition is on or off.. This type has no unit defined"]
        pub fn value(&self) -> &bool {
            &self.v
        }
        #[doc = r" Set the"]
        #[doc = "Indicates whether the vehicle ignition is on or off.. This type has no unit defined"]
        #[doc = r" . Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
            assert!(Self::bounds_check(&value));
            self.v = value;
            if let Some(ts) = maybe_timestamp {
                self.timestamp = ts;
            }
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &bool) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self {
                    v: value,
                    timestamp: timestamp.unwrap_or_default(),
                })
            } else {
                None
            }
        }
    }
    #[doc = "Accumulated ignition on time in seconds.. The unit of this type is s"]
    #[allow(non_camel_case_types)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct IgnitionOnTime {
        v: crate::v2::units::Second<u32>,
        timestamp: crate::v2::Timestamp,
    }
    impl IgnitionOnTime {
        pub fn timestamp(&self) -> &crate::v2::Timestamp {
            &self.timestamp
        }
        #[doc = r" Get the "]
        #[doc = "Accumulated ignition on time in seconds.. The unit of this type is s"]
        pub fn value(&self) -> &crate::v2::units::Second<u32> {
            &self.v
        }
        #[doc = r" Set the"]
        #[doc = "Accumulated ignition on time in seconds.. The unit of this type is s"]
        #[doc = r" . Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(
            &mut self,
            value: crate::v2::units::Second<u32>,
            maybe_timestamp: Option<crate::v2::Timestamp>,
        ) {
            assert!(Self::bounds_check(&value));
            self.v = value;
            if let Some(ts) = maybe_timestamp {
                self.timestamp = ts;
            }
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &crate::v2::units::Second<u32>) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(
            value: crate::v2::units::Second<u32>,
            timestamp: Option<crate::v2::Timestamp>,
        ) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self {
                    v: value,
                    timestamp: timestamp.unwrap_or_default(),
                })
            } else {
                None
            }
        }
    }
    #[doc = "Accumulated ignition off time in seconds.. The unit of this type is s"]
    #[allow(non_camel_case_types)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct IgnitionOffTime {
        v: crate::v2::units::Second<u32>,
        timestamp: crate::v2::Timestamp,
    }
    impl IgnitionOffTime {
        pub fn timestamp(&self) -> &crate::v2::Timestamp {
            &self.timestamp
        }
        #[doc = r" Get the "]
        #[doc = "Accumulated ignition off time in seconds.. The unit of this type is s"]
        pub fn value(&self) -> &crate::v2::units::Second<u32> {
            &self.v
        }
        #[doc = r" Set the"]
        #[doc = "Accumulated ignition off time in seconds.. The unit of this type is s"]
        #[doc = r" . Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(
            &mut self,
            value: crate::v2::units::Second<u32>,
            maybe_timestamp: Option<crate::v2::Timestamp>,
        ) {
            assert!(Self::bounds_check(&value));
            self.v = value;
            if let Some(ts) = maybe_timestamp {
                self.timestamp = ts;
            }
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &crate::v2::units::Second<u32>) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(
            value: crate::v2::units::Second<u32>,
            timestamp: Option<crate::v2::Timestamp>,
        ) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self {
                    v: value,
                    timestamp: timestamp.unwrap_or_default(),
                })
            } else {
                None
            }
        }
    }
    #[doc = "Accumulated drive time in seconds.. The unit of this type is s"]
    #[allow(non_camel_case_types)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct DriveTime {
        v: crate::v2::units::Second<u32>,
        timestamp: crate::v2::Timestamp,
    }
    impl DriveTime {
        pub fn timestamp(&self) -> &crate::v2::Timestamp {
            &self.timestamp
        }
        #[doc = r" Get the "]
        #[doc = "Accumulated drive time in seconds.. The unit of this type is s"]
        pub fn value(&self) -> &crate::v2::units::Second<u32> {
            &self.v
        }
        #[doc = r" Set the"]
        #[doc = "Accumulated drive time in seconds.. The unit of this type is s"]
        #[doc = r" . Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(
            &mut self,
            value: crate::v2::units::Second<u32>,
            maybe_timestamp: Option<crate::v2::Timestamp>,
        ) {
            assert!(Self::bounds_check(&value));
            self.v = value;
            if let Some(ts) = maybe_timestamp {
                self.timestamp = ts;
            }
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &crate::v2::units::Second<u32>) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(
            value: crate::v2::units::Second<u32>,
            timestamp: Option<crate::v2::Timestamp>,
        ) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self {
                    v: value,
                    timestamp: timestamp.unwrap_or_default(),
                })
            } else {
                None
            }
        }
    }
    #[doc = "Accumulated idle time in seconds.. The unit of this type is s"]
    #[allow(non_camel_case_types)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct IdleTime {
        v: crate::v2::units::Second<u32>,
        timestamp: crate::v2::Timestamp,
    }
    impl IdleTime {
        pub fn timestamp(&self) -> &crate::v2::Timestamp {
            &self.timestamp
        }
        #[doc = r" Get the "]
        #[doc = "Accumulated idle time in seconds.. The unit of this type is s"]
        pub fn value(&self) -> &crate::v2::units::Second<u32> {
            &self.v
        }
        #[doc = r" Set the"]
        #[doc = "Accumulated idle time in seconds.. The unit of this type is s"]
        #[doc = r" . Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(
            &mut self,
            value: crate::v2::units::Second<u32>,
            maybe_timestamp: Option<crate::v2::Timestamp>,
        ) {
            assert!(Self::bounds_check(&value));
            self.v = value;
            if let Some(ts) = maybe_timestamp {
                self.timestamp = ts;
            }
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &crate::v2::units::Second<u32>) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(
            value: crate::v2::units::Second<u32>,
            timestamp: Option<crate::v2::Timestamp>,
        ) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self {
                    v: value,
                    timestamp: timestamp.unwrap_or_default(),
                })
            } else {
                None
            }
        }
    }
    #[doc = "Vehicle speed. The unit of this type is km/h"]
    #[allow(non_camel_case_types)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct Speed {
        v: crate::v2::units::KilometrePerHour<f32>,
        timestamp: crate::v2::Timestamp,
    }
    impl Speed {
        pub fn timestamp(&self) -> &crate::v2::Timestamp {
            &self.timestamp
        }
        #[doc = r" Get the "]
        #[doc = "Vehicle speed. The unit of this type is km/h"]
        pub fn value(&self) -> &crate::v2::units::KilometrePerHour<f32> {
            &self.v
        }
        #[doc = r" Set the"]
        #[doc = "Vehicle speed. The unit of this type is km/h"]
        #[doc = r" . Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(
            &mut self,
            value: crate::v2::units::KilometrePerHour<f32>,
            maybe_timestamp: Option<crate::v2::Timestamp>,
        ) {
            assert!(Self::bounds_check(&value));
            self.v = value;
            if let Some(ts) = maybe_timestamp {
                self.timestamp = ts;
            }
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &crate::v2::units::KilometrePerHour<f32>) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(
            value: crate::v2::units::KilometrePerHour<f32>,
            timestamp: Option<crate::v2::Timestamp>,
        ) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self {
                    v: value,
                    timestamp: timestamp.unwrap_or_default(),
                })
            } else {
                None
            }
        }
    }
    #[doc = "Odometer reading, total distance travelled during the lifetime of the vehicle.. The unit of this type is km"]
    #[allow(non_camel_case_types)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct TravelledDistance {
        v: crate::v2::units::Kilometre<f32>,
        timestamp: crate::v2::Timestamp,
    }
    impl TravelledDistance {
        pub fn timestamp(&self) -> &crate::v2::Timestamp {
            &self.timestamp
        }
        #[doc = r" Get the "]
        #[doc = "Odometer reading, total distance travelled during the lifetime of the vehicle.. The unit of this type is km"]
        pub fn value(&self) -> &crate::v2::units::Kilometre<f32> {
            &self.v
        }
        #[doc = r" Set the"]
        #[doc = "Odometer reading, total distance travelled during the lifetime of the vehicle.. The unit of this type is km"]
        #[doc = r" . Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(
            &mut self,
            value: crate::v2::units::Kilometre<f32>,
            maybe_timestamp: Option<crate::v2::Timestamp>,
        ) {
            assert!(Self::bounds_check(&value));
            self.v = value;
            if let Some(ts) = maybe_timestamp {
                self.timestamp = ts;
            }
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &crate::v2::units::Kilometre<f32>) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(
            value: crate::v2::units::Kilometre<f32>,
            timestamp: Option<crate::v2::Timestamp>,
        ) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self {
                    v: value,
                    timestamp: timestamp.unwrap_or_default(),
                })
            } else {
                None
            }
        }
    }
    #[doc = "Current trip meter reading. The unit of this type is km"]
    #[allow(non_camel_case_types)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct TripMeterReading {
        v: crate::v2::units::Kilometre<f32>,
        timestamp: crate::v2::Timestamp,
    }
    impl TripMeterReading {
        pub fn timestamp(&self) -> &crate::v2::Timestamp {
            &self.timestamp
        }
        #[doc = r" Get the "]
        #[doc = "Current trip meter reading. The unit of this type is km"]
        pub fn value(&self) -> &crate::v2::units::Kilometre<f32> {
            &self.v
        }
        #[doc = r" Set the"]
        #[doc = "Current trip meter reading. The unit of this type is km"]
        #[doc = r" . Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(
            &mut self,
            value: crate::v2::units::Kilometre<f32>,
            maybe_timestamp: Option<crate::v2::Timestamp>,
        ) {
            assert!(Self::bounds_check(&value));
            self.v = value;
            if let Some(ts) = maybe_timestamp {
                self.timestamp = ts;
            }
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &crate::v2::units::Kilometre<f32>) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(
            value: crate::v2::units::Kilometre<f32>,
            timestamp: Option<crate::v2::Timestamp>,
        ) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self {
                    v: value,
                    timestamp: timestamp.unwrap_or_default(),
                })
            } else {
                None
            }
        }
    }
    #[doc = "Ambient air temperature outside the vehicle.. The unit of this type is celsius"]
    #[allow(non_camel_case_types)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct AmbientAirTemperature {
        v: crate::v2::units::Celsius<f32>,
        timestamp: crate::v2::Timestamp,
    }
    impl AmbientAirTemperature {
        pub fn timestamp(&self) -> &crate::v2::Timestamp {
            &self.timestamp
        }
        #[doc = r" Get the "]
        #[doc = "Ambient air temperature outside the vehicle.. The unit of this type is celsius"]
        pub fn value(&self) -> &crate::v2::units::Celsius<f32> {
            &self.v
        }
        #[doc = r" Set the"]
        #[doc = "Ambient air temperature outside the vehicle.. The unit of this type is celsius"]
        #[doc = r" . Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(
            &mut self,
            value: crate::v2::units::Celsius<f32>,
            maybe_timestamp: Option<crate::v2::Timestamp>,
        ) {
            assert!(Self::bounds_check(&value));
            self.v = value;
            if let Some(ts) = maybe_timestamp {
                self.timestamp = ts;
            }
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &crate::v2::units::Celsius<f32>) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(
            value: crate::v2::units::Celsius<f32>,
            timestamp: Option<crate::v2::Timestamp>,
        ) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self {
                    v: value,
                    timestamp: timestamp.unwrap_or_default(),
                })
            } else {
                None
            }
        }
    }
    #[doc = "Indicates whether the vehicle is stationary or moving. This type has no unit defined"]
    #[allow(non_camel_case_types)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct IsMoving {
        v: bool,
        timestamp: crate::v2::Timestamp,
    }
    impl IsMoving {
        pub fn timestamp(&self) -> &crate::v2::Timestamp {
            &self.timestamp
        }
        #[doc = r" Get the "]
        #[doc = "Indicates whether the vehicle is stationary or moving. This type has no unit defined"]
        pub fn value(&self) -> &bool {
            &self.v
        }
        #[doc = r" Set the"]
        #[doc = "Indicates whether the vehicle is stationary or moving. This type has no unit defined"]
        #[doc = r" . Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
            assert!(Self::bounds_check(&value));
            self.v = value;
            if let Some(ts) = maybe_timestamp {
                self.timestamp = ts;
            }
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &bool) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self {
                    v: value,
                    timestamp: timestamp.unwrap_or_default(),
                })
            } else {
                None
            }
        }
    }
    #[doc = "Average speed for the current trip. The unit of this type is km/h"]
    #[allow(non_camel_case_types)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct AverageSpeed {
        v: crate::v2::units::KilometrePerHour<f32>,
        timestamp: crate::v2::Timestamp,
    }
    impl AverageSpeed {
        pub fn timestamp(&self) -> &crate::v2::Timestamp {
            &self.timestamp
        }
        #[doc = r" Get the "]
        #[doc = "Average speed for the current trip. The unit of this type is km/h"]
        pub fn value(&self) -> &crate::v2::units::KilometrePerHour<f32> {
            &self.v
        }
        #[doc = r" Set the"]
        #[doc = "Average speed for the current trip. The unit of this type is km/h"]
        #[doc = r" . Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(
            &mut self,
            value: crate::v2::units::KilometrePerHour<f32>,
            maybe_timestamp: Option<crate::v2::Timestamp>,
        ) {
            assert!(Self::bounds_check(&value));
            self.v = value;
            if let Some(ts) = maybe_timestamp {
                self.timestamp = ts;
            }
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &crate::v2::units::KilometrePerHour<f32>) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(
            value: crate::v2::units::KilometrePerHour<f32>,
            timestamp: Option<crate::v2::Timestamp>,
        ) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self {
                    v: value,
                    timestamp: timestamp.unwrap_or_default(),
                })
            } else {
                None
            }
        }
    }
    #[doc = "The permitted total weight of cargo and installations (e.g. a roof rack) on top of the vehicle.. The unit of this type is kg"]
    #[allow(non_camel_case_types)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct RoofLoad {
        v: crate::v2::units::Kilogram<i16>,
    }
    impl RoofLoad {
        #[doc = r" Get the "]
        #[doc = "The permitted total weight of cargo and installations (e.g. a roof rack) on top of the vehicle.. The unit of this type is kg"]
        pub fn value(&self) -> &crate::v2::units::Kilogram<i16> {
            &self.v
        }
        #[doc = r" Set the"]
        #[doc = "The permitted total weight of cargo and installations (e.g. a roof rack) on top of the vehicle.. The unit of this type is kg"]
        #[doc = r" Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(&mut self, value: crate::v2::units::Kilogram<i16>) {
            assert!(Self::bounds_check(&value));
            self.v = value;
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &crate::v2::units::Kilogram<i16>) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(value: crate::v2::units::Kilogram<i16>) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self { v: value })
            } else {
                None
            }
        }
    }
    #[doc = "The time needed to accelerate the vehicle from a given start velocity to a given target velocity.. The unit of this type is s"]
    #[allow(non_camel_case_types)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct accelerationTime {
        v: crate::v2::units::Second<i16>,
    }
    impl accelerationTime {
        #[doc = r" Get the "]
        #[doc = "The time needed to accelerate the vehicle from a given start velocity to a given target velocity.. The unit of this type is s"]
        pub fn value(&self) -> &crate::v2::units::Second<i16> {
            &self.v
        }
        #[doc = r" Set the"]
        #[doc = "The time needed to accelerate the vehicle from a given start velocity to a given target velocity.. The unit of this type is s"]
        #[doc = r" Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(&mut self, value: crate::v2::units::Second<i16>) {
            assert!(Self::bounds_check(&value));
            self.v = value;
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &crate::v2::units::Second<i16>) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(value: crate::v2::units::Second<i16>) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self { v: value })
            } else {
                None
            }
        }
    }
    #[doc = "The available volume for cargo or luggage. For automobiles, this is usually the trunk volume.. The unit of this type is l"]
    #[allow(non_camel_case_types)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct cargoVolume {
        v: crate::v2::units::Litre<f32>,
    }
    impl cargoVolume {
        #[doc = r" Get the "]
        #[doc = "The available volume for cargo or luggage. For automobiles, this is usually the trunk volume.. The unit of this type is l"]
        pub fn value(&self) -> &crate::v2::units::Litre<f32> {
            &self.v
        }
        #[doc = r" Set the"]
        #[doc = "The available volume for cargo or luggage. For automobiles, this is usually the trunk volume.. The unit of this type is l"]
        #[doc = r" Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(&mut self, value: crate::v2::units::Litre<f32>) {
            assert!(Self::bounds_check(&value));
            self.v = value;
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. Return true if the value is"]
        #[doc = r"within bounds."]
        pub fn bounds_check(v: &crate::v2::units::Litre<f32>) -> bool {
            true && v.0 >= 0f32
        }
        #[doc = r" create a new instance"]
        pub fn new(value: crate::v2::units::Litre<f32>) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self { v: value })
            } else {
                None
            }
        }
    }
    #[doc = "The CO2 emissions.. The unit of this type is g/km"]
    #[allow(non_camel_case_types)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct emissionsCO2 {
        v: i16,
    }
    impl emissionsCO2 {
        #[doc = r" Get the "]
        #[doc = "The CO2 emissions.. The unit of this type is g/km"]
        pub fn value(&self) -> &i16 {
            &self.v
        }
        #[doc = r" Set the"]
        #[doc = "The CO2 emissions.. The unit of this type is g/km"]
        #[doc = r" Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(&mut self, value: i16) {
            assert!(Self::bounds_check(&value));
            self.v = value;
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &i16) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(value: i16) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self { v: value })
            } else {
                None
            }
        }
    }
    #[doc = "Current overall Vehicle weight. Including passengers, cargo and other load inside the car.. The unit of this type is kg"]
    #[allow(non_camel_case_types)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct CurrentOverallWeight {
        v: crate::v2::units::Kilogram<u16>,
        timestamp: crate::v2::Timestamp,
    }
    impl CurrentOverallWeight {
        pub fn timestamp(&self) -> &crate::v2::Timestamp {
            &self.timestamp
        }
        #[doc = r" Get the "]
        #[doc = "Current overall Vehicle weight. Including passengers, cargo and other load inside the car.. The unit of this type is kg"]
        pub fn value(&self) -> &crate::v2::units::Kilogram<u16> {
            &self.v
        }
        #[doc = r" Set the"]
        #[doc = "Current overall Vehicle weight. Including passengers, cargo and other load inside the car.. The unit of this type is kg"]
        #[doc = r" . Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(
            &mut self,
            value: crate::v2::units::Kilogram<u16>,
            maybe_timestamp: Option<crate::v2::Timestamp>,
        ) {
            assert!(Self::bounds_check(&value));
            self.v = value;
            if let Some(ts) = maybe_timestamp {
                self.timestamp = ts;
            }
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &crate::v2::units::Kilogram<u16>) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(
            value: crate::v2::units::Kilogram<u16>,
            timestamp: Option<crate::v2::Timestamp>,
        ) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self {
                    v: value,
                    timestamp: timestamp.unwrap_or_default(),
                })
            } else {
                None
            }
        }
    }
    #[doc = "Vehicle curb weight, including all liquids and full tank of fuel, but no cargo or passengers.. The unit of this type is kg"]
    #[allow(non_camel_case_types)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct CurbWeight {
        v: crate::v2::units::Kilogram<u16>,
    }
    impl CurbWeight {
        #[doc = r" Get the "]
        #[doc = "Vehicle curb weight, including all liquids and full tank of fuel, but no cargo or passengers.. The unit of this type is kg"]
        pub fn value(&self) -> &crate::v2::units::Kilogram<u16> {
            &self.v
        }
        #[doc = r" Set the"]
        #[doc = "Vehicle curb weight, including all liquids and full tank of fuel, but no cargo or passengers.. The unit of this type is kg"]
        #[doc = r" Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(&mut self, value: crate::v2::units::Kilogram<u16>) {
            assert!(Self::bounds_check(&value));
            self.v = value;
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &crate::v2::units::Kilogram<u16>) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(value: crate::v2::units::Kilogram<u16>) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self { v: value })
            } else {
                None
            }
        }
    }
    #[doc = "Curb weight of vehicle, including all liquids and full tank of fuel and full load of cargo and passengers.. The unit of this type is kg"]
    #[allow(non_camel_case_types)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct GrossWeight {
        v: crate::v2::units::Kilogram<u16>,
    }
    impl GrossWeight {
        #[doc = r" Get the "]
        #[doc = "Curb weight of vehicle, including all liquids and full tank of fuel and full load of cargo and passengers.. The unit of this type is kg"]
        pub fn value(&self) -> &crate::v2::units::Kilogram<u16> {
            &self.v
        }
        #[doc = r" Set the"]
        #[doc = "Curb weight of vehicle, including all liquids and full tank of fuel and full load of cargo and passengers.. The unit of this type is kg"]
        #[doc = r" Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(&mut self, value: crate::v2::units::Kilogram<u16>) {
            assert!(Self::bounds_check(&value));
            self.v = value;
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &crate::v2::units::Kilogram<u16>) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(value: crate::v2::units::Kilogram<u16>) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self { v: value })
            } else {
                None
            }
        }
    }
    #[doc = "Maximum weight of trailer.. The unit of this type is kg"]
    #[allow(non_camel_case_types)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct MaxTowWeight {
        v: crate::v2::units::Kilogram<u16>,
    }
    impl MaxTowWeight {
        #[doc = r" Get the "]
        #[doc = "Maximum weight of trailer.. The unit of this type is kg"]
        pub fn value(&self) -> &crate::v2::units::Kilogram<u16> {
            &self.v
        }
        #[doc = r" Set the"]
        #[doc = "Maximum weight of trailer.. The unit of this type is kg"]
        #[doc = r" Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(&mut self, value: crate::v2::units::Kilogram<u16>) {
            assert!(Self::bounds_check(&value));
            self.v = value;
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &crate::v2::units::Kilogram<u16>) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(value: crate::v2::units::Kilogram<u16>) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self { v: value })
            } else {
                None
            }
        }
    }
    #[doc = "Maximum vertical weight on the tow ball of a trailer.. The unit of this type is kg"]
    #[allow(non_camel_case_types)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct MaxTowBallWeight {
        v: crate::v2::units::Kilogram<u16>,
    }
    impl MaxTowBallWeight {
        #[doc = r" Get the "]
        #[doc = "Maximum vertical weight on the tow ball of a trailer.. The unit of this type is kg"]
        pub fn value(&self) -> &crate::v2::units::Kilogram<u16> {
            &self.v
        }
        #[doc = r" Set the"]
        #[doc = "Maximum vertical weight on the tow ball of a trailer.. The unit of this type is kg"]
        #[doc = r" Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(&mut self, value: crate::v2::units::Kilogram<u16>) {
            assert!(Self::bounds_check(&value));
            self.v = value;
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &crate::v2::units::Kilogram<u16>) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(value: crate::v2::units::Kilogram<u16>) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self { v: value })
            } else {
                None
            }
        }
    }
    #[doc = "Overall vehicle length.. The unit of this type is mm"]
    #[allow(non_camel_case_types)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct Length {
        v: crate::v2::units::Millimetre<u16>,
    }
    impl Length {
        #[doc = r" Get the "]
        #[doc = "Overall vehicle length.. The unit of this type is mm"]
        pub fn value(&self) -> &crate::v2::units::Millimetre<u16> {
            &self.v
        }
        #[doc = r" Set the"]
        #[doc = "Overall vehicle length.. The unit of this type is mm"]
        #[doc = r" Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(&mut self, value: crate::v2::units::Millimetre<u16>) {
            assert!(Self::bounds_check(&value));
            self.v = value;
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &crate::v2::units::Millimetre<u16>) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(value: crate::v2::units::Millimetre<u16>) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self { v: value })
            } else {
                None
            }
        }
    }
    #[doc = "Overall vehicle height.. The unit of this type is mm"]
    #[allow(non_camel_case_types)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct Height {
        v: crate::v2::units::Millimetre<u16>,
    }
    impl Height {
        #[doc = r" Get the "]
        #[doc = "Overall vehicle height.. The unit of this type is mm"]
        pub fn value(&self) -> &crate::v2::units::Millimetre<u16> {
            &self.v
        }
        #[doc = r" Set the"]
        #[doc = "Overall vehicle height.. The unit of this type is mm"]
        #[doc = r" Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(&mut self, value: crate::v2::units::Millimetre<u16>) {
            assert!(Self::bounds_check(&value));
            self.v = value;
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &crate::v2::units::Millimetre<u16>) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(value: crate::v2::units::Millimetre<u16>) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self { v: value })
            } else {
                None
            }
        }
    }
    #[doc = "Overall vehicle width.. The unit of this type is mm"]
    #[allow(non_camel_case_types)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct Width {
        v: crate::v2::units::Millimetre<u16>,
    }
    impl Width {
        #[doc = r" Get the "]
        #[doc = "Overall vehicle width.. The unit of this type is mm"]
        pub fn value(&self) -> &crate::v2::units::Millimetre<u16> {
            &self.v
        }
        #[doc = r" Set the"]
        #[doc = "Overall vehicle width.. The unit of this type is mm"]
        #[doc = r" Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(&mut self, value: crate::v2::units::Millimetre<u16>) {
            assert!(Self::bounds_check(&value));
            self.v = value;
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &crate::v2::units::Millimetre<u16>) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(value: crate::v2::units::Millimetre<u16>) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self { v: value })
            } else {
                None
            }
        }
    }
    #[allow(non_snake_case)]
    pub mod service {
        use cdds_derive::Topic;
        use cyclonedds_rs::*;
        #[doc = "Indicates if vehicle needs service (of any kind). True = Service needed now or in the near future. False = No known need for service.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct ServiceDue {
            v: bool,
            timestamp: crate::v2::Timestamp,
        }
        impl ServiceDue {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Indicates if vehicle needs service (of any kind). True = Service needed now or in the near future. False = No known need for service.. This type has no unit defined"]
            pub fn value(&self) -> &bool {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Indicates if vehicle needs service (of any kind). True = Service needed now or in the near future. False = No known need for service.. This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &bool) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Remaining distance to service (of any kind). Negative values indicate service overdue.. The unit of this type is km"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct DistanceToService {
            v: crate::v2::units::Kilometre<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl DistanceToService {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Remaining distance to service (of any kind). Negative values indicate service overdue.. The unit of this type is km"]
            pub fn value(&self) -> &crate::v2::units::Kilometre<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Remaining distance to service (of any kind). Negative values indicate service overdue.. The unit of this type is km"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Kilometre<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Kilometre<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Kilometre<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Remaining time to service (of any kind). Negative values indicate service overdue.. The unit of this type is s"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct TimeToService {
            v: crate::v2::units::Second<i32>,
            timestamp: crate::v2::Timestamp,
        }
        impl TimeToService {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Remaining time to service (of any kind). Negative values indicate service overdue.. The unit of this type is s"]
            pub fn value(&self) -> &crate::v2::units::Second<i32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Remaining time to service (of any kind). Negative values indicate service overdue.. The unit of this type is s"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Second<i32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Second<i32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Second<i32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
    }
    #[allow(non_snake_case)]
    pub mod driver {
        use cdds_derive::Topic;
        use cyclonedds_rs::*;
        #[doc = "Distraction level of the driver will be the level how much the driver is distracted, by multiple factors. E.g. Driving situation, acustical or optical signales inside the cockpit, phone calls. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct DistractionLevel {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl DistractionLevel {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Distraction level of the driver will be the level how much the driver is distracted, by multiple factors. E.g. Driving situation, acustical or optical signales inside the cockpit, phone calls. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Distraction level of the driver will be the level how much the driver is distracted, by multiple factors. E.g. Driving situation, acustical or optical signales inside the cockpit, phone calls. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Has driver the eyes on road or not?. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct EyesOnRoad {
            v: bool,
            timestamp: crate::v2::Timestamp,
        }
        impl EyesOnRoad {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Has driver the eyes on road or not?. This type has no unit defined"]
            pub fn value(&self) -> &bool {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Has driver the eyes on road or not?. This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &bool) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Probability of attentiveness of the driver.. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct AttentiveProbability {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl AttentiveProbability {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Probability of attentiveness of the driver.. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Probability of attentiveness of the driver.. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Fatigueness level of driver. Evaluated by multiple factors like trip time, behaviour of steering, eye status.. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct FatigueLevel {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl FatigueLevel {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Fatigueness level of driver. Evaluated by multiple factors like trip time, behaviour of steering, eye status.. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Fatigueness level of driver. Evaluated by multiple factors like trip time, behaviour of steering, eye status.. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Heart rate of the driver.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct HeartRate {
            v: u16,
            timestamp: crate::v2::Timestamp,
        }
        impl HeartRate {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Heart rate of the driver.. This type has no unit defined"]
            pub fn value(&self) -> &u16 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Heart rate of the driver.. This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u16, maybe_timestamp: Option<crate::v2::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u16) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u16, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod identifier {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Subject for the authentification of the occupant. E.g. UserID 7331677. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Subject {
                v: String,
                timestamp: crate::v2::Timestamp,
            }
            impl Subject {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Subject for the authentification of the occupant. E.g. UserID 7331677. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Subject for the authentification of the occupant. E.g. UserID 7331677. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: String,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Unique Issuer for the authentification of the occupant. E.g. https://accounts.funcorp.com. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Issuer {
                v: String,
                timestamp: crate::v2::Timestamp,
            }
            impl Issuer {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Unique Issuer for the authentification of the occupant. E.g. https://accounts.funcorp.com. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Unique Issuer for the authentification of the occupant. E.g. https://accounts.funcorp.com. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: String,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
    }
    #[allow(non_snake_case)]
    pub mod obd {
        use cdds_derive::Topic;
        use cyclonedds_rs::*;
        #[doc = "PID 00 - Bit array of the supported pids 01 to 20. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct PidsA {
            v: u32,
            timestamp: crate::v2::Timestamp,
        }
        impl PidsA {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 00 - Bit array of the supported pids 01 to 20. This type has no unit defined"]
            pub fn value(&self) -> &u32 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 00 - Bit array of the supported pids 01 to 20. This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u32, maybe_timestamp: Option<crate::v2::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u32) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u32, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "List of currently active DTCs formatted according OBD II (SAE-J2012DA_201812) standard ([P|C|B|U]XXXXX ). This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct DTCList {
            v: Vec<String>,
            timestamp: crate::v2::Timestamp,
        }
        impl DTCList {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "List of currently active DTCs formatted according OBD II (SAE-J2012DA_201812) standard ([P|C|B|U]XXXXX ). This type has no unit defined"]
            pub fn value(&self) -> &Vec<String> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "List of currently active DTCs formatted according OBD II (SAE-J2012DA_201812) standard ([P|C|B|U]XXXXX ). This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: Vec<String>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &Vec<String>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: Vec<String>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 02 - DTC that triggered the freeze frame. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct FreezeDTC {
            v: String,
            timestamp: crate::v2::Timestamp,
        }
        impl FreezeDTC {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 02 - DTC that triggered the freeze frame. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 02 - DTC that triggered the freeze frame. This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String, maybe_timestamp: Option<crate::v2::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 03 - Fuel status. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct FuelStatus {
            v: String,
            timestamp: crate::v2::Timestamp,
        }
        impl FuelStatus {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 03 - Fuel status. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 03 - Fuel status. This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String, maybe_timestamp: Option<crate::v2::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 04 - Engine load in percent - 0 = no load, 100 = full load. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct EngineLoad {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl EngineLoad {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 04 - Engine load in percent - 0 = no load, 100 = full load. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 04 - Engine load in percent - 0 = no load, 100 = full load. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 05 - Coolant temperature. The unit of this type is celsius"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct CoolantTemperature {
            v: crate::v2::units::Celsius<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl CoolantTemperature {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 05 - Coolant temperature. The unit of this type is celsius"]
            pub fn value(&self) -> &crate::v2::units::Celsius<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 05 - Coolant temperature. The unit of this type is celsius"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Celsius<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Celsius<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Celsius<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 06 - Short Term (immediate) Fuel Trim - Bank 1 - negative percent leaner, positive percent richer. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct ShortTermFuelTrim1 {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl ShortTermFuelTrim1 {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 06 - Short Term (immediate) Fuel Trim - Bank 1 - negative percent leaner, positive percent richer. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 06 - Short Term (immediate) Fuel Trim - Bank 1 - negative percent leaner, positive percent richer. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 07 - Long Term (learned) Fuel Trim - Bank 1 - negative percent leaner, positive percent richer. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct LongTermFuelTrim1 {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl LongTermFuelTrim1 {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 07 - Long Term (learned) Fuel Trim - Bank 1 - negative percent leaner, positive percent richer. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 07 - Long Term (learned) Fuel Trim - Bank 1 - negative percent leaner, positive percent richer. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 08 - Short Term (immediate) Fuel Trim - Bank 2 - negative percent leaner, positive percent richer. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct ShortTermFuelTrim2 {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl ShortTermFuelTrim2 {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 08 - Short Term (immediate) Fuel Trim - Bank 2 - negative percent leaner, positive percent richer. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 08 - Short Term (immediate) Fuel Trim - Bank 2 - negative percent leaner, positive percent richer. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 09 - Long Term (learned) Fuel Trim - Bank 2 - negative percent leaner, positive percent richer. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct LongTermFuelTrim2 {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl LongTermFuelTrim2 {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 09 - Long Term (learned) Fuel Trim - Bank 2 - negative percent leaner, positive percent richer. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 09 - Long Term (learned) Fuel Trim - Bank 2 - negative percent leaner, positive percent richer. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 0A - Fuel pressure. The unit of this type is kPa"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct FuelPressure {
            v: crate::v2::units::KiloPascal<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl FuelPressure {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 0A - Fuel pressure. The unit of this type is kPa"]
            pub fn value(&self) -> &crate::v2::units::KiloPascal<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 0A - Fuel pressure. The unit of this type is kPa"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::KiloPascal<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::KiloPascal<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::KiloPascal<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 0B - Intake manifold pressure. The unit of this type is kPa"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct MAP {
            v: crate::v2::units::KiloPascal<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl MAP {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 0B - Intake manifold pressure. The unit of this type is kPa"]
            pub fn value(&self) -> &crate::v2::units::KiloPascal<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 0B - Intake manifold pressure. The unit of this type is kPa"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::KiloPascal<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::KiloPascal<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::KiloPascal<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 0C - Engine speed measured as rotations per minute. The unit of this type is rpm"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct EngineSpeed {
            v: crate::v2::units::RPM<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl EngineSpeed {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 0C - Engine speed measured as rotations per minute. The unit of this type is rpm"]
            pub fn value(&self) -> &crate::v2::units::RPM<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 0C - Engine speed measured as rotations per minute. The unit of this type is rpm"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::RPM<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::RPM<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::RPM<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 0D - Vehicle speed. The unit of this type is km/h"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Speed {
            v: crate::v2::units::KilometrePerHour<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl Speed {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 0D - Vehicle speed. The unit of this type is km/h"]
            pub fn value(&self) -> &crate::v2::units::KilometrePerHour<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 0D - Vehicle speed. The unit of this type is km/h"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::KilometrePerHour<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::KilometrePerHour<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::KilometrePerHour<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 0E - Time advance. The unit of this type is degrees"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct TimingAdvance {
            v: f32,
            timestamp: crate::v2::Timestamp,
        }
        impl TimingAdvance {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 0E - Time advance. The unit of this type is degrees"]
            pub fn value(&self) -> &f32 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 0E - Time advance. The unit of this type is degrees"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: f32, maybe_timestamp: Option<crate::v2::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &f32) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: f32, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 0F - Intake temperature. The unit of this type is celsius"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct IntakeTemp {
            v: crate::v2::units::Celsius<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl IntakeTemp {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 0F - Intake temperature. The unit of this type is celsius"]
            pub fn value(&self) -> &crate::v2::units::Celsius<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 0F - Intake temperature. The unit of this type is celsius"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Celsius<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Celsius<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Celsius<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 10 - Grams of air drawn into engine per second. The unit of this type is g/s"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct MAF {
            v: crate::v2::units::GramPerSec<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl MAF {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 10 - Grams of air drawn into engine per second. The unit of this type is g/s"]
            pub fn value(&self) -> &crate::v2::units::GramPerSec<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 10 - Grams of air drawn into engine per second. The unit of this type is g/s"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::GramPerSec<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::GramPerSec<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::GramPerSec<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 11 - Throttle position - 0 = closed throttle, 100 = open throttle. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct ThrottlePosition {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl ThrottlePosition {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 11 - Throttle position - 0 = closed throttle, 100 = open throttle. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 11 - Throttle position - 0 = closed throttle, 100 = open throttle. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 12 - Secondary air status. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct AirStatus {
            v: String,
            timestamp: crate::v2::Timestamp,
        }
        impl AirStatus {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 12 - Secondary air status. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 12 - Secondary air status. This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String, maybe_timestamp: Option<crate::v2::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 13 - Presence of oxygen sensors in 2 banks. [A0..A3] == Bank 1, Sensors 1-4. [A4..A7] == Bank 2, Sensors 1-4. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct OxygenSensorsIn2Banks {
            v: u8,
            timestamp: crate::v2::Timestamp,
        }
        impl OxygenSensorsIn2Banks {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 13 - Presence of oxygen sensors in 2 banks. [A0..A3] == Bank 1, Sensors 1-4. [A4..A7] == Bank 2, Sensors 1-4. This type has no unit defined"]
            pub fn value(&self) -> &u8 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 13 - Presence of oxygen sensors in 2 banks. [A0..A3] == Bank 1, Sensors 1-4. [A4..A7] == Bank 2, Sensors 1-4. This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u8, maybe_timestamp: Option<crate::v2::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u8) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u8, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 1C - OBD standards this vehicle conforms to. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct OBDStandards {
            v: u8,
        }
        impl OBDStandards {
            #[doc = r" Get the "]
            #[doc = "PID 1C - OBD standards this vehicle conforms to. This type has no unit defined"]
            pub fn value(&self) -> &u8 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 1C - OBD standards this vehicle conforms to. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u8) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u8) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u8) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 1D - Presence of oxygen sensors in 4 banks. Similar to PID 13, but [A0..A7] == [B1S1, B1S2, B2S1, B2S2, B3S1, B3S2, B4S1, B4S2]. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct OxygenSensorsIn4Banks {
            v: u8,
            timestamp: crate::v2::Timestamp,
        }
        impl OxygenSensorsIn4Banks {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 1D - Presence of oxygen sensors in 4 banks. Similar to PID 13, but [A0..A7] == [B1S1, B1S2, B2S1, B2S2, B3S1, B3S2, B4S1, B4S2]. This type has no unit defined"]
            pub fn value(&self) -> &u8 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 1D - Presence of oxygen sensors in 4 banks. Similar to PID 13, but [A0..A7] == [B1S1, B1S2, B2S1, B2S2, B3S1, B3S2, B4S1, B4S2]. This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u8, maybe_timestamp: Option<crate::v2::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u8) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u8, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 1E - Auxiliary input status (power take off). This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct AuxInputStatus {
            v: bool,
            timestamp: crate::v2::Timestamp,
        }
        impl AuxInputStatus {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 1E - Auxiliary input status (power take off). This type has no unit defined"]
            pub fn value(&self) -> &bool {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 1E - Auxiliary input status (power take off). This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &bool) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 1F - Engine run time. The unit of this type is s"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct RunTime {
            v: crate::v2::units::Second<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl RunTime {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 1F - Engine run time. The unit of this type is s"]
            pub fn value(&self) -> &crate::v2::units::Second<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 1F - Engine run time. The unit of this type is s"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Second<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Second<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Second<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 20 - Bit array of the supported pids 21 to 40. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct PidsB {
            v: u32,
            timestamp: crate::v2::Timestamp,
        }
        impl PidsB {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 20 - Bit array of the supported pids 21 to 40. This type has no unit defined"]
            pub fn value(&self) -> &u32 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 20 - Bit array of the supported pids 21 to 40. This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u32, maybe_timestamp: Option<crate::v2::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u32) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u32, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 21 - Distance traveled with MIL on. The unit of this type is km"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct DistanceWithMIL {
            v: crate::v2::units::Kilometre<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl DistanceWithMIL {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 21 - Distance traveled with MIL on. The unit of this type is km"]
            pub fn value(&self) -> &crate::v2::units::Kilometre<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 21 - Distance traveled with MIL on. The unit of this type is km"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Kilometre<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Kilometre<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Kilometre<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 22 - Fuel rail pressure relative to vacuum. The unit of this type is kPa"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct FuelRailPressureVac {
            v: crate::v2::units::KiloPascal<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl FuelRailPressureVac {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 22 - Fuel rail pressure relative to vacuum. The unit of this type is kPa"]
            pub fn value(&self) -> &crate::v2::units::KiloPascal<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 22 - Fuel rail pressure relative to vacuum. The unit of this type is kPa"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::KiloPascal<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::KiloPascal<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::KiloPascal<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 23 - Fuel rail pressure direct inject. The unit of this type is kPa"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct FuelRailPressureDirect {
            v: crate::v2::units::KiloPascal<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl FuelRailPressureDirect {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 23 - Fuel rail pressure direct inject. The unit of this type is kPa"]
            pub fn value(&self) -> &crate::v2::units::KiloPascal<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 23 - Fuel rail pressure direct inject. The unit of this type is kPa"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::KiloPascal<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::KiloPascal<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::KiloPascal<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 2C - Commanded exhaust gas recirculation (EGR). The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct CommandedEGR {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl CommandedEGR {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 2C - Commanded exhaust gas recirculation (EGR). The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 2C - Commanded exhaust gas recirculation (EGR). The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 2D - Exhaust gas recirculation (EGR) error. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct EGRError {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl EGRError {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 2D - Exhaust gas recirculation (EGR) error. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 2D - Exhaust gas recirculation (EGR) error. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 2E - Commanded evaporative purge (EVAP) valve. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct CommandedEVAP {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl CommandedEVAP {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 2E - Commanded evaporative purge (EVAP) valve. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 2E - Commanded evaporative purge (EVAP) valve. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 2F - Fuel level in the fuel tank. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct FuelLevel {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl FuelLevel {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 2F - Fuel level in the fuel tank. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 2F - Fuel level in the fuel tank. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 30 - Number of warm-ups since codes cleared. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct WarmupsSinceDTCClear {
            v: u8,
            timestamp: crate::v2::Timestamp,
        }
        impl WarmupsSinceDTCClear {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 30 - Number of warm-ups since codes cleared. This type has no unit defined"]
            pub fn value(&self) -> &u8 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 30 - Number of warm-ups since codes cleared. This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u8, maybe_timestamp: Option<crate::v2::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u8) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u8, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 31 - Distance traveled since codes cleared. The unit of this type is km"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct DistanceSinceDTCClear {
            v: crate::v2::units::Kilometre<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl DistanceSinceDTCClear {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 31 - Distance traveled since codes cleared. The unit of this type is km"]
            pub fn value(&self) -> &crate::v2::units::Kilometre<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 31 - Distance traveled since codes cleared. The unit of this type is km"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Kilometre<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Kilometre<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Kilometre<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 32 - Evaporative purge (EVAP) system pressure. The unit of this type is Pa"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct EVAPVaporPressure {
            v: crate::v2::units::Pascal<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl EVAPVaporPressure {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 32 - Evaporative purge (EVAP) system pressure. The unit of this type is Pa"]
            pub fn value(&self) -> &crate::v2::units::Pascal<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 32 - Evaporative purge (EVAP) system pressure. The unit of this type is Pa"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Pascal<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Pascal<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Pascal<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 33 - Barometric pressure. The unit of this type is kPa"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct BarometricPressure {
            v: crate::v2::units::KiloPascal<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl BarometricPressure {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 33 - Barometric pressure. The unit of this type is kPa"]
            pub fn value(&self) -> &crate::v2::units::KiloPascal<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 33 - Barometric pressure. The unit of this type is kPa"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::KiloPascal<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::KiloPascal<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::KiloPascal<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 40 - Bit array of the supported pids 41 to 60. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct PidsC {
            v: u32,
            timestamp: crate::v2::Timestamp,
        }
        impl PidsC {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 40 - Bit array of the supported pids 41 to 60. This type has no unit defined"]
            pub fn value(&self) -> &u32 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 40 - Bit array of the supported pids 41 to 60. This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u32, maybe_timestamp: Option<crate::v2::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u32) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u32, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 42 - Control module voltage. The unit of this type is V"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct ControlModuleVoltage {
            v: crate::v2::units::Volt<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl ControlModuleVoltage {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 42 - Control module voltage. The unit of this type is V"]
            pub fn value(&self) -> &crate::v2::units::Volt<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 42 - Control module voltage. The unit of this type is V"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Volt<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Volt<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Volt<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 43 - Absolute load value. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct AbsoluteLoad {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl AbsoluteLoad {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 43 - Absolute load value. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 43 - Absolute load value. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 44 - Commanded equivalence ratio. The unit of this type is ratio"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct CommandedEquivalenceRatio {
            v: crate::v2::units::Ratio<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl CommandedEquivalenceRatio {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 44 - Commanded equivalence ratio. The unit of this type is ratio"]
            pub fn value(&self) -> &crate::v2::units::Ratio<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 44 - Commanded equivalence ratio. The unit of this type is ratio"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Ratio<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Ratio<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Ratio<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 45 - Relative throttle position. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct RelativeThrottlePosition {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl RelativeThrottlePosition {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 45 - Relative throttle position. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 45 - Relative throttle position. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 46 - Ambient air temperature. The unit of this type is celsius"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct AmbientAirTemperature {
            v: crate::v2::units::Celsius<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl AmbientAirTemperature {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 46 - Ambient air temperature. The unit of this type is celsius"]
            pub fn value(&self) -> &crate::v2::units::Celsius<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 46 - Ambient air temperature. The unit of this type is celsius"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Celsius<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Celsius<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Celsius<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 47 - Absolute throttle position B. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct ThrottlePositionB {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl ThrottlePositionB {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 47 - Absolute throttle position B. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 47 - Absolute throttle position B. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 48 - Absolute throttle position C. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct ThrottlePositionC {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl ThrottlePositionC {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 48 - Absolute throttle position C. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 48 - Absolute throttle position C. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 49 - Accelerator pedal position D. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct AcceleratorPositionD {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl AcceleratorPositionD {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 49 - Accelerator pedal position D. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 49 - Accelerator pedal position D. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 4A - Accelerator pedal position E. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct AcceleratorPositionE {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl AcceleratorPositionE {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 4A - Accelerator pedal position E. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 4A - Accelerator pedal position E. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 4B - Accelerator pedal position F. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct AcceleratorPositionF {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl AcceleratorPositionF {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 4B - Accelerator pedal position F. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 4B - Accelerator pedal position F. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 4C - Commanded throttle actuator. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct ThrottleActuator {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl ThrottleActuator {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 4C - Commanded throttle actuator. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 4C - Commanded throttle actuator. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 4D - Run time with MIL on. The unit of this type is min"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct RunTimeMIL {
            v: crate::v2::units::Minute<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl RunTimeMIL {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 4D - Run time with MIL on. The unit of this type is min"]
            pub fn value(&self) -> &crate::v2::units::Minute<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 4D - Run time with MIL on. The unit of this type is min"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Minute<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Minute<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Minute<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 4E - Time since trouble codes cleared. The unit of this type is min"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct TimeSinceDTCCleared {
            v: crate::v2::units::Minute<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl TimeSinceDTCCleared {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 4E - Time since trouble codes cleared. The unit of this type is min"]
            pub fn value(&self) -> &crate::v2::units::Minute<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 4E - Time since trouble codes cleared. The unit of this type is min"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Minute<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Minute<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Minute<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 50 - Maximum flow for mass air flow sensor. The unit of this type is g/s"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct MaxMAF {
            v: crate::v2::units::GramPerSec<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl MaxMAF {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 50 - Maximum flow for mass air flow sensor. The unit of this type is g/s"]
            pub fn value(&self) -> &crate::v2::units::GramPerSec<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 50 - Maximum flow for mass air flow sensor. The unit of this type is g/s"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::GramPerSec<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::GramPerSec<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::GramPerSec<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 51 - Fuel type. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct FuelType {
            v: String,
            timestamp: crate::v2::Timestamp,
        }
        impl FuelType {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 51 - Fuel type. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 51 - Fuel type. This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String, maybe_timestamp: Option<crate::v2::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 52 - Percentage of ethanol in the fuel. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct EthanolPercent {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl EthanolPercent {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 52 - Percentage of ethanol in the fuel. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 52 - Percentage of ethanol in the fuel. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 53 - Absolute evaporative purge (EVAP) system pressure. The unit of this type is kPa"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct EVAPVaporPressureAbsolute {
            v: crate::v2::units::KiloPascal<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl EVAPVaporPressureAbsolute {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 53 - Absolute evaporative purge (EVAP) system pressure. The unit of this type is kPa"]
            pub fn value(&self) -> &crate::v2::units::KiloPascal<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 53 - Absolute evaporative purge (EVAP) system pressure. The unit of this type is kPa"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::KiloPascal<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::KiloPascal<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::KiloPascal<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 54 - Alternate evaporative purge (EVAP) system pressure. The unit of this type is Pa"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct EVAPVaporPressureAlternate {
            v: crate::v2::units::Pascal<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl EVAPVaporPressureAlternate {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 54 - Alternate evaporative purge (EVAP) system pressure. The unit of this type is Pa"]
            pub fn value(&self) -> &crate::v2::units::Pascal<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 54 - Alternate evaporative purge (EVAP) system pressure. The unit of this type is Pa"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Pascal<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Pascal<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Pascal<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 55 (byte A) - Short term secondary O2 trim - Bank 1. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct ShortTermO2Trim1 {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl ShortTermO2Trim1 {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 55 (byte A) - Short term secondary O2 trim - Bank 1. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 55 (byte A) - Short term secondary O2 trim - Bank 1. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 55 (byte B) - Short term secondary O2 trim - Bank 3. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct ShortTermO2Trim3 {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl ShortTermO2Trim3 {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 55 (byte B) - Short term secondary O2 trim - Bank 3. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 55 (byte B) - Short term secondary O2 trim - Bank 3. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 56 (byte A) - Long term secondary O2 trim - Bank 1. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct LongTermO2Trim1 {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl LongTermO2Trim1 {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 56 (byte A) - Long term secondary O2 trim - Bank 1. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 56 (byte A) - Long term secondary O2 trim - Bank 1. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 56 (byte B) - Long term secondary O2 trim - Bank 3. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct LongTermO2Trim3 {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl LongTermO2Trim3 {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 56 (byte B) - Long term secondary O2 trim - Bank 3. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 56 (byte B) - Long term secondary O2 trim - Bank 3. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 57 (byte A) - Short term secondary O2 trim - Bank 2. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct ShortTermO2Trim2 {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl ShortTermO2Trim2 {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 57 (byte A) - Short term secondary O2 trim - Bank 2. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 57 (byte A) - Short term secondary O2 trim - Bank 2. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 57 (byte B) - Short term secondary O2 trim - Bank 4. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct ShortTermO2Trim4 {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl ShortTermO2Trim4 {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 57 (byte B) - Short term secondary O2 trim - Bank 4. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 57 (byte B) - Short term secondary O2 trim - Bank 4. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 58 (byte A) - Long term secondary O2 trim - Bank 2. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct LongTermO2Trim2 {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl LongTermO2Trim2 {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 58 (byte A) - Long term secondary O2 trim - Bank 2. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 58 (byte A) - Long term secondary O2 trim - Bank 2. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 58 (byte B) - Long term secondary O2 trim - Bank 4. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct LongTermO2Trim4 {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl LongTermO2Trim4 {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 58 (byte B) - Long term secondary O2 trim - Bank 4. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 58 (byte B) - Long term secondary O2 trim - Bank 4. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 59 - Absolute fuel rail pressure. The unit of this type is kPa"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct FuelRailPressureAbsolute {
            v: crate::v2::units::KiloPascal<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl FuelRailPressureAbsolute {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 59 - Absolute fuel rail pressure. The unit of this type is kPa"]
            pub fn value(&self) -> &crate::v2::units::KiloPascal<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 59 - Absolute fuel rail pressure. The unit of this type is kPa"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::KiloPascal<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::KiloPascal<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::KiloPascal<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 5A - Relative accelerator pedal position. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct RelativeAcceleratorPosition {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl RelativeAcceleratorPosition {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 5A - Relative accelerator pedal position. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 5A - Relative accelerator pedal position. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 5B - Remaining life of hybrid battery. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct HybridBatteryRemaining {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl HybridBatteryRemaining {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 5B - Remaining life of hybrid battery. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 5B - Remaining life of hybrid battery. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 5C - Engine oil temperature. The unit of this type is celsius"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct OilTemperature {
            v: crate::v2::units::Celsius<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl OilTemperature {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 5C - Engine oil temperature. The unit of this type is celsius"]
            pub fn value(&self) -> &crate::v2::units::Celsius<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 5C - Engine oil temperature. The unit of this type is celsius"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Celsius<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Celsius<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Celsius<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 5D - Fuel injection timing. The unit of this type is degrees"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct FuelInjectionTiming {
            v: f32,
            timestamp: crate::v2::Timestamp,
        }
        impl FuelInjectionTiming {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 5D - Fuel injection timing. The unit of this type is degrees"]
            pub fn value(&self) -> &f32 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 5D - Fuel injection timing. The unit of this type is degrees"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: f32, maybe_timestamp: Option<crate::v2::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &f32) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: f32, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 5E - Engine fuel rate. The unit of this type is l/h"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct FuelRate {
            v: crate::v2::units::LiterPerHour<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl FuelRate {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 5E - Engine fuel rate. The unit of this type is l/h"]
            pub fn value(&self) -> &crate::v2::units::LiterPerHour<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 5E - Engine fuel rate. The unit of this type is l/h"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::LiterPerHour<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::LiterPerHour<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::LiterPerHour<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod drivecyclestatus {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Malfunction Indicator Light (MIL) - False = Off, True = On. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct MIL {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl MIL {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Malfunction Indicator Light (MIL) - False = Off, True = On. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Malfunction Indicator Light (MIL) - False = Off, True = On. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Number of sensor Trouble Codes (DTC). This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct DTCCount {
                v: u8,
                timestamp: crate::v2::Timestamp,
            }
            impl DTCCount {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Number of sensor Trouble Codes (DTC). This type has no unit defined"]
                pub fn value(&self) -> &u8 {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Number of sensor Trouble Codes (DTC). This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: u8, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &u8) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: u8, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Type of the ignition for ICE - spark = spark plug ignition, compression = self-igniting (Diesel engines). This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IgnitionType {
                v: String,
                timestamp: crate::v2::Timestamp,
            }
            impl IgnitionType {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Type of the ignition for ICE - spark = spark plug ignition, compression = self-igniting (Diesel engines). This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Type of the ignition for ICE - spark = spark plug ignition, compression = self-igniting (Diesel engines). This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: String,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod catalyst {
            #[allow(non_snake_case)]
            pub mod bank2 {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "PID 3D - Catalyst temperature from bank 2, sensor 1. The unit of this type is celsius"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Temperature1 {
                    v: crate::v2::units::Celsius<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    bank: u8,
                }
                impl Temperature1 {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 3D - Catalyst temperature from bank 2, sensor 1. The unit of this type is celsius"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,bank)"]
                    pub fn value(&self) -> (&crate::v2::units::Celsius<f32>, &u8) {
                        (&self.v, &self.bank)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 3D - Catalyst temperature from bank 2, sensor 1. The unit of this type is celsius"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Celsius<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        bank: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.bank = bank;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Celsius<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Celsius<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        bank: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                bank,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 3F - Catalyst temperature from bank 2, sensor 2. The unit of this type is celsius"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Temperature2 {
                    v: crate::v2::units::Celsius<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    bank: u8,
                }
                impl Temperature2 {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 3F - Catalyst temperature from bank 2, sensor 2. The unit of this type is celsius"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,bank)"]
                    pub fn value(&self) -> (&crate::v2::units::Celsius<f32>, &u8) {
                        (&self.v, &self.bank)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 3F - Catalyst temperature from bank 2, sensor 2. The unit of this type is celsius"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Celsius<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        bank: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.bank = bank;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Celsius<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Celsius<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        bank: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                bank,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod bank1 {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "PID 3C - Catalyst temperature from bank 1, sensor 1. The unit of this type is celsius"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Temperature1 {
                    v: crate::v2::units::Celsius<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    bank: u8,
                }
                impl Temperature1 {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 3C - Catalyst temperature from bank 1, sensor 1. The unit of this type is celsius"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,bank)"]
                    pub fn value(&self) -> (&crate::v2::units::Celsius<f32>, &u8) {
                        (&self.v, &self.bank)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 3C - Catalyst temperature from bank 1, sensor 1. The unit of this type is celsius"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Celsius<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        bank: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.bank = bank;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Celsius<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Celsius<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        bank: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                bank,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 3E - Catalyst temperature from bank 1, sensor 2. The unit of this type is celsius"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Temperature2 {
                    v: crate::v2::units::Celsius<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    bank: u8,
                }
                impl Temperature2 {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 3E - Catalyst temperature from bank 1, sensor 2. The unit of this type is celsius"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,bank)"]
                    pub fn value(&self) -> (&crate::v2::units::Celsius<f32>, &u8) {
                        (&self.v, &self.bank)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 3E - Catalyst temperature from bank 1, sensor 2. The unit of this type is celsius"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Celsius<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        bank: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.bank = bank;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Celsius<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Celsius<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        bank: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                bank,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod o2wr {
            #[allow(non_snake_case)]
            pub mod sensor8 {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Lambda {
                    v: f32,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Lambda {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&f32, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: f32,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &f32) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: f32,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Voltage {
                    v: crate::v2::units::Volt<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Voltage {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Volt<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Volt<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Volt<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Volt<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Current {
                    v: crate::v2::units::Amp<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Current {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Amp<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Amp<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Amp<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Amp<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod sensor7 {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Lambda {
                    v: f32,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Lambda {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&f32, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: f32,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &f32) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: f32,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Voltage {
                    v: crate::v2::units::Volt<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Voltage {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Volt<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Volt<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Volt<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Volt<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Current {
                    v: crate::v2::units::Amp<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Current {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Amp<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Amp<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Amp<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Amp<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod sensor6 {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Lambda {
                    v: f32,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Lambda {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&f32, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: f32,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &f32) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: f32,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Voltage {
                    v: crate::v2::units::Volt<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Voltage {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Volt<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Volt<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Volt<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Volt<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Current {
                    v: crate::v2::units::Amp<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Current {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Amp<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Amp<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Amp<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Amp<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod sensor5 {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Lambda {
                    v: f32,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Lambda {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&f32, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: f32,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &f32) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: f32,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Voltage {
                    v: crate::v2::units::Volt<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Voltage {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Volt<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Volt<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Volt<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Volt<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Current {
                    v: crate::v2::units::Amp<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Current {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Amp<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Amp<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Amp<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Amp<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod sensor4 {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Lambda {
                    v: f32,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Lambda {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&f32, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: f32,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &f32) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: f32,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Voltage {
                    v: crate::v2::units::Volt<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Voltage {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Volt<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Volt<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Volt<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Volt<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Current {
                    v: crate::v2::units::Amp<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Current {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Amp<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Amp<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Amp<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Amp<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod sensor3 {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Lambda {
                    v: f32,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Lambda {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&f32, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: f32,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &f32) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: f32,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Voltage {
                    v: crate::v2::units::Volt<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Voltage {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Volt<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Volt<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Volt<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Volt<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Current {
                    v: crate::v2::units::Amp<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Current {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Amp<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Amp<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Amp<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Amp<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod sensor2 {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Lambda {
                    v: f32,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Lambda {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&f32, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: f32,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &f32) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: f32,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Voltage {
                    v: crate::v2::units::Volt<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Voltage {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Volt<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Volt<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Volt<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Volt<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Current {
                    v: crate::v2::units::Amp<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Current {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Amp<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Amp<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Amp<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Amp<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod sensor1 {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Lambda {
                    v: f32,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Lambda {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&f32, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: f32,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &f32) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: f32,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Voltage {
                    v: crate::v2::units::Volt<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Voltage {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Volt<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Volt<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Volt<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Volt<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Current {
                    v: crate::v2::units::Amp<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Current {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Amp<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Amp<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Amp<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Amp<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod o2 {
            #[allow(non_snake_case)]
            pub mod sensor8 {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "PID 1x (byte A) - Sensor voltage. The unit of this type is V"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Voltage {
                    v: crate::v2::units::Volt<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Voltage {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 1x (byte A) - Sensor voltage. The unit of this type is V"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Volt<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 1x (byte A) - Sensor voltage. The unit of this type is V"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Volt<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Volt<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Volt<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 1x (byte B) - Short term fuel trim. The unit of this type is percent"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct ShortTermFuelTrim {
                    v: crate::v2::units::Percent<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl ShortTermFuelTrim {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 1x (byte B) - Short term fuel trim. The unit of this type is percent"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Percent<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 1x (byte B) - Short term fuel trim. The unit of this type is percent"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Percent<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Percent<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod sensor7 {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "PID 1x (byte A) - Sensor voltage. The unit of this type is V"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Voltage {
                    v: crate::v2::units::Volt<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Voltage {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 1x (byte A) - Sensor voltage. The unit of this type is V"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Volt<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 1x (byte A) - Sensor voltage. The unit of this type is V"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Volt<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Volt<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Volt<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 1x (byte B) - Short term fuel trim. The unit of this type is percent"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct ShortTermFuelTrim {
                    v: crate::v2::units::Percent<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl ShortTermFuelTrim {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 1x (byte B) - Short term fuel trim. The unit of this type is percent"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Percent<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 1x (byte B) - Short term fuel trim. The unit of this type is percent"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Percent<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Percent<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod sensor6 {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "PID 1x (byte A) - Sensor voltage. The unit of this type is V"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Voltage {
                    v: crate::v2::units::Volt<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Voltage {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 1x (byte A) - Sensor voltage. The unit of this type is V"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Volt<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 1x (byte A) - Sensor voltage. The unit of this type is V"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Volt<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Volt<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Volt<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 1x (byte B) - Short term fuel trim. The unit of this type is percent"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct ShortTermFuelTrim {
                    v: crate::v2::units::Percent<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl ShortTermFuelTrim {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 1x (byte B) - Short term fuel trim. The unit of this type is percent"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Percent<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 1x (byte B) - Short term fuel trim. The unit of this type is percent"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Percent<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Percent<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod sensor5 {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "PID 1x (byte A) - Sensor voltage. The unit of this type is V"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Voltage {
                    v: crate::v2::units::Volt<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Voltage {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 1x (byte A) - Sensor voltage. The unit of this type is V"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Volt<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 1x (byte A) - Sensor voltage. The unit of this type is V"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Volt<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Volt<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Volt<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 1x (byte B) - Short term fuel trim. The unit of this type is percent"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct ShortTermFuelTrim {
                    v: crate::v2::units::Percent<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl ShortTermFuelTrim {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 1x (byte B) - Short term fuel trim. The unit of this type is percent"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Percent<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 1x (byte B) - Short term fuel trim. The unit of this type is percent"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Percent<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Percent<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod sensor4 {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "PID 1x (byte A) - Sensor voltage. The unit of this type is V"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Voltage {
                    v: crate::v2::units::Volt<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Voltage {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 1x (byte A) - Sensor voltage. The unit of this type is V"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Volt<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 1x (byte A) - Sensor voltage. The unit of this type is V"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Volt<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Volt<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Volt<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 1x (byte B) - Short term fuel trim. The unit of this type is percent"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct ShortTermFuelTrim {
                    v: crate::v2::units::Percent<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl ShortTermFuelTrim {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 1x (byte B) - Short term fuel trim. The unit of this type is percent"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Percent<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 1x (byte B) - Short term fuel trim. The unit of this type is percent"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Percent<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Percent<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod sensor3 {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "PID 1x (byte A) - Sensor voltage. The unit of this type is V"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Voltage {
                    v: crate::v2::units::Volt<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Voltage {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 1x (byte A) - Sensor voltage. The unit of this type is V"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Volt<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 1x (byte A) - Sensor voltage. The unit of this type is V"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Volt<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Volt<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Volt<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 1x (byte B) - Short term fuel trim. The unit of this type is percent"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct ShortTermFuelTrim {
                    v: crate::v2::units::Percent<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl ShortTermFuelTrim {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 1x (byte B) - Short term fuel trim. The unit of this type is percent"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Percent<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 1x (byte B) - Short term fuel trim. The unit of this type is percent"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Percent<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Percent<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod status {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Malfunction Indicator Light (MIL) False = Off, True = On. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct MIL {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl MIL {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Malfunction Indicator Light (MIL) False = Off, True = On. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Malfunction Indicator Light (MIL) False = Off, True = On. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Number of sensor Trouble Codes (DTC). This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct DTCCount {
                v: u8,
                timestamp: crate::v2::Timestamp,
            }
            impl DTCCount {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Number of sensor Trouble Codes (DTC). This type has no unit defined"]
                pub fn value(&self) -> &u8 {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Number of sensor Trouble Codes (DTC). This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: u8, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &u8) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: u8, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Type of the ignition for ICE - spark = spark plug ignition, compression = self-igniting (Diesel engines). This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IgnitionType {
                v: String,
                timestamp: crate::v2::Timestamp,
            }
            impl IgnitionType {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Type of the ignition for ICE - spark = spark plug ignition, compression = self-igniting (Diesel engines). This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Type of the ignition for ICE - spark = spark plug ignition, compression = self-igniting (Diesel engines). This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: String,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
    }
    #[allow(non_snake_case)]
    pub mod chassis {
        use cdds_derive::Topic;
        use cyclonedds_rs::*;
        #[doc = "Vehicle curb weight, in kg, including all liquids and full tank of fuel, but no cargo or passengers.. The unit of this type is kg"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct CurbWeight {
            v: crate::v2::units::Kilogram<u16>,
        }
        impl CurbWeight {
            #[doc = r" Get the "]
            #[doc = "Vehicle curb weight, in kg, including all liquids and full tank of fuel, but no cargo or passengers.. The unit of this type is kg"]
            pub fn value(&self) -> &crate::v2::units::Kilogram<u16> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Vehicle curb weight, in kg, including all liquids and full tank of fuel, but no cargo or passengers.. The unit of this type is kg"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: crate::v2::units::Kilogram<u16>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Kilogram<u16>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: crate::v2::units::Kilogram<u16>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "Curb weight of vehicle, including all liquids and full tank of fuel and full load of cargo and passengers.. The unit of this type is kg"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct GrossWeight {
            v: crate::v2::units::Kilogram<u16>,
        }
        impl GrossWeight {
            #[doc = r" Get the "]
            #[doc = "Curb weight of vehicle, including all liquids and full tank of fuel and full load of cargo and passengers.. The unit of this type is kg"]
            pub fn value(&self) -> &crate::v2::units::Kilogram<u16> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Curb weight of vehicle, including all liquids and full tank of fuel and full load of cargo and passengers.. The unit of this type is kg"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: crate::v2::units::Kilogram<u16>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Kilogram<u16>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: crate::v2::units::Kilogram<u16>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "Maximum weight, in kilos, of trailer.. The unit of this type is kg"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct TowWeight {
            v: crate::v2::units::Kilogram<u16>,
        }
        impl TowWeight {
            #[doc = r" Get the "]
            #[doc = "Maximum weight, in kilos, of trailer.. The unit of this type is kg"]
            pub fn value(&self) -> &crate::v2::units::Kilogram<u16> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Maximum weight, in kilos, of trailer.. The unit of this type is kg"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: crate::v2::units::Kilogram<u16>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Kilogram<u16>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: crate::v2::units::Kilogram<u16>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "Overall vehicle length, in mm.. The unit of this type is mm"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Length {
            v: crate::v2::units::Millimetre<u16>,
        }
        impl Length {
            #[doc = r" Get the "]
            #[doc = "Overall vehicle length, in mm.. The unit of this type is mm"]
            pub fn value(&self) -> &crate::v2::units::Millimetre<u16> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Overall vehicle length, in mm.. The unit of this type is mm"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: crate::v2::units::Millimetre<u16>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Millimetre<u16>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: crate::v2::units::Millimetre<u16>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "Overall vehicle height, in mm.. The unit of this type is mm"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Height {
            v: crate::v2::units::Millimetre<u16>,
        }
        impl Height {
            #[doc = r" Get the "]
            #[doc = "Overall vehicle height, in mm.. The unit of this type is mm"]
            pub fn value(&self) -> &crate::v2::units::Millimetre<u16> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Overall vehicle height, in mm.. The unit of this type is mm"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: crate::v2::units::Millimetre<u16>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Millimetre<u16>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: crate::v2::units::Millimetre<u16>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "Overall vehicle width, in mm.. The unit of this type is mm"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Width {
            v: crate::v2::units::Millimetre<u16>,
        }
        impl Width {
            #[doc = r" Get the "]
            #[doc = "Overall vehicle width, in mm.. The unit of this type is mm"]
            pub fn value(&self) -> &crate::v2::units::Millimetre<u16> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Overall vehicle width, in mm.. The unit of this type is mm"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: crate::v2::units::Millimetre<u16>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Millimetre<u16>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: crate::v2::units::Millimetre<u16>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "Overall wheel base, in mm.. The unit of this type is mm"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Wheelbase {
            v: crate::v2::units::Millimetre<u16>,
        }
        impl Wheelbase {
            #[doc = r" Get the "]
            #[doc = "Overall wheel base, in mm.. The unit of this type is mm"]
            pub fn value(&self) -> &crate::v2::units::Millimetre<u16> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Overall wheel base, in mm.. The unit of this type is mm"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: crate::v2::units::Millimetre<u16>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Millimetre<u16>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: crate::v2::units::Millimetre<u16>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "Overall wheel tracking, in mm.. The unit of this type is mm"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Track {
            v: crate::v2::units::Millimetre<u16>,
        }
        impl Track {
            #[doc = r" Get the "]
            #[doc = "Overall wheel tracking, in mm.. The unit of this type is mm"]
            pub fn value(&self) -> &crate::v2::units::Millimetre<u16> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Overall wheel tracking, in mm.. The unit of this type is mm"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: crate::v2::units::Millimetre<u16>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Millimetre<u16>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: crate::v2::units::Millimetre<u16>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "Number of axles on the vehicle. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct AxleCount {
            v: u8,
        }
        impl AxleCount {
            #[doc = r" Get the "]
            #[doc = "Number of axles on the vehicle. This type has no unit defined"]
            pub fn value(&self) -> &u8 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Number of axles on the vehicle. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u8) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u8) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u8) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod trailer {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Signal indicating if trailer is connected or not.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Connected {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl Connected {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Signal indicating if trailer is connected or not.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Signal indicating if trailer is connected or not.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod brake {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Brake pedal position as percent. 0 = Not depressed. 100 = Fully depressed.. The unit of this type is percent"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct PedalPosition {
                v: crate::v2::units::Percent<u8>,
                timestamp: crate::v2::Timestamp,
            }
            impl PedalPosition {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Brake pedal position as percent. 0 = Not depressed. 100 = Fully depressed.. The unit of this type is percent"]
                pub fn value(&self) -> &crate::v2::units::Percent<u8> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Brake pedal position as percent. 0 = Not depressed. 100 = Fully depressed.. The unit of this type is percent"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Percent<u8>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v2::units::Percent<u8>) -> bool {
                    v.0 <= 100u8 && v.0 >= 0u8
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Percent<u8>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod accelerator {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Accelerator pedal position as percent. 0 = Not depressed. 100 = Fully depressed.. The unit of this type is percent"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct PedalPosition {
                v: crate::v2::units::Percent<u8>,
                timestamp: crate::v2::Timestamp,
            }
            impl PedalPosition {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Accelerator pedal position as percent. 0 = Not depressed. 100 = Fully depressed.. The unit of this type is percent"]
                pub fn value(&self) -> &crate::v2::units::Percent<u8> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Accelerator pedal position as percent. 0 = Not depressed. 100 = Fully depressed.. The unit of this type is percent"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Percent<u8>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v2::units::Percent<u8>) -> bool {
                    v.0 <= 100u8 && v.0 >= 0u8
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Percent<u8>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod steeringwheel {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Steering wheel angle. Positive = degrees to the left. Negative = degrees to the right.. The unit of this type is degrees"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Angle {
                v: i16,
                timestamp: crate::v2::Timestamp,
            }
            impl Angle {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Steering wheel angle. Positive = degrees to the left. Negative = degrees to the right.. The unit of this type is degrees"]
                pub fn value(&self) -> &i16 {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Steering wheel angle. Positive = degrees to the left. Negative = degrees to the right.. The unit of this type is degrees"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: i16, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &i16) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: i16, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Steering wheel column tilt. 0 = Lowest position. 100 = Highest position.. The unit of this type is percent"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Tilt {
                v: crate::v2::units::Percent<u8>,
                timestamp: crate::v2::Timestamp,
            }
            impl Tilt {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Steering wheel column tilt. 0 = Lowest position. 100 = Highest position.. The unit of this type is percent"]
                pub fn value(&self) -> &crate::v2::units::Percent<u8> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Steering wheel column tilt. 0 = Lowest position. 100 = Highest position.. The unit of this type is percent"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Percent<u8>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v2::units::Percent<u8>) -> bool {
                    v.0 <= 100u8 && v.0 >= 0u8
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Percent<u8>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Steering wheel column extension from dashboard. 0 = Closest to dashboard. 100 = Furthest from dashboard.. The unit of this type is percent"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Extension {
                v: crate::v2::units::Percent<u8>,
                timestamp: crate::v2::Timestamp,
            }
            impl Extension {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Steering wheel column extension from dashboard. 0 = Closest to dashboard. 100 = Furthest from dashboard.. The unit of this type is percent"]
                pub fn value(&self) -> &crate::v2::units::Percent<u8> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Steering wheel column extension from dashboard. 0 = Closest to dashboard. 100 = Furthest from dashboard.. The unit of this type is percent"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Percent<u8>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v2::units::Percent<u8>) -> bool {
                    v.0 <= 100u8 && v.0 >= 0u8
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Percent<u8>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Position of the steering wheel on the left or right side of the vehicle.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Position {
                v: String,
            }
            impl Position {
                #[doc = r" Get the "]
                #[doc = "Position of the steering wheel on the left or right side of the vehicle.. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Position of the steering wheel on the left or right side of the vehicle.. This type has no unit defined"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: String) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod parkingbrake {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Parking brake status. True = Parking Brake is Engaged. False = Parking Brake is not Engaged.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsEngaged {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsEngaged {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Parking brake status. True = Parking Brake is Engaged. False = Parking Brake is not Engaged.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Parking brake status. True = Parking Brake is Engaged. False = Parking Brake is not Engaged.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod axle {
            #[allow(non_snake_case)]
            pub mod wheel {
                #[allow(non_snake_case)]
                pub mod brake {
                    use cdds_derive::Topic;
                    use cyclonedds_rs::*;
                    #[doc = "Brake fluid level as percent. 0 = Empty. 100 = Full.. The unit of this type is percent"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct FluidLevel {
                        v: crate::v2::units::Percent<u8>,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key]
                        row: u8,
                        #[topic_key_enum]
                        side: crate::v2::Side,
                    }
                    impl FluidLevel {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Brake fluid level as percent. 0 = Empty. 100 = Full.. The unit of this type is percent"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, side)"]
                        pub fn value(
                            &self,
                        ) -> (&crate::v2::units::Percent<u8>, &u8, &crate::v2::Side)
                        {
                            (&self.v, &self.row, &self.side)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Brake fluid level as percent. 0 = Empty. 100 = Full.. The unit of this type is percent"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: crate::v2::units::Percent<u8>,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            side: crate::v2::Side,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.row = row;
                            self.side = side;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &crate::v2::units::Percent<u8>) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: crate::v2::units::Percent<u8>,
                            timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            side: crate::v2::Side,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    side,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Brake fluid level status. True = Brake fluid level low. False = Brake fluid level OK.. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct FluidLevelLow {
                        v: bool,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key]
                        row: u8,
                        #[topic_key_enum]
                        side: crate::v2::Side,
                    }
                    impl FluidLevelLow {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Brake fluid level status. True = Brake fluid level low. False = Brake fluid level OK.. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, side)"]
                        pub fn value(&self) -> (&bool, &u8, &crate::v2::Side) {
                            (&self.v, &self.row, &self.side)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Brake fluid level status. True = Brake fluid level low. False = Brake fluid level OK.. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            side: crate::v2::Side,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.row = row;
                            self.side = side;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            side: crate::v2::Side,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    side,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Brake pad wear as percent. 0 = No Wear. 100 = Worn.. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct PadWear {
                        v: u8,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key]
                        row: u8,
                        #[topic_key_enum]
                        side: crate::v2::Side,
                    }
                    impl PadWear {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Brake pad wear as percent. 0 = No Wear. 100 = Worn.. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, side)"]
                        pub fn value(&self) -> (&u8, &u8, &crate::v2::Side) {
                            (&self.v, &self.row, &self.side)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Brake pad wear as percent. 0 = No Wear. 100 = Worn.. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: u8,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            side: crate::v2::Side,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.row = row;
                            self.side = side;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &u8) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: u8,
                            timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            side: crate::v2::Side,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    side,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Brake pad wear status. True = Worn. False = Not Worn.. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct BrakesWorn {
                        v: bool,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key]
                        row: u8,
                        #[topic_key_enum]
                        side: crate::v2::Side,
                    }
                    impl BrakesWorn {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Brake pad wear status. True = Worn. False = Not Worn.. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, side)"]
                        pub fn value(&self) -> (&bool, &u8, &crate::v2::Side) {
                            (&self.v, &self.row, &self.side)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Brake pad wear status. True = Worn. False = Not Worn.. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            side: crate::v2::Side,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.row = row;
                            self.side = side;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            side: crate::v2::Side,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    side,
                                })
                            } else {
                                None
                            }
                        }
                    }
                }
                #[allow(non_snake_case)]
                pub mod tire {
                    use cdds_derive::Topic;
                    use cyclonedds_rs::*;
                    #[doc = "Tire pressure in kilo-Pascal. The unit of this type is kPa"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Pressure {
                        v: crate::v2::units::KiloPascal<u16>,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key]
                        row: u8,
                        #[topic_key_enum]
                        side: crate::v2::Side,
                    }
                    impl Pressure {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Tire pressure in kilo-Pascal. The unit of this type is kPa"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, side)"]
                        pub fn value(
                            &self,
                        ) -> (&crate::v2::units::KiloPascal<u16>, &u8, &crate::v2::Side)
                        {
                            (&self.v, &self.row, &self.side)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Tire pressure in kilo-Pascal. The unit of this type is kPa"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: crate::v2::units::KiloPascal<u16>,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            side: crate::v2::Side,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.row = row;
                            self.side = side;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &crate::v2::units::KiloPascal<u16>) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: crate::v2::units::KiloPascal<u16>,
                            timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            side: crate::v2::Side,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    side,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Tire Pressure Status. True = Low tire pressure. False = Good tire pressure.. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct PressureLow {
                        v: bool,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key]
                        row: u8,
                        #[topic_key_enum]
                        side: crate::v2::Side,
                    }
                    impl PressureLow {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Tire Pressure Status. True = Low tire pressure. False = Good tire pressure.. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, side)"]
                        pub fn value(&self) -> (&bool, &u8, &crate::v2::Side) {
                            (&self.v, &self.row, &self.side)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Tire Pressure Status. True = Low tire pressure. False = Good tire pressure.. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            side: crate::v2::Side,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.row = row;
                            self.side = side;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            side: crate::v2::Side,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    side,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Tire temperature in Celsius.. The unit of this type is celsius"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Temperature {
                        v: crate::v2::units::Celsius<f32>,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key]
                        row: u8,
                        #[topic_key_enum]
                        side: crate::v2::Side,
                    }
                    impl Temperature {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Tire temperature in Celsius.. The unit of this type is celsius"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, side)"]
                        pub fn value(
                            &self,
                        ) -> (&crate::v2::units::Celsius<f32>, &u8, &crate::v2::Side)
                        {
                            (&self.v, &self.row, &self.side)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Tire temperature in Celsius.. The unit of this type is celsius"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: crate::v2::units::Celsius<f32>,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            side: crate::v2::Side,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.row = row;
                            self.side = side;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &crate::v2::units::Celsius<f32>) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: crate::v2::units::Celsius<f32>,
                            timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            side: crate::v2::Side,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    side,
                                })
                            } else {
                                None
                            }
                        }
                    }
                }
                #[allow(non_snake_case)]
                pub mod left {}
            }
        }
    }
    #[allow(non_snake_case)]
    pub mod adas {
        #[allow(non_snake_case)]
        pub mod esc {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Indicates if ECS is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsActive {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsActive {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if ECS is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if ECS is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates if ESC incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Error {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl Error {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if ESC incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if ESC incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates if ESC is currently regulating vehicle stability. True = Engaged. False = Not Engaged.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsEngaged {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsEngaged {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if ESC is currently regulating vehicle stability. True = Engaged. False = Not Engaged.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if ESC is currently regulating vehicle stability. True = Engaged. False = Not Engaged.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod tcs {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Indicates if TCS is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsActive {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsActive {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if TCS is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if TCS is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates if TCS incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Error {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl Error {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if TCS incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if TCS incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates if TCS is currently regulating traction. True = Engaged. False = Not Engaged.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsEngaged {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsEngaged {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if TCS is currently regulating traction. True = Engaged. False = Not Engaged.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if TCS is currently regulating traction. True = Engaged. False = Not Engaged.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod abs {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Indicates if ABS is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsActive {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsActive {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if ABS is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if ABS is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates if ABS incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Error {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl Error {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if ABS incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if ABS incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates if ABS is currently regulating brake pressure. True = Engaged. False = Not Engaged.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsEngaged {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsEngaged {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if ABS is currently regulating brake pressure. True = Engaged. False = Not Engaged.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if ABS is currently regulating brake pressure. True = Engaged. False = Not Engaged.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod obstacledetection {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Indicates if obstacle sensor system is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsActive {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsActive {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if obstacle sensor system is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if obstacle sensor system is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates if obstacle sensor system incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Error {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl Error {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if obstacle sensor system incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if obstacle sensor system incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod lanedeparturedetection {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Indicates if lane departure detection system is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsActive {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsActive {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if lane departure detection system is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if lane departure detection system is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates if lane departure detection registered a lane departure. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Warning {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl Warning {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if lane departure detection registered a lane departure. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if lane departure detection registered a lane departure. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates if lane departure system incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Error {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl Error {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if lane departure system incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if lane departure system incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod cruisecontrol {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Indicates if cruise control system is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsActive {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsActive {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if cruise control system is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if cruise control system is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Set cruise control speed in kilometers per hour. The unit of this type is km/h"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct SpeedSet {
                v: crate::v2::units::KilometrePerHour<f32>,
                timestamp: crate::v2::Timestamp,
            }
            impl SpeedSet {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Set cruise control speed in kilometers per hour. The unit of this type is km/h"]
                pub fn value(&self) -> &crate::v2::units::KilometrePerHour<f32> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Set cruise control speed in kilometers per hour. The unit of this type is km/h"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::KilometrePerHour<f32>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::KilometrePerHour<f32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::KilometrePerHour<f32>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates if cruise control system incurred and error condition. True = Error. False = NoError.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Error {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl Error {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if cruise control system incurred and error condition. True = Error. False = NoError.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if cruise control system incurred and error condition. True = Error. False = NoError.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
    }
    #[allow(non_snake_case)]
    pub mod cabin {
        use cdds_derive::Topic;
        use cyclonedds_rs::*;
        #[doc = "Number of doors in vehicle. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct DoorCount {
            v: u8,
        }
        impl DoorCount {
            #[doc = r" Get the "]
            #[doc = "Number of doors in vehicle. This type has no unit defined"]
            pub fn value(&self) -> &u8 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Number of doors in vehicle. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u8) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u8) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u8) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "The position of the driver seat in row 1.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct DriverPosition {
            v: u8,
        }
        impl DriverPosition {
            #[doc = r" Get the "]
            #[doc = "The position of the driver seat in row 1.. This type has no unit defined"]
            pub fn value(&self) -> &u8 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "The position of the driver seat in row 1.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u8) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u8) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u8) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "Number of seat rows in vehicle. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct SeatRowCount {
            v: u8,
        }
        impl SeatRowCount {
            #[doc = r" Get the "]
            #[doc = "Number of seat rows in vehicle. This type has no unit defined"]
            pub fn value(&self) -> &u8 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Number of seat rows in vehicle. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u8) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u8) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u8) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "Number of seats across each row from the front to the rear. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct SeatPosCount {
            v: Vec<u8>,
        }
        impl SeatPosCount {
            #[doc = r" Get the "]
            #[doc = "Number of seats across each row from the front to the rear. This type has no unit defined"]
            pub fn value(&self) -> &Vec<u8> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Number of seats across each row from the front to the rear. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: Vec<u8>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &Vec<u8>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: Vec<u8>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod convertible {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Roof status on convertible vehicles. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Status {
                v: String,
                timestamp: crate::v2::Timestamp,
            }
            impl Status {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Roof status on convertible vehicles. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Roof status on convertible vehicles. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: String,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod seat {
            #[allow(non_snake_case)]
            pub mod occupant {
                #[allow(non_snake_case)]
                pub mod identifier {
                    use cdds_derive::Topic;
                    use cyclonedds_rs::*;
                    #[doc = "Subject for the authentification of the occupant. E.g. UserID 7331677. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Subject {
                        v: String,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key]
                        row: u8,
                        #[topic_key]
                        pos: u8,
                    }
                    impl Subject {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Subject for the authentification of the occupant. E.g. UserID 7331677. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, pos)"]
                        pub fn value(&self) -> (&String, &u8, &u8) {
                            (&self.v, &self.row, &self.pos)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Subject for the authentification of the occupant. E.g. UserID 7331677. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: String,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.row = row;
                            self.pos = pos;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &String) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: String,
                            timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    pos,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Unique Issuer for the authentification of the occupant. E.g. https://accounts.funcorp.com. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Issuer {
                        v: String,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key]
                        row: u8,
                        #[topic_key]
                        pos: u8,
                    }
                    impl Issuer {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Unique Issuer for the authentification of the occupant. E.g. https://accounts.funcorp.com. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, pos)"]
                        pub fn value(&self) -> (&String, &u8, &u8) {
                            (&self.v, &self.row, &self.pos)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Unique Issuer for the authentification of the occupant. E.g. https://accounts.funcorp.com. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: String,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.row = row;
                            self.pos = pos;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &String) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: String,
                            timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    pos,
                                })
                            } else {
                                None
                            }
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod cushion {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Height of the seat cushion (leg support), relative to seat. 0 = Lowermost. 500 = Uppermost.. The unit of this type is mm"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Height {
                    v: crate::v2::units::Millimetre<u16>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    row: u8,
                    #[topic_key]
                    pos: u8,
                }
                impl Height {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Height of the seat cushion (leg support), relative to seat. 0 = Lowermost. 500 = Uppermost.. The unit of this type is mm"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, pos)"]
                    pub fn value(&self) -> (&crate::v2::units::Millimetre<u16>, &u8, &u8) {
                        (&self.v, &self.row, &self.pos)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Height of the seat cushion (leg support), relative to seat. 0 = Lowermost. 500 = Uppermost.. The unit of this type is mm"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Millimetre<u16>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.row = row;
                        self.pos = pos;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v2::units::Millimetre<u16>) -> bool {
                        v.0 <= 500u16 && v.0 >= 0u16
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Millimetre<u16>,
                        timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                pos,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Forward length of cushion (leg support), relative to seat. 0 = Rearmost. 500 = Forwardmost.. The unit of this type is mm"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Length {
                    v: crate::v2::units::Millimetre<u16>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    row: u8,
                    #[topic_key]
                    pos: u8,
                }
                impl Length {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Forward length of cushion (leg support), relative to seat. 0 = Rearmost. 500 = Forwardmost.. The unit of this type is mm"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, pos)"]
                    pub fn value(&self) -> (&crate::v2::units::Millimetre<u16>, &u8, &u8) {
                        (&self.v, &self.row, &self.pos)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Forward length of cushion (leg support), relative to seat. 0 = Rearmost. 500 = Forwardmost.. The unit of this type is mm"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Millimetre<u16>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.row = row;
                        self.pos = pos;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v2::units::Millimetre<u16>) -> bool {
                        v.0 <= 500u16 && v.0 >= 0u16
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Millimetre<u16>,
                        timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                pos,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod lumbar {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Lumbar support inflation. 0 = Fully deflated. 255 = Fully inflated.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Inflation {
                    v: u8,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    row: u8,
                    #[topic_key]
                    pos: u8,
                }
                impl Inflation {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Lumbar support inflation. 0 = Fully deflated. 255 = Fully inflated.. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, pos)"]
                    pub fn value(&self) -> (&u8, &u8, &u8) {
                        (&self.v, &self.row, &self.pos)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Lumbar support inflation. 0 = Fully deflated. 255 = Fully inflated.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: u8,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.row = row;
                        self.pos = pos;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &u8) -> bool {
                        *v <= 255u8 && *v >= 0u8
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: u8,
                        timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                pos,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Lumbar support position. 0 = Lowermost. 255 = Uppermost.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Height {
                    v: u8,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    row: u8,
                    #[topic_key]
                    pos: u8,
                }
                impl Height {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Lumbar support position. 0 = Lowermost. 255 = Uppermost.. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, pos)"]
                    pub fn value(&self) -> (&u8, &u8, &u8) {
                        (&self.v, &self.row, &self.pos)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Lumbar support position. 0 = Lowermost. 255 = Uppermost.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: u8,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.row = row;
                        self.pos = pos;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &u8) -> bool {
                        *v <= 255u8 && *v >= 0u8
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: u8,
                        timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                pos,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod sidebolster {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Side bolster support inflation. 0 = Fully deflated. 255 = Fully inflated.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Inflation {
                    v: u8,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    row: u8,
                    #[topic_key]
                    pos: u8,
                }
                impl Inflation {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Side bolster support inflation. 0 = Fully deflated. 255 = Fully inflated.. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, pos)"]
                    pub fn value(&self) -> (&u8, &u8, &u8) {
                        (&self.v, &self.row, &self.pos)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Side bolster support inflation. 0 = Fully deflated. 255 = Fully inflated.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: u8,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.row = row;
                        self.pos = pos;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &u8) -> bool {
                        *v <= 255u8 && *v >= 0u8
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: u8,
                        timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                pos,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod headrestraint {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Height of head restraint. 0 = Bottommost. 255 = Uppermost.. The unit of this type is mm"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Height {
                    v: crate::v2::units::Millimetre<u8>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    row: u8,
                    #[topic_key]
                    pos: u8,
                }
                impl Height {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Height of head restraint. 0 = Bottommost. 255 = Uppermost.. The unit of this type is mm"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, pos)"]
                    pub fn value(&self) -> (&crate::v2::units::Millimetre<u8>, &u8, &u8) {
                        (&self.v, &self.row, &self.pos)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Height of head restraint. 0 = Bottommost. 255 = Uppermost.. The unit of this type is mm"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Millimetre<u8>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.row = row;
                        self.pos = pos;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v2::units::Millimetre<u8>) -> bool {
                        v.0 <= 255u8 && v.0 >= 0u8
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Millimetre<u8>,
                        timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                pos,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod airbag {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Airbag deployment status. True = Airbag deployed. False = Airbag not deployed.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct IsDeployed {
                    v: bool,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    row: u8,
                    #[topic_key]
                    pos: u8,
                }
                impl IsDeployed {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Airbag deployment status. True = Airbag deployed. False = Airbag not deployed.. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, pos)"]
                    pub fn value(&self) -> (&bool, &u8, &u8) {
                        (&self.v, &self.row, &self.pos)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Airbag deployment status. True = Airbag deployed. False = Airbag not deployed.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.row = row;
                        self.pos = pos;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                pos,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod switch {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Warmer switch for Seat heater (SingleSeat.Heating). This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Warmer {
                    v: bool,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    row: u8,
                    #[topic_key]
                    pos: u8,
                }
                impl Warmer {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Warmer switch for Seat heater (SingleSeat.Heating). This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, pos)"]
                    pub fn value(&self) -> (&bool, &u8, &u8) {
                        (&self.v, &self.row, &self.pos)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Warmer switch for Seat heater (SingleSeat.Heating). This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.row = row;
                        self.pos = pos;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                pos,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Cooler switch for Seat heater (SingleSeat.Heating). This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Cooler {
                    v: bool,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    row: u8,
                    #[topic_key]
                    pos: u8,
                }
                impl Cooler {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Cooler switch for Seat heater (SingleSeat.Heating). This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, pos)"]
                    pub fn value(&self) -> (&bool, &u8, &u8) {
                        (&self.v, &self.row, &self.pos)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Cooler switch for Seat heater (SingleSeat.Heating). This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.row = row;
                        self.pos = pos;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                pos,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Seat forward switch engaged (SingleSeat.Position). This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Forward {
                    v: bool,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    row: u8,
                    #[topic_key]
                    pos: u8,
                }
                impl Forward {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Seat forward switch engaged (SingleSeat.Position). This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, pos)"]
                    pub fn value(&self) -> (&bool, &u8, &u8) {
                        (&self.v, &self.row, &self.pos)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Seat forward switch engaged (SingleSeat.Position). This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.row = row;
                        self.pos = pos;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                pos,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Seat backward switch engaged (SingleSeat.Position). This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Backward {
                    v: bool,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    row: u8,
                    #[topic_key]
                    pos: u8,
                }
                impl Backward {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Seat backward switch engaged (SingleSeat.Position). This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, pos)"]
                    pub fn value(&self) -> (&bool, &u8, &u8) {
                        (&self.v, &self.row, &self.pos)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Seat backward switch engaged (SingleSeat.Position). This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.row = row;
                        self.pos = pos;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                pos,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Seat up switch engaged (SingleSeat.Height). This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Up {
                    v: bool,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    row: u8,
                    #[topic_key]
                    pos: u8,
                }
                impl Up {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Seat up switch engaged (SingleSeat.Height). This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, pos)"]
                    pub fn value(&self) -> (&bool, &u8, &u8) {
                        (&self.v, &self.row, &self.pos)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Seat up switch engaged (SingleSeat.Height). This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.row = row;
                        self.pos = pos;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                pos,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Seat down switch engaged (SingleSeat.Height). This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Down {
                    v: bool,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    row: u8,
                    #[topic_key]
                    pos: u8,
                }
                impl Down {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Seat down switch engaged (SingleSeat.Height). This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, pos)"]
                    pub fn value(&self) -> (&bool, &u8, &u8) {
                        (&self.v, &self.row, &self.pos)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Seat down switch engaged (SingleSeat.Height). This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.row = row;
                        self.pos = pos;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                pos,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[allow(non_snake_case)]
                pub mod sidebolster {
                    use cdds_derive::Topic;
                    use cyclonedds_rs::*;
                    #[doc = "Side bolster inflation switch engaged (SingleSeat.SideBolster.Inflation). This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Inflate {
                        v: bool,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key]
                        row: u8,
                        #[topic_key]
                        pos: u8,
                    }
                    impl Inflate {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Side bolster inflation switch engaged (SingleSeat.SideBolster.Inflation). This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, pos)"]
                        pub fn value(&self) -> (&bool, &u8, &u8) {
                            (&self.v, &self.row, &self.pos)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Side bolster inflation switch engaged (SingleSeat.SideBolster.Inflation). This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.row = row;
                            self.pos = pos;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    pos,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Side bolster deflation switch engaged (SingleSeat.SideBolster.Inflation). This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Deflate {
                        v: bool,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key]
                        row: u8,
                        #[topic_key]
                        pos: u8,
                    }
                    impl Deflate {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Side bolster deflation switch engaged (SingleSeat.SideBolster.Inflation). This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, pos)"]
                        pub fn value(&self) -> (&bool, &u8, &u8) {
                            (&self.v, &self.row, &self.pos)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Side bolster deflation switch engaged (SingleSeat.SideBolster.Inflation). This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.row = row;
                            self.pos = pos;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    pos,
                                })
                            } else {
                                None
                            }
                        }
                    }
                }
                #[allow(non_snake_case)]
                pub mod lumbar {
                    use cdds_derive::Topic;
                    use cyclonedds_rs::*;
                    #[doc = "Lumbar up switch engaged (SingleSeat.Lumbar.Height). This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Up {
                        v: bool,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key]
                        row: u8,
                        #[topic_key]
                        pos: u8,
                    }
                    impl Up {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Lumbar up switch engaged (SingleSeat.Lumbar.Height). This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, pos)"]
                        pub fn value(&self) -> (&bool, &u8, &u8) {
                            (&self.v, &self.row, &self.pos)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Lumbar up switch engaged (SingleSeat.Lumbar.Height). This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.row = row;
                            self.pos = pos;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    pos,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Lumbar down switch engaged (SingleSeat.Lumbar.Height). This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Down {
                        v: bool,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key]
                        row: u8,
                        #[topic_key]
                        pos: u8,
                    }
                    impl Down {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Lumbar down switch engaged (SingleSeat.Lumbar.Height). This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, pos)"]
                        pub fn value(&self) -> (&bool, &u8, &u8) {
                            (&self.v, &self.row, &self.pos)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Lumbar down switch engaged (SingleSeat.Lumbar.Height). This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.row = row;
                            self.pos = pos;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    pos,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Lumbar inflation switch engaged (SingleSeat.Lumbar.Inflation). This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Inflate {
                        v: bool,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key]
                        row: u8,
                        #[topic_key]
                        pos: u8,
                    }
                    impl Inflate {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Lumbar inflation switch engaged (SingleSeat.Lumbar.Inflation). This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, pos)"]
                        pub fn value(&self) -> (&bool, &u8, &u8) {
                            (&self.v, &self.row, &self.pos)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Lumbar inflation switch engaged (SingleSeat.Lumbar.Inflation). This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.row = row;
                            self.pos = pos;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    pos,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Lumbar deflation switch engaged (SingleSeat.Lumbar.Inflation). This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Deflate {
                        v: bool,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key]
                        row: u8,
                        #[topic_key]
                        pos: u8,
                    }
                    impl Deflate {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Lumbar deflation switch engaged (SingleSeat.Lumbar.Inflation). This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, pos)"]
                        pub fn value(&self) -> (&bool, &u8, &u8) {
                            (&self.v, &self.row, &self.pos)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Lumbar deflation switch engaged (SingleSeat.Lumbar.Inflation). This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.row = row;
                            self.pos = pos;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    pos,
                                })
                            } else {
                                None
                            }
                        }
                    }
                }
                #[allow(non_snake_case)]
                pub mod cushion {
                    use cdds_derive::Topic;
                    use cyclonedds_rs::*;
                    #[doc = "Seat cushion up switch engaged (SingleSeat.Cushion.Height). This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Up {
                        v: bool,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key]
                        row: u8,
                        #[topic_key]
                        pos: u8,
                    }
                    impl Up {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Seat cushion up switch engaged (SingleSeat.Cushion.Height). This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, pos)"]
                        pub fn value(&self) -> (&bool, &u8, &u8) {
                            (&self.v, &self.row, &self.pos)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Seat cushion up switch engaged (SingleSeat.Cushion.Height). This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.row = row;
                            self.pos = pos;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    pos,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Seat cushion down switch engaged (SingleSeat.Cushion.Height). This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Down {
                        v: bool,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key]
                        row: u8,
                        #[topic_key]
                        pos: u8,
                    }
                    impl Down {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Seat cushion down switch engaged (SingleSeat.Cushion.Height). This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, pos)"]
                        pub fn value(&self) -> (&bool, &u8, &u8) {
                            (&self.v, &self.row, &self.pos)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Seat cushion down switch engaged (SingleSeat.Cushion.Height). This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.row = row;
                            self.pos = pos;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    pos,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Seat cushion forward/lengthen switch engaged (SingleSeat.Cushion.Length). This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Forward {
                        v: bool,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key]
                        row: u8,
                        #[topic_key]
                        pos: u8,
                    }
                    impl Forward {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Seat cushion forward/lengthen switch engaged (SingleSeat.Cushion.Length). This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, pos)"]
                        pub fn value(&self) -> (&bool, &u8, &u8) {
                            (&self.v, &self.row, &self.pos)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Seat cushion forward/lengthen switch engaged (SingleSeat.Cushion.Length). This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.row = row;
                            self.pos = pos;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    pos,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Seat cushion backward/shorten switch engaged (SingleSeat.Cushion.Length). This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Backward {
                        v: bool,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key]
                        row: u8,
                        #[topic_key]
                        pos: u8,
                    }
                    impl Backward {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Seat cushion backward/shorten switch engaged (SingleSeat.Cushion.Length). This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, pos)"]
                        pub fn value(&self) -> (&bool, &u8, &u8) {
                            (&self.v, &self.row, &self.pos)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Seat cushion backward/shorten switch engaged (SingleSeat.Cushion.Length). This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.row = row;
                            self.pos = pos;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    pos,
                                })
                            } else {
                                None
                            }
                        }
                    }
                }
                #[allow(non_snake_case)]
                pub mod recline {
                    use cdds_derive::Topic;
                    use cyclonedds_rs::*;
                    #[doc = "Seatback recline backward switch engaged (SingleSeat.Recline). This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Backward {
                        v: bool,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key]
                        row: u8,
                        #[topic_key]
                        pos: u8,
                    }
                    impl Backward {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Seatback recline backward switch engaged (SingleSeat.Recline). This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, pos)"]
                        pub fn value(&self) -> (&bool, &u8, &u8) {
                            (&self.v, &self.row, &self.pos)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Seatback recline backward switch engaged (SingleSeat.Recline). This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.row = row;
                            self.pos = pos;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    pos,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Seatback recline forward switch engaged (SingleSeat.Recline). This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Forward {
                        v: bool,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key]
                        row: u8,
                        #[topic_key]
                        pos: u8,
                    }
                    impl Forward {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Seatback recline forward switch engaged (SingleSeat.Recline). This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, pos)"]
                        pub fn value(&self) -> (&bool, &u8, &u8) {
                            (&self.v, &self.row, &self.pos)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Seatback recline forward switch engaged (SingleSeat.Recline). This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.row = row;
                            self.pos = pos;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    pos,
                                })
                            } else {
                                None
                            }
                        }
                    }
                }
                #[allow(non_snake_case)]
                pub mod massage {
                    use cdds_derive::Topic;
                    use cyclonedds_rs::*;
                    #[doc = "Increase massage level switch engaged (SingleSeat.Massage). This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Increase {
                        v: bool,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key]
                        row: u8,
                        #[topic_key]
                        pos: u8,
                    }
                    impl Increase {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Increase massage level switch engaged (SingleSeat.Massage). This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, pos)"]
                        pub fn value(&self) -> (&bool, &u8, &u8) {
                            (&self.v, &self.row, &self.pos)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Increase massage level switch engaged (SingleSeat.Massage). This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.row = row;
                            self.pos = pos;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    pos,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Decrease massage level switch engaged (SingleSeat.Massage). This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Decrease {
                        v: bool,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key]
                        row: u8,
                        #[topic_key]
                        pos: u8,
                    }
                    impl Decrease {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Decrease massage level switch engaged (SingleSeat.Massage). This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, pos)"]
                        pub fn value(&self) -> (&bool, &u8, &u8) {
                            (&self.v, &self.row, &self.pos)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Decrease massage level switch engaged (SingleSeat.Massage). This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.row = row;
                            self.pos = pos;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    pos,
                                })
                            } else {
                                None
                            }
                        }
                    }
                }
                #[allow(non_snake_case)]
                pub mod headrestraint {
                    use cdds_derive::Topic;
                    use cyclonedds_rs::*;
                    #[doc = "Head restraint up switch engaged (SingleSeat.HeadRestraint.Height). This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Up {
                        v: bool,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key]
                        row: u8,
                        #[topic_key]
                        pos: u8,
                    }
                    impl Up {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Head restraint up switch engaged (SingleSeat.HeadRestraint.Height). This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, pos)"]
                        pub fn value(&self) -> (&bool, &u8, &u8) {
                            (&self.v, &self.row, &self.pos)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Head restraint up switch engaged (SingleSeat.HeadRestraint.Height). This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.row = row;
                            self.pos = pos;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    pos,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Head restraint down switch engaged (SingleSeat.HeadRestraint.Height). This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Down {
                        v: bool,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key]
                        row: u8,
                        #[topic_key]
                        pos: u8,
                    }
                    impl Down {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Head restraint down switch engaged (SingleSeat.HeadRestraint.Height). This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, pos)"]
                        pub fn value(&self) -> (&bool, &u8, &u8) {
                            (&self.v, &self.row, &self.pos)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Head restraint down switch engaged (SingleSeat.HeadRestraint.Height). This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.row = row;
                            self.pos = pos;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    pos,
                                })
                            } else {
                                None
                            }
                        }
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod door {
            #[allow(non_snake_case)]
            pub mod window {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Is window open or closed. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct isOpen {
                    v: bool,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    row: u8,
                    #[topic_key_enum]
                    side: crate::v2::Side,
                }
                impl isOpen {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Is window open or closed. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, side)"]
                    pub fn value(&self) -> (&bool, &u8, &crate::v2::Side) {
                        (&self.v, &self.row, &self.side)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Is window open or closed. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        side: crate::v2::Side,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.row = row;
                        self.side = side;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        side: crate::v2::Side,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                side,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Window position. 0 = Fully closed 100 = Fully opened.. The unit of this type is percent"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Position {
                    v: crate::v2::units::Percent<u8>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    row: u8,
                    #[topic_key_enum]
                    side: crate::v2::Side,
                }
                impl Position {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Window position. 0 = Fully closed 100 = Fully opened.. The unit of this type is percent"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, side)"]
                    pub fn value(&self) -> (&crate::v2::units::Percent<u8>, &u8, &crate::v2::Side) {
                        (&self.v, &self.row, &self.side)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Window position. 0 = Fully closed 100 = Fully opened.. The unit of this type is percent"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Percent<u8>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        side: crate::v2::Side,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.row = row;
                        self.side = side;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v2::units::Percent<u8>) -> bool {
                        v.0 <= 100u8 && v.0 >= 0u8
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Percent<u8>,
                        timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        side: crate::v2::Side,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                side,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Is window child lock engaged. True = Engaged. False = Disengaged.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct ChildLock {
                    v: bool,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    row: u8,
                    #[topic_key_enum]
                    side: crate::v2::Side,
                }
                impl ChildLock {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Is window child lock engaged. True = Engaged. False = Disengaged.. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, side)"]
                    pub fn value(&self) -> (&bool, &u8, &crate::v2::Side) {
                        (&self.v, &self.row, &self.side)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Is window child lock engaged. True = Engaged. False = Disengaged.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        side: crate::v2::Side,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.row = row;
                        self.side = side;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        side: crate::v2::Side,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                side,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Switch controlling sliding action such as window, sunroof, or blind.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Switch {
                    v: String,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    row: u8,
                    #[topic_key_enum]
                    side: crate::v2::Side,
                }
                impl Switch {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Switch controlling sliding action such as window, sunroof, or blind.. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, side)"]
                    pub fn value(&self) -> (&String, &u8, &crate::v2::Side) {
                        (&self.v, &self.row, &self.side)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Switch controlling sliding action such as window, sunroof, or blind.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        side: crate::v2::Side,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.row = row;
                        self.side = side;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        side: crate::v2::Side,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                side,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod shade {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Switch controlling sliding action such as window, sunroof, or blind.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Switch {
                    v: String,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    row: u8,
                    #[topic_key_enum]
                    side: crate::v2::Side,
                }
                impl Switch {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Switch controlling sliding action such as window, sunroof, or blind.. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, side)"]
                    pub fn value(&self) -> (&String, &u8, &crate::v2::Side) {
                        (&self.v, &self.row, &self.side)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Switch controlling sliding action such as window, sunroof, or blind.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        side: crate::v2::Side,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.row = row;
                        self.side = side;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        side: crate::v2::Side,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                side,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Position of window blind. 0 = Fully retracted. 100 = Fully deployed.. The unit of this type is percent"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Position {
                    v: crate::v2::units::Percent<u8>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    row: u8,
                    #[topic_key_enum]
                    side: crate::v2::Side,
                }
                impl Position {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Position of window blind. 0 = Fully retracted. 100 = Fully deployed.. The unit of this type is percent"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, side)"]
                    pub fn value(&self) -> (&crate::v2::units::Percent<u8>, &u8, &crate::v2::Side) {
                        (&self.v, &self.row, &self.side)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Position of window blind. 0 = Fully retracted. 100 = Fully deployed.. The unit of this type is percent"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Percent<u8>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        side: crate::v2::Side,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.row = row;
                        self.side = side;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v2::units::Percent<u8>) -> bool {
                        v.0 <= 100u8 && v.0 >= 0u8
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Percent<u8>,
                        timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        side: crate::v2::Side,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                side,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod lights {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Is glove box light on. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsGloveBoxOn {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsGloveBoxOn {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is glove box light on. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Is glove box light on. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Is trunk light light on. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsTrunkOn {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsTrunkOn {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is trunk light light on. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Is trunk light light on. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Is central dome light light on. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsDomeOn {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsDomeOn {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is central dome light light on. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Is central dome light light on. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "How much ambient light is detected in cabin. 0 = No ambient light. 100 = Full brightness. The unit of this type is percent"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct AmbientLight {
                v: crate::v2::units::Percent<u8>,
                timestamp: crate::v2::Timestamp,
            }
            impl AmbientLight {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "How much ambient light is detected in cabin. 0 = No ambient light. 100 = Full brightness. The unit of this type is percent"]
                pub fn value(&self) -> &crate::v2::units::Percent<u8> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "How much ambient light is detected in cabin. 0 = No ambient light. 100 = Full brightness. The unit of this type is percent"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Percent<u8>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v2::units::Percent<u8>) -> bool {
                    v.0 <= 100u8 && v.0 >= 0u8
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Percent<u8>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Intensity of the interior lights. 0 = Off. 100 = Full brightness.. The unit of this type is percent"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct LightIntensity {
                v: crate::v2::units::Percent<u8>,
                timestamp: crate::v2::Timestamp,
            }
            impl LightIntensity {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Intensity of the interior lights. 0 = Off. 100 = Full brightness.. The unit of this type is percent"]
                pub fn value(&self) -> &crate::v2::units::Percent<u8> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Intensity of the interior lights. 0 = Off. 100 = Full brightness.. The unit of this type is percent"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Percent<u8>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v2::units::Percent<u8>) -> bool {
                    v.0 <= 100u8 && v.0 >= 0u8
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Percent<u8>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod spotlight {}
        }
        #[allow(non_snake_case)]
        pub mod rearviewmirror {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Dimming level of rearview mirror. 0 = undimmed. 100 = fully dimmed. The unit of this type is percent"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct DimmingLevel {
                v: crate::v2::units::Percent<u8>,
                timestamp: crate::v2::Timestamp,
            }
            impl DimmingLevel {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Dimming level of rearview mirror. 0 = undimmed. 100 = fully dimmed. The unit of this type is percent"]
                pub fn value(&self) -> &crate::v2::units::Percent<u8> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Dimming level of rearview mirror. 0 = undimmed. 100 = fully dimmed. The unit of this type is percent"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Percent<u8>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Percent<u8>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Percent<u8>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod sunroof {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Sunroof position. 0 = Fully closed 100 = Fully opened. -100 = Fully tilted. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Position {
                v: i8,
                timestamp: crate::v2::Timestamp,
            }
            impl Position {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Sunroof position. 0 = Fully closed 100 = Fully opened. -100 = Fully tilted. This type has no unit defined"]
                pub fn value(&self) -> &i8 {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Sunroof position. 0 = Fully closed 100 = Fully opened. -100 = Fully tilted. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: i8, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &i8) -> bool {
                    *v <= 100i8 && *v >= -100i8
                }
                #[doc = r" create a new instance"]
                pub fn new(value: i8, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Switch controlling sliding action such as window, sunroof, or shade.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Switch {
                v: String,
                timestamp: crate::v2::Timestamp,
            }
            impl Switch {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Switch controlling sliding action such as window, sunroof, or shade.. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Switch controlling sliding action such as window, sunroof, or shade.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: String,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod shade {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Switch controlling sliding action such as window, sunroof, or blind.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Switch {
                    v: String,
                    timestamp: crate::v2::Timestamp,
                }
                impl Switch {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Switch controlling sliding action such as window, sunroof, or blind.. This type has no unit defined"]
                    pub fn value(&self) -> &String {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Switch controlling sliding action such as window, sunroof, or blind.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Position of window blind. 0 = Fully retracted. 100 = Fully deployed.. The unit of this type is percent"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Position {
                    v: crate::v2::units::Percent<u8>,
                    timestamp: crate::v2::Timestamp,
                }
                impl Position {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Position of window blind. 0 = Fully retracted. 100 = Fully deployed.. The unit of this type is percent"]
                    pub fn value(&self) -> &crate::v2::units::Percent<u8> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Position of window blind. 0 = Fully retracted. 100 = Fully deployed.. The unit of this type is percent"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Percent<u8>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v2::units::Percent<u8>) -> bool {
                        v.0 <= 100u8 && v.0 >= 0u8
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Percent<u8>,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod infotainment {
            #[allow(non_snake_case)]
            pub mod hmi {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "ISO 639-1 standard language code for the current HMI. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct CurrentLanguage {
                    v: String,
                    timestamp: crate::v2::Timestamp,
                }
                impl CurrentLanguage {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "ISO 639-1 standard language code for the current HMI. This type has no unit defined"]
                    pub fn value(&self) -> &String {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "ISO 639-1 standard language code for the current HMI. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Date format used in the current HMI. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct DateFormat {
                    v: String,
                    timestamp: crate::v2::Timestamp,
                }
                impl DateFormat {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Date format used in the current HMI. This type has no unit defined"]
                    pub fn value(&self) -> &String {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Date format used in the current HMI. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Time format used in the current HMI. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct TimeFormat {
                    v: String,
                    timestamp: crate::v2::Timestamp,
                }
                impl TimeFormat {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Time format used in the current HMI. This type has no unit defined"]
                    pub fn value(&self) -> &String {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Time format used in the current HMI. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Distance unit used in the current HMI. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct DistanceUnit {
                    v: String,
                    timestamp: crate::v2::Timestamp,
                }
                impl DistanceUnit {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Distance unit used in the current HMI. This type has no unit defined"]
                    pub fn value(&self) -> &String {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Distance unit used in the current HMI. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Fuel economy unit used in the current HMI. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct FuelEconomyUnits {
                    v: String,
                    timestamp: crate::v2::Timestamp,
                }
                impl FuelEconomyUnits {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Fuel economy unit used in the current HMI. This type has no unit defined"]
                    pub fn value(&self) -> &String {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Fuel economy unit used in the current HMI. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "EV fuel economy unit used in the current HMI. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct EVEconomyUnits {
                    v: String,
                    timestamp: crate::v2::Timestamp,
                }
                impl EVEconomyUnits {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "EV fuel economy unit used in the current HMI. This type has no unit defined"]
                    pub fn value(&self) -> &String {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "EV fuel economy unit used in the current HMI. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Temperature unit used in the current HMI. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct TemperatureUnit {
                    v: String,
                    timestamp: crate::v2::Timestamp,
                }
                impl TemperatureUnit {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Temperature unit used in the current HMI. This type has no unit defined"]
                    pub fn value(&self) -> &String {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Temperature unit used in the current HMI. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Current display theme. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct DayNightMode {
                    v: String,
                    timestamp: crate::v2::Timestamp,
                }
                impl DayNightMode {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Current display theme. This type has no unit defined"]
                    pub fn value(&self) -> &String {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Current display theme. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod navigation {
                #[allow(non_snake_case)]
                pub mod currentlocation {
                    use cdds_derive::Topic;
                    use cyclonedds_rs::*;
                    #[doc = "Current latitude of vehicle, as reported by GPS.. The unit of this type is degrees"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Latitude {
                        v: f64,
                        timestamp: crate::v2::Timestamp,
                    }
                    impl Latitude {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Current latitude of vehicle, as reported by GPS.. The unit of this type is degrees"]
                        pub fn value(&self) -> &f64 {
                            &self.v
                        }
                        #[doc = r" Set the"]
                        #[doc = "Current latitude of vehicle, as reported by GPS.. The unit of this type is degrees"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: f64,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. Return true if the value is"]
                        #[doc = r"within bounds."]
                        pub fn bounds_check(v: &f64) -> bool {
                            *v <= 90f64 && *v >= -90f64
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: f64,
                            timestamp: Option<crate::v2::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Current longitude of vehicle, as reported by GPS.. The unit of this type is degrees"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Longitude {
                        v: f64,
                        timestamp: crate::v2::Timestamp,
                    }
                    impl Longitude {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Current longitude of vehicle, as reported by GPS.. The unit of this type is degrees"]
                        pub fn value(&self) -> &f64 {
                            &self.v
                        }
                        #[doc = r" Set the"]
                        #[doc = "Current longitude of vehicle, as reported by GPS.. The unit of this type is degrees"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: f64,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. Return true if the value is"]
                        #[doc = r"within bounds."]
                        pub fn bounds_check(v: &f64) -> bool {
                            *v <= 180f64 && *v >= -180f64
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: f64,
                            timestamp: Option<crate::v2::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Current magnetic compass heading, in degrees.. The unit of this type is degrees"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Heading {
                        v: f64,
                        timestamp: crate::v2::Timestamp,
                    }
                    impl Heading {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Current magnetic compass heading, in degrees.. The unit of this type is degrees"]
                        pub fn value(&self) -> &f64 {
                            &self.v
                        }
                        #[doc = r" Set the"]
                        #[doc = "Current magnetic compass heading, in degrees.. The unit of this type is degrees"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: f64,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. Return true if the value is"]
                        #[doc = r"within bounds."]
                        pub fn bounds_check(v: &f64) -> bool {
                            *v <= 360f64 && *v >= 0f64
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: f64,
                            timestamp: Option<crate::v2::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Accuracy level of the latitude and longitude coordinates in meters.. The unit of this type is m"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Accuracy {
                        v: crate::v2::units::Metre<f64>,
                        timestamp: crate::v2::Timestamp,
                    }
                    impl Accuracy {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Accuracy level of the latitude and longitude coordinates in meters.. The unit of this type is m"]
                        pub fn value(&self) -> &crate::v2::units::Metre<f64> {
                            &self.v
                        }
                        #[doc = r" Set the"]
                        #[doc = "Accuracy level of the latitude and longitude coordinates in meters.. The unit of this type is m"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: crate::v2::units::Metre<f64>,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &crate::v2::units::Metre<f64>) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: crate::v2::units::Metre<f64>,
                            timestamp: Option<crate::v2::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Current elevation of the position in meters.. The unit of this type is m"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Altitude {
                        v: crate::v2::units::Metre<f64>,
                        timestamp: crate::v2::Timestamp,
                    }
                    impl Altitude {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Current elevation of the position in meters.. The unit of this type is m"]
                        pub fn value(&self) -> &crate::v2::units::Metre<f64> {
                            &self.v
                        }
                        #[doc = r" Set the"]
                        #[doc = "Current elevation of the position in meters.. The unit of this type is m"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: crate::v2::units::Metre<f64>,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &crate::v2::units::Metre<f64>) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: crate::v2::units::Metre<f64>,
                            timestamp: Option<crate::v2::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Vehicle speed, as sensed by the GPS receiver.. The unit of this type is km/h"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Speed {
                        v: crate::v2::units::KilometrePerHour<u16>,
                        timestamp: crate::v2::Timestamp,
                    }
                    impl Speed {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Vehicle speed, as sensed by the GPS receiver.. The unit of this type is km/h"]
                        pub fn value(&self) -> &crate::v2::units::KilometrePerHour<u16> {
                            &self.v
                        }
                        #[doc = r" Set the"]
                        #[doc = "Vehicle speed, as sensed by the GPS receiver.. The unit of this type is km/h"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: crate::v2::units::KilometrePerHour<u16>,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. Return true if the value is"]
                        #[doc = r"within bounds."]
                        pub fn bounds_check(v: &crate::v2::units::KilometrePerHour<u16>) -> bool {
                            v.0 <= 250u16 && v.0 >= 0u16
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: crate::v2::units::KilometrePerHour<u16>,
                            timestamp: Option<crate::v2::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                }
                #[allow(non_snake_case)]
                pub mod destinationset {
                    use cdds_derive::Topic;
                    use cyclonedds_rs::*;
                    #[doc = "Latitude of destination. The unit of this type is degrees"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Latitude {
                        v: f64,
                        timestamp: crate::v2::Timestamp,
                    }
                    impl Latitude {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Latitude of destination. The unit of this type is degrees"]
                        pub fn value(&self) -> &f64 {
                            &self.v
                        }
                        #[doc = r" Set the"]
                        #[doc = "Latitude of destination. The unit of this type is degrees"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: f64,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. Return true if the value is"]
                        #[doc = r"within bounds."]
                        pub fn bounds_check(v: &f64) -> bool {
                            *v <= 90f64 && *v >= -90f64
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: f64,
                            timestamp: Option<crate::v2::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Longitude of destination. The unit of this type is degrees"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Longitude {
                        v: f64,
                        timestamp: crate::v2::Timestamp,
                    }
                    impl Longitude {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Longitude of destination. The unit of this type is degrees"]
                        pub fn value(&self) -> &f64 {
                            &self.v
                        }
                        #[doc = r" Set the"]
                        #[doc = "Longitude of destination. The unit of this type is degrees"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: f64,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. Return true if the value is"]
                        #[doc = r"within bounds."]
                        pub fn bounds_check(v: &f64) -> bool {
                            *v <= 180f64 && *v >= -180f64
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: f64,
                            timestamp: Option<crate::v2::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod media {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Tells if the media was. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Action {
                    v: String,
                    timestamp: crate::v2::Timestamp,
                }
                impl Action {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Tells if the media was. This type has no unit defined"]
                    pub fn value(&self) -> &String {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Tells if the media was. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "URI of suggested media that was declined. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct DeclinedURI {
                    v: String,
                    timestamp: crate::v2::Timestamp,
                }
                impl DeclinedURI {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "URI of suggested media that was declined. This type has no unit defined"]
                    pub fn value(&self) -> &String {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "URI of suggested media that was declined. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "URI of suggested media that was selected. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct SelectedURI {
                    v: String,
                    timestamp: crate::v2::Timestamp,
                }
                impl SelectedURI {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "URI of suggested media that was selected. This type has no unit defined"]
                    pub fn value(&self) -> &String {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "URI of suggested media that was selected. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Current Media Volume. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Volume {
                    v: u8,
                    timestamp: crate::v2::Timestamp,
                }
                impl Volume {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Current Media Volume. This type has no unit defined"]
                    pub fn value(&self) -> &u8 {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Current Media Volume. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: u8,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &u8) -> bool {
                        *v <= 100u8 && *v >= 0u8
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(value: u8, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[allow(non_snake_case)]
                pub mod played {
                    use cdds_derive::Topic;
                    use cyclonedds_rs::*;
                    #[doc = "Media selected for playback. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Source {
                        v: String,
                        timestamp: crate::v2::Timestamp,
                    }
                    impl Source {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Media selected for playback. This type has no unit defined"]
                        pub fn value(&self) -> &String {
                            &self.v
                        }
                        #[doc = r" Set the"]
                        #[doc = "Media selected for playback. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: String,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &String) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: String,
                            timestamp: Option<crate::v2::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Name of artist being played. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Artist {
                        v: String,
                        timestamp: crate::v2::Timestamp,
                    }
                    impl Artist {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Name of artist being played. This type has no unit defined"]
                        pub fn value(&self) -> &String {
                            &self.v
                        }
                        #[doc = r" Set the"]
                        #[doc = "Name of artist being played. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: String,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &String) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: String,
                            timestamp: Option<crate::v2::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Name of album being played. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Album {
                        v: String,
                        timestamp: crate::v2::Timestamp,
                    }
                    impl Album {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Name of album being played. This type has no unit defined"]
                        pub fn value(&self) -> &String {
                            &self.v
                        }
                        #[doc = r" Set the"]
                        #[doc = "Name of album being played. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: String,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &String) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: String,
                            timestamp: Option<crate::v2::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Name of track being played. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Track {
                        v: String,
                        timestamp: crate::v2::Timestamp,
                    }
                    impl Track {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Name of track being played. This type has no unit defined"]
                        pub fn value(&self) -> &String {
                            &self.v
                        }
                        #[doc = r" Set the"]
                        #[doc = "Name of track being played. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: String,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &String) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: String,
                            timestamp: Option<crate::v2::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "User Resource associated with the media. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct URI {
                        v: String,
                        timestamp: crate::v2::Timestamp,
                    }
                    impl URI {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "User Resource associated with the media. This type has no unit defined"]
                        pub fn value(&self) -> &String {
                            &self.v
                        }
                        #[doc = r" Set the"]
                        #[doc = "User Resource associated with the media. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: String,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &String) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: String,
                            timestamp: Option<crate::v2::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod hvac {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Is recirculation active.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsRecirculationActive {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsRecirculationActive {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is recirculation active.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Is recirculation active.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Is front defroster active.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsFrontDefrosterActive {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsFrontDefrosterActive {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is front defroster active.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Is front defroster active.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Is rear defroster active.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsRearDefrosterActive {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsRearDefrosterActive {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is rear defroster active.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Is rear defroster active.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Is Air conditioning active.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsAirConditioningActive {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsAirConditioningActive {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is Air conditioning active.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Is Air conditioning active.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Ambient air temperature inside the vehicle.. The unit of this type is celsius"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct AmbientAirTemperature {
                v: crate::v2::units::Celsius<f32>,
                timestamp: crate::v2::Timestamp,
            }
            impl AmbientAirTemperature {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Ambient air temperature inside the vehicle.. The unit of this type is celsius"]
                pub fn value(&self) -> &crate::v2::units::Celsius<f32> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Ambient air temperature inside the vehicle.. The unit of this type is celsius"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Celsius<f32>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Celsius<f32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Celsius<f32>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod station {}
        }
        #[allow(non_snake_case)]
        pub mod rearshade {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Switch controlling sliding action such as window, sunroof, or blind.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Switch {
                v: String,
                timestamp: crate::v2::Timestamp,
            }
            impl Switch {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Switch controlling sliding action such as window, sunroof, or blind.. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Switch controlling sliding action such as window, sunroof, or blind.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: String,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Position of window blind. 0 = Fully retracted. 100 = Fully deployed.. The unit of this type is percent"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Position {
                v: crate::v2::units::Percent<u8>,
                timestamp: crate::v2::Timestamp,
            }
            impl Position {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Position of window blind. 0 = Fully retracted. 100 = Fully deployed.. The unit of this type is percent"]
                pub fn value(&self) -> &crate::v2::units::Percent<u8> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Position of window blind. 0 = Fully retracted. 100 = Fully deployed.. The unit of this type is percent"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Percent<u8>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v2::units::Percent<u8>) -> bool {
                    v.0 <= 100u8 && v.0 >= 0u8
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Percent<u8>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
    }
    #[allow(non_snake_case)]
    pub mod body {
        use cdds_derive::Topic;
        use cyclonedds_rs::*;
        #[doc = "Body type code as defined by ISO 3779. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct BodyType {
            v: String,
        }
        impl BodyType {
            #[doc = r" Get the "]
            #[doc = "Body type code as defined by ISO 3779. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Body type code as defined by ISO 3779. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "Location of the fuel cap or charge port. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct RefuelPosition {
            v: String,
        }
        impl RefuelPosition {
            #[doc = r" Get the "]
            #[doc = "Location of the fuel cap or charge port. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Location of the fuel cap or charge port. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod chargingport {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Indicates the primary charging type fitted to the vehicle. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Type {
                v: String,
            }
            impl Type {
                #[doc = r" Get the "]
                #[doc = "Indicates the primary charging type fitted to the vehicle. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicates the primary charging type fitted to the vehicle. This type has no unit defined"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: String) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod mirrors {
            #[allow(non_snake_case)]
            pub mod heating {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Mirror Heater on or off. True = Heater On. False = Heater Off.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Status {
                    v: bool,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key_enum]
                    side: crate::v2::Side,
                }
                impl Status {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Mirror Heater on or off. True = Heater On. False = Heater Off.. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,side)"]
                    pub fn value(&self) -> (&bool, &crate::v2::Side) {
                        (&self.v, &self.side)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Mirror Heater on or off. True = Heater On. False = Heater Off.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        side: crate::v2::Side,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.side = side;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v2::Timestamp>,
                        side: crate::v2::Side,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                side,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod lights {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Is high beam on. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsHighBeamOn {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsHighBeamOn {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is high beam on. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Is high beam on. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Is low beam on. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsLowBeamOn {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsLowBeamOn {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is low beam on. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Is low beam on. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Are running lights on. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsRunningOn {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsRunningOn {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Are running lights on. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Are running lights on. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Is backup (reverse) light on. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsBackupOn {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsBackupOn {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is backup (reverse) light on. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Is backup (reverse) light on. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Is parking light on. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsParkingOn {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsParkingOn {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is parking light on. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Is parking light on. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Is brake light on. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsBrakeOn {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsBrakeOn {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is brake light on. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Is brake light on. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Is rear fog light on. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsRearFogOn {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsRearFogOn {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is rear fog light on. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Is rear fog light on. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Is front fog light on. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsFrontFogOn {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsFrontFogOn {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is front fog light on. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Is front fog light on. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Are hazards on. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsHazardOn {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsHazardOn {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Are hazards on. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Are hazards on. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Is left indicator flashing. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsLeftIndicatorOn {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsLeftIndicatorOn {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is left indicator flashing. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Is left indicator flashing. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Is right indicator flashing. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsRightIndicatorOn {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsRightIndicatorOn {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is right indicator flashing. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Is right indicator flashing. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod windshield {
            #[allow(non_snake_case)]
            pub mod wiping {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Wiper status. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Status {
                    v: String,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key_enum]
                    position: crate::v2::Position,
                }
                impl Status {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Wiper status. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,position)"]
                    pub fn value(&self) -> (&String, &crate::v2::Position) {
                        (&self.v, &self.position)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Wiper status. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        position: crate::v2::Position,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.position = position;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v2::Timestamp>,
                        position: crate::v2::Position,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                position,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod heating {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Windshield heater status. 0 - off, 1 - on. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Status {
                    v: bool,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key_enum]
                    position: crate::v2::Position,
                }
                impl Status {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Windshield heater status. 0 - off, 1 - on. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,position)"]
                    pub fn value(&self) -> (&bool, &crate::v2::Position) {
                        (&self.v, &self.position)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Windshield heater status. 0 - off, 1 - on. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        position: crate::v2::Position,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.position = position;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v2::Timestamp>,
                        position: crate::v2::Position,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                position,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod washerfluid {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Low level indication for washer fluid. True = Level Low. False = Level OK.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct LevelLow {
                    v: bool,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key_enum]
                    position: crate::v2::Position,
                }
                impl LevelLow {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Low level indication for washer fluid. True = Level Low. False = Level OK.. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,position)"]
                    pub fn value(&self) -> (&bool, &crate::v2::Position) {
                        (&self.v, &self.position)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Low level indication for washer fluid. True = Level Low. False = Level OK.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        position: crate::v2::Position,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.position = position;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v2::Timestamp>,
                        position: crate::v2::Position,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                position,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Washer fluid level as a percent. 0 = Empty. 100 = Full.. The unit of this type is percent"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Level {
                    v: crate::v2::units::Percent<u8>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key_enum]
                    position: crate::v2::Position,
                }
                impl Level {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Washer fluid level as a percent. 0 = Empty. 100 = Full.. The unit of this type is percent"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,position)"]
                    pub fn value(&self) -> (&crate::v2::units::Percent<u8>, &crate::v2::Position) {
                        (&self.v, &self.position)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Washer fluid level as a percent. 0 = Empty. 100 = Full.. The unit of this type is percent"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Percent<u8>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        position: crate::v2::Position,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.position = position;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Percent<u8>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Percent<u8>,
                        timestamp: Option<crate::v2::Timestamp>,
                        position: crate::v2::Position,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                position,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod raindetection {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Rain intensity. 0 = Dry, No Rain. 100 = Covered.. The unit of this type is percent"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct intensity {
                v: crate::v2::units::Percent<u8>,
                timestamp: crate::v2::Timestamp,
            }
            impl intensity {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Rain intensity. 0 = Dry, No Rain. 100 = Covered.. The unit of this type is percent"]
                pub fn value(&self) -> &crate::v2::units::Percent<u8> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Rain intensity. 0 = Dry, No Rain. 100 = Covered.. The unit of this type is percent"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Percent<u8>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Percent<u8>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Percent<u8>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod horn {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Horn active or inactive. True = Active. False = Inactive.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsActive {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsActive {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Horn active or inactive. True = Active. False = Inactive.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Horn active or inactive. True = Active. False = Inactive.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod trunk {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Trunk open or closed. True = Open. False = Closed. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsOpen {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsOpen {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Trunk open or closed. True = Open. False = Closed. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Trunk open or closed. True = Open. False = Closed. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Is trunk locked or unlocked. True = Locked. False = Unlocked.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsLocked {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsLocked {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is trunk locked or unlocked. True = Locked. False = Unlocked.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Is trunk locked or unlocked. True = Locked. False = Unlocked.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod hood {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "hood open or closed. True = Open. False = Closed. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsOpen {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsOpen {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "hood open or closed. True = Open. False = Closed. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "hood open or closed. True = Open. False = Closed. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
    }
    #[allow(non_snake_case)]
    pub mod powertrain {
        use cdds_derive::Topic;
        use cyclonedds_rs::*;
        #[doc = "The accumulated energy from regenerative braking over lifetime.. The unit of this type is kWh"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct AccumulatedBrakingEnergy {
            v: crate::v2::units::KilowattHour<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl AccumulatedBrakingEnergy {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "The accumulated energy from regenerative braking over lifetime.. The unit of this type is kWh"]
            pub fn value(&self) -> &crate::v2::units::KilowattHour<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "The accumulated energy from regenerative braking over lifetime.. The unit of this type is kWh"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::KilowattHour<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::KilowattHour<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::KilowattHour<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Remaining range in meters using all energy sources available in the vehicle.. The unit of this type is m"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Range {
            v: crate::v2::units::Metre<u32>,
            timestamp: crate::v2::Timestamp,
        }
        impl Range {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Remaining range in meters using all energy sources available in the vehicle.. The unit of this type is m"]
            pub fn value(&self) -> &crate::v2::units::Metre<u32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Remaining range in meters using all energy sources available in the vehicle.. The unit of this type is m"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Metre<u32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Metre<u32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Metre<u32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod fuelsystem {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Defines the fuel type of the vehicle. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct FuelType {
                v: String,
            }
            impl FuelType {
                #[doc = r" Get the "]
                #[doc = "Defines the fuel type of the vehicle. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Defines the fuel type of the vehicle. This type has no unit defined"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: String) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Defines the hybrid type of the vehicle. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct HybridType {
                v: String,
            }
            impl HybridType {
                #[doc = r" Get the "]
                #[doc = "Defines the hybrid type of the vehicle. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Defines the hybrid type of the vehicle. This type has no unit defined"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: String) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Capacity of the fuel tank in liters. The unit of this type is l"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct TankCapacity {
                v: crate::v2::units::Litre<f32>,
            }
            impl TankCapacity {
                #[doc = r" Get the "]
                #[doc = "Capacity of the fuel tank in liters. The unit of this type is l"]
                pub fn value(&self) -> &crate::v2::units::Litre<f32> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Capacity of the fuel tank in liters. The unit of this type is l"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: crate::v2::units::Litre<f32>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Litre<f32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: crate::v2::units::Litre<f32>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Level in fuel tank as percent of capacity. 0 = empty. 100 = full.. The unit of this type is percent"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Level {
                v: crate::v2::units::Percent<u8>,
                timestamp: crate::v2::Timestamp,
            }
            impl Level {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Level in fuel tank as percent of capacity. 0 = empty. 100 = full.. The unit of this type is percent"]
                pub fn value(&self) -> &crate::v2::units::Percent<u8> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Level in fuel tank as percent of capacity. 0 = empty. 100 = full.. The unit of this type is percent"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Percent<u8>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v2::units::Percent<u8>) -> bool {
                    v.0 <= 100u8 && v.0 >= 0u8
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Percent<u8>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Remaining range in meters using only liquid fuel.. The unit of this type is m"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Range {
                v: crate::v2::units::Metre<u32>,
                timestamp: crate::v2::Timestamp,
            }
            impl Range {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Remaining range in meters using only liquid fuel.. The unit of this type is m"]
                pub fn value(&self) -> &crate::v2::units::Metre<u32> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Remaining range in meters using only liquid fuel.. The unit of this type is m"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Metre<u32>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Metre<u32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Metre<u32>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Current consumption in liters per 100 km.. The unit of this type is l/100km"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct InstantConsumption {
                v: crate::v2::units::LiterPerHundredKm<f32>,
                timestamp: crate::v2::Timestamp,
            }
            impl InstantConsumption {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Current consumption in liters per 100 km.. The unit of this type is l/100km"]
                pub fn value(&self) -> &crate::v2::units::LiterPerHundredKm<f32> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Current consumption in liters per 100 km.. The unit of this type is l/100km"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::LiterPerHundredKm<f32>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v2::units::LiterPerHundredKm<f32>) -> bool {
                    true && v.0 >= 0f32
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::LiterPerHundredKm<f32>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Average consumption in liters per 100 km.. The unit of this type is l/100km"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct AverageConsumption {
                v: crate::v2::units::LiterPerHundredKm<f32>,
                timestamp: crate::v2::Timestamp,
            }
            impl AverageConsumption {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Average consumption in liters per 100 km.. The unit of this type is l/100km"]
                pub fn value(&self) -> &crate::v2::units::LiterPerHundredKm<f32> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Average consumption in liters per 100 km.. The unit of this type is l/100km"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::LiterPerHundredKm<f32>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v2::units::LiterPerHundredKm<f32>) -> bool {
                    true && v.0 >= 0f32
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::LiterPerHundredKm<f32>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Fuel amount in liters consumed since start of current trip.. The unit of this type is l"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct ConsumptionSinceStart {
                v: crate::v2::units::Litre<f32>,
                timestamp: crate::v2::Timestamp,
            }
            impl ConsumptionSinceStart {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Fuel amount in liters consumed since start of current trip.. The unit of this type is l"]
                pub fn value(&self) -> &crate::v2::units::Litre<f32> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Fuel amount in liters consumed since start of current trip.. The unit of this type is l"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Litre<f32>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Litre<f32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Litre<f32>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Time in seconds elapsed since start of current trip.. The unit of this type is s"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct TimeSinceStart {
                v: crate::v2::units::Second<u32>,
                timestamp: crate::v2::Timestamp,
            }
            impl TimeSinceStart {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Time in seconds elapsed since start of current trip.. The unit of this type is s"]
                pub fn value(&self) -> &crate::v2::units::Second<u32> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Time in seconds elapsed since start of current trip.. The unit of this type is s"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Second<u32>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Second<u32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Second<u32>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates whether eco start stop is currently enabled. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct EngineStopStartEnabled {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl EngineStopStartEnabled {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates whether eco start stop is currently enabled. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicates whether eco start stop is currently enabled. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates that the fuel level is low (e.g. <50km range). This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct LowFuelLevel {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl LowFuelLevel {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates that the fuel level is low (e.g. <50km range). This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicates that the fuel level is low (e.g. <50km range). This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod battery {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Indicating if the power (positive terminator) of the traction battery is connected to the powertrain.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct PowerConnected {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl PowerConnected {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicating if the power (positive terminator) of the traction battery is connected to the powertrain.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicating if the power (positive terminator) of the traction battery is connected to the powertrain.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicating if the ground (negative terminator) of the traction battery is connected to the powertrain.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct GroundConnected {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl GroundConnected {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicating if the ground (negative terminator) of the traction battery is connected to the powertrain.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicating if the ground (negative terminator) of the traction battery is connected to the powertrain.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Temperature of the battery pack. The unit of this type is celsius"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Temperature {
                v: crate::v2::units::Celsius<f32>,
                timestamp: crate::v2::Timestamp,
            }
            impl Temperature {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Temperature of the battery pack. The unit of this type is celsius"]
                pub fn value(&self) -> &crate::v2::units::Celsius<f32> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Temperature of the battery pack. The unit of this type is celsius"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Celsius<f32>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Celsius<f32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Celsius<f32>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Gross capacity of the battery. The unit of this type is kWh"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct GrossCapacity {
                v: crate::v2::units::KilowattHour<u16>,
            }
            impl GrossCapacity {
                #[doc = r" Get the "]
                #[doc = "Gross capacity of the battery. The unit of this type is kWh"]
                pub fn value(&self) -> &crate::v2::units::KilowattHour<u16> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Gross capacity of the battery. The unit of this type is kWh"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: crate::v2::units::KilowattHour<u16>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::KilowattHour<u16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: crate::v2::units::KilowattHour<u16>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Net capacity of the battery. The unit of this type is kWh"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct NetCapacity {
                v: crate::v2::units::KilowattHour<u16>,
            }
            impl NetCapacity {
                #[doc = r" Get the "]
                #[doc = "Net capacity of the battery. The unit of this type is kWh"]
                pub fn value(&self) -> &crate::v2::units::KilowattHour<u16> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Net capacity of the battery. The unit of this type is kWh"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: crate::v2::units::KilowattHour<u16>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::KilowattHour<u16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: crate::v2::units::KilowattHour<u16>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Nominal Voltage of the battery. The unit of this type is V"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct NominalVoltage {
                v: crate::v2::units::Volt<u16>,
            }
            impl NominalVoltage {
                #[doc = r" Get the "]
                #[doc = "Nominal Voltage of the battery. The unit of this type is V"]
                pub fn value(&self) -> &crate::v2::units::Volt<u16> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Nominal Voltage of the battery. The unit of this type is V"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: crate::v2::units::Volt<u16>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Volt<u16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: crate::v2::units::Volt<u16>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Referent Voltage of the battery. The unit of this type is V"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct ReferentVoltage {
                v: crate::v2::units::Volt<u16>,
            }
            impl ReferentVoltage {
                #[doc = r" Get the "]
                #[doc = "Referent Voltage of the battery. The unit of this type is V"]
                pub fn value(&self) -> &crate::v2::units::Volt<u16> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Referent Voltage of the battery. The unit of this type is V"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: crate::v2::units::Volt<u16>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Volt<u16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: crate::v2::units::Volt<u16>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "The accumulated energy delivered to the battery during charging over lifetime.. The unit of this type is kWh"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct AccumulatedChargedEnergy {
                v: crate::v2::units::KilowattHour<f32>,
                timestamp: crate::v2::Timestamp,
            }
            impl AccumulatedChargedEnergy {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "The accumulated energy delivered to the battery during charging over lifetime.. The unit of this type is kWh"]
                pub fn value(&self) -> &crate::v2::units::KilowattHour<f32> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "The accumulated energy delivered to the battery during charging over lifetime.. The unit of this type is kWh"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::KilowattHour<f32>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::KilowattHour<f32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::KilowattHour<f32>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "The accumulated energy leaving HV battery for propulsion and auxiliary loads over lifetime.. The unit of this type is kWh"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct AccumulatedConsumedEnergy {
                v: crate::v2::units::KilowattHour<f32>,
                timestamp: crate::v2::Timestamp,
            }
            impl AccumulatedConsumedEnergy {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "The accumulated energy leaving HV battery for propulsion and auxiliary loads over lifetime.. The unit of this type is kWh"]
                pub fn value(&self) -> &crate::v2::units::KilowattHour<f32> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "The accumulated energy leaving HV battery for propulsion and auxiliary loads over lifetime.. The unit of this type is kWh"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::KilowattHour<f32>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::KilowattHour<f32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::KilowattHour<f32>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Remaining range in meters using only battery.. The unit of this type is m"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Range {
                v: crate::v2::units::Metre<u32>,
                timestamp: crate::v2::Timestamp,
            }
            impl Range {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Remaining range in meters using only battery.. The unit of this type is m"]
                pub fn value(&self) -> &crate::v2::units::Metre<u32> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Remaining range in meters using only battery.. The unit of this type is m"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Metre<u32>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Metre<u32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Metre<u32>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod charging {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Maximum charge level for battery, can potentially be set manually.. The unit of this type is percent"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct ChargeLimit {
                    v: crate::v2::units::Percent<u8>,
                    timestamp: crate::v2::Timestamp,
                }
                impl ChargeLimit {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Maximum charge level for battery, can potentially be set manually.. The unit of this type is percent"]
                    pub fn value(&self) -> &crate::v2::units::Percent<u8> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Maximum charge level for battery, can potentially be set manually.. The unit of this type is percent"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Percent<u8>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v2::units::Percent<u8>) -> bool {
                        v.0 <= 100u8 && v.0 >= 0u8
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Percent<u8>,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Maximum charging current that can be accepted by the system.. The unit of this type is A"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct MaximumChargingCurrent {
                    v: crate::v2::units::Amp<f32>,
                    timestamp: crate::v2::Timestamp,
                }
                impl MaximumChargingCurrent {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Maximum charging current that can be accepted by the system.. The unit of this type is A"]
                    pub fn value(&self) -> &crate::v2::units::Amp<f32> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Maximum charging current that can be accepted by the system.. The unit of this type is A"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Amp<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Amp<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Amp<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Signal indicating if charge port cover is open or closed, can potentially be controlled manually.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct ChargePortFlap {
                    v: String,
                    timestamp: crate::v2::Timestamp,
                }
                impl ChargePortFlap {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Signal indicating if charge port cover is open or closed, can potentially be controlled manually.. This type has no unit defined"]
                    pub fn value(&self) -> &String {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Signal indicating if charge port cover is open or closed, can potentially be controlled manually.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Signal indicating if charge plug is connected or not.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct ChargePlugStatus {
                    v: bool,
                    timestamp: crate::v2::Timestamp,
                }
                impl ChargePlugStatus {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Signal indicating if charge plug is connected or not.. This type has no unit defined"]
                    pub fn value(&self) -> &bool {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Signal indicating if charge plug is connected or not.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Type of charge plug available on the vehicle (CSS includes Type2).. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct ChargePlugType {
                    v: String,
                }
                impl ChargePlugType {
                    #[doc = r" Get the "]
                    #[doc = "Type of charge plug available on the vehicle (CSS includes Type2).. This type has no unit defined"]
                    pub fn value(&self) -> &String {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Type of charge plug available on the vehicle (CSS includes Type2).. This type has no unit defined"]
                    #[doc = r" Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(&mut self, value: String) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(value: String) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self { v: value })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Control of the charge process - manually initiated (plug-in event, companion app, etc), timer-based or grid-controlled (eg ISO 15118).. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Mode {
                    v: String,
                    timestamp: crate::v2::Timestamp,
                }
                impl Mode {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Control of the charge process - manually initiated (plug-in event, companion app, etc), timer-based or grid-controlled (eg ISO 15118).. This type has no unit defined"]
                    pub fn value(&self) -> &String {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Control of the charge process - manually initiated (plug-in event, companion app, etc), timer-based or grid-controlled (eg ISO 15118).. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "State of charging process.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Status {
                    v: bool,
                    timestamp: crate::v2::Timestamp,
                }
                impl Status {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "State of charging process.. This type has no unit defined"]
                    pub fn value(&self) -> &bool {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "State of charging process.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Start or stop the charging process.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct StartStopCharging {
                    v: String,
                    timestamp: crate::v2::Timestamp,
                }
                impl StartStopCharging {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Start or stop the charging process.. This type has no unit defined"]
                    pub fn value(&self) -> &String {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Start or stop the charging process.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Current charging current.. The unit of this type is A"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct ChargeCurrent {
                    v: crate::v2::units::Amp<f32>,
                    timestamp: crate::v2::Timestamp,
                }
                impl ChargeCurrent {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Current charging current.. The unit of this type is A"]
                    pub fn value(&self) -> &crate::v2::units::Amp<f32> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Current charging current.. The unit of this type is A"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Amp<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Amp<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Amp<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Current charging voltage.. The unit of this type is V"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct ChargeVoltage {
                    v: crate::v2::units::Volt<f32>,
                    timestamp: crate::v2::Timestamp,
                }
                impl ChargeVoltage {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Current charging voltage.. The unit of this type is V"]
                    pub fn value(&self) -> &crate::v2::units::Volt<f32> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Current charging voltage.. The unit of this type is V"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Volt<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Volt<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Volt<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Current charging rate, as in kilometers of range added per hour.. The unit of this type is km/h"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct ChargeRate {
                    v: crate::v2::units::KilometrePerHour<f32>,
                    timestamp: crate::v2::Timestamp,
                }
                impl ChargeRate {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Current charging rate, as in kilometers of range added per hour.. The unit of this type is km/h"]
                    pub fn value(&self) -> &crate::v2::units::KilometrePerHour<f32> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Current charging rate, as in kilometers of range added per hour.. The unit of this type is km/h"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::KilometrePerHour<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::KilometrePerHour<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::KilometrePerHour<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "The time needed to complete the current charging process to the set charge limit. 0 if charging is complete, negative number if no charging process is active.. The unit of this type is s"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct TimeToComplete {
                    v: crate::v2::units::Second<u32>,
                    timestamp: crate::v2::Timestamp,
                }
                impl TimeToComplete {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "The time needed to complete the current charging process to the set charge limit. 0 if charging is complete, negative number if no charging process is active.. The unit of this type is s"]
                    pub fn value(&self) -> &crate::v2::units::Second<u32> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "The time needed to complete the current charging process to the set charge limit. 0 if charging is complete, negative number if no charging process is active.. The unit of this type is s"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Second<u32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Second<u32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Second<u32>,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[allow(non_snake_case)]
                pub mod timer {
                    use cdds_derive::Topic;
                    use cyclonedds_rs::*;
                    #[doc = "Time value for next charging-related action (Unix timestamp, seconds).. The unit of this type is s"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Time {
                        v: crate::v2::units::Second<u32>,
                        timestamp: crate::v2::Timestamp,
                    }
                    impl Time {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Time value for next charging-related action (Unix timestamp, seconds).. The unit of this type is s"]
                        pub fn value(&self) -> &crate::v2::units::Second<u32> {
                            &self.v
                        }
                        #[doc = r" Set the"]
                        #[doc = "Time value for next charging-related action (Unix timestamp, seconds).. The unit of this type is s"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: crate::v2::units::Second<u32>,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &crate::v2::units::Second<u32>) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: crate::v2::units::Second<u32>,
                            timestamp: Option<crate::v2::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Defines whether Timer.Time is defining start- or endtime of a charging action; departuretime denotes that target time should be taken from vehicle-level desired departure-time setting.. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Mode {
                        v: String,
                        timestamp: crate::v2::Timestamp,
                    }
                    impl Mode {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Defines whether Timer.Time is defining start- or endtime of a charging action; departuretime denotes that target time should be taken from vehicle-level desired departure-time setting.. This type has no unit defined"]
                        pub fn value(&self) -> &String {
                            &self.v
                        }
                        #[doc = r" Set the"]
                        #[doc = "Defines whether Timer.Time is defining start- or endtime of a charging action; departuretime denotes that target time should be taken from vehicle-level desired departure-time setting.. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: String,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &String) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: String,
                            timestamp: Option<crate::v2::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod stateofcharge {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Physical state of charge of the high voltage battery. This is not necessarily the state of charge being displayed to the customer.. The unit of this type is percent"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Current {
                    v: crate::v2::units::Percent<f32>,
                    timestamp: crate::v2::Timestamp,
                }
                impl Current {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Physical state of charge of the high voltage battery. This is not necessarily the state of charge being displayed to the customer.. The unit of this type is percent"]
                    pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Physical state of charge of the high voltage battery. This is not necessarily the state of charge being displayed to the customer.. The unit of this type is percent"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Percent<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v2::units::Percent<f32>) -> bool {
                        v.0 <= 100.0f32 && v.0 >= 0f32
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Percent<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "State of charge displayed to the customer.. The unit of this type is percent"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Displayed {
                    v: crate::v2::units::Percent<f32>,
                    timestamp: crate::v2::Timestamp,
                }
                impl Displayed {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "State of charge displayed to the customer.. The unit of this type is percent"]
                    pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "State of charge displayed to the customer.. The unit of this type is percent"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Percent<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v2::units::Percent<f32>) -> bool {
                        v.0 <= 100.0f32 && v.0 >= 0f32
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Percent<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Target state of charge set (eg. by customer).. The unit of this type is percent"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Target {
                    v: crate::v2::units::Percent<u8>,
                    timestamp: crate::v2::Timestamp,
                }
                impl Target {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Target state of charge set (eg. by customer).. The unit of this type is percent"]
                    pub fn value(&self) -> &crate::v2::units::Percent<u8> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Target state of charge set (eg. by customer).. The unit of this type is percent"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Percent<u8>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v2::units::Percent<u8>) -> bool {
                        v.0 <= 100u8 && v.0 >= 0u8
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Percent<u8>,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod electricmotor {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Peak power, in kilowatts, that motor(s) can generate.. The unit of this type is kW"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct MaxPower {
                v: crate::v2::units::Kilowatt<u16>,
            }
            impl MaxPower {
                #[doc = r" Get the "]
                #[doc = "Peak power, in kilowatts, that motor(s) can generate.. The unit of this type is kW"]
                pub fn value(&self) -> &crate::v2::units::Kilowatt<u16> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Peak power, in kilowatts, that motor(s) can generate.. The unit of this type is kW"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: crate::v2::units::Kilowatt<u16>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Kilowatt<u16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: crate::v2::units::Kilowatt<u16>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Peak power, in newton meter, that the motor(s) can generate.. The unit of this type is Nm"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct MaxTorque {
                v: crate::v2::units::NewtonMetre<u16>,
            }
            impl MaxTorque {
                #[doc = r" Get the "]
                #[doc = "Peak power, in newton meter, that the motor(s) can generate.. The unit of this type is Nm"]
                pub fn value(&self) -> &crate::v2::units::NewtonMetre<u16> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Peak power, in newton meter, that the motor(s) can generate.. The unit of this type is Nm"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: crate::v2::units::NewtonMetre<u16>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::NewtonMetre<u16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: crate::v2::units::NewtonMetre<u16>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Peak regen/brake power, in kilowatts, that motor(s) can generate.. The unit of this type is kW"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct MaxRegenPower {
                v: crate::v2::units::Kilowatt<u16>,
            }
            impl MaxRegenPower {
                #[doc = r" Get the "]
                #[doc = "Peak regen/brake power, in kilowatts, that motor(s) can generate.. The unit of this type is kW"]
                pub fn value(&self) -> &crate::v2::units::Kilowatt<u16> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Peak regen/brake power, in kilowatts, that motor(s) can generate.. The unit of this type is kW"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: crate::v2::units::Kilowatt<u16>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Kilowatt<u16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: crate::v2::units::Kilowatt<u16>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Peak regen/brake torque, in newton meter, that the motor(s) can generate.. The unit of this type is Nm"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct MaxRegenTorque {
                v: crate::v2::units::NewtonMetre<u16>,
            }
            impl MaxRegenTorque {
                #[doc = r" Get the "]
                #[doc = "Peak regen/brake torque, in newton meter, that the motor(s) can generate.. The unit of this type is Nm"]
                pub fn value(&self) -> &crate::v2::units::NewtonMetre<u16> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Peak regen/brake torque, in newton meter, that the motor(s) can generate.. The unit of this type is Nm"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: crate::v2::units::NewtonMetre<u16>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::NewtonMetre<u16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: crate::v2::units::NewtonMetre<u16>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod motor {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Motor rotational speed measured as rotations per minute. Negative values indicate reverse driving mode.. The unit of this type is rpm"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Rpm {
                    v: crate::v2::units::RPM<i32>,
                    timestamp: crate::v2::Timestamp,
                }
                impl Rpm {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Motor rotational speed measured as rotations per minute. Negative values indicate reverse driving mode.. The unit of this type is rpm"]
                    pub fn value(&self) -> &crate::v2::units::RPM<i32> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Motor rotational speed measured as rotations per minute. Negative values indicate reverse driving mode.. The unit of this type is rpm"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::RPM<i32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v2::units::RPM<i32>) -> bool {
                        v.0 <= 100000i32 && v.0 >= -100000i32
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::RPM<i32>,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Motor temperature.. The unit of this type is celsius"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Temperature {
                    v: crate::v2::units::Celsius<i16>,
                    timestamp: crate::v2::Timestamp,
                }
                impl Temperature {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Motor temperature.. The unit of this type is celsius"]
                    pub fn value(&self) -> &crate::v2::units::Celsius<i16> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Motor temperature.. The unit of this type is celsius"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Celsius<i16>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v2::units::Celsius<i16>) -> bool {
                        v.0 <= 200i16 && v.0 >= -50i16
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Celsius<i16>,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Motor coolant temperature (if applicable).. The unit of this type is celsius"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct CoolantTemperature {
                    v: crate::v2::units::Celsius<i16>,
                    timestamp: crate::v2::Timestamp,
                }
                impl CoolantTemperature {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Motor coolant temperature (if applicable).. The unit of this type is celsius"]
                    pub fn value(&self) -> &crate::v2::units::Celsius<i16> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Motor coolant temperature (if applicable).. The unit of this type is celsius"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Celsius<i16>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v2::units::Celsius<i16>) -> bool {
                        v.0 <= 200i16 && v.0 >= -50i16
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Celsius<i16>,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Current motor power output. Negative values indicate regen mode.. The unit of this type is kW"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Power {
                    v: crate::v2::units::Kilowatt<i16>,
                    timestamp: crate::v2::Timestamp,
                }
                impl Power {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Current motor power output. Negative values indicate regen mode.. The unit of this type is kW"]
                    pub fn value(&self) -> &crate::v2::units::Kilowatt<i16> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Current motor power output. Negative values indicate regen mode.. The unit of this type is kW"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Kilowatt<i16>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v2::units::Kilowatt<i16>) -> bool {
                        v.0 <= 2000i16 && v.0 >= -2000i16
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Kilowatt<i16>,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Current motor torque. Negative values indicate regen mode.. The unit of this type is Nm"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Torque {
                    v: crate::v2::units::NewtonMetre<i16>,
                    timestamp: crate::v2::Timestamp,
                }
                impl Torque {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Current motor torque. Negative values indicate regen mode.. The unit of this type is Nm"]
                    pub fn value(&self) -> &crate::v2::units::NewtonMetre<i16> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Current motor torque. Negative values indicate regen mode.. The unit of this type is Nm"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::NewtonMetre<i16>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v2::units::NewtonMetre<i16>) -> bool {
                        v.0 <= 5000i16 && v.0 >= -5000i16
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::NewtonMetre<i16>,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod transmission {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Transmission type.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Type {
                v: String,
            }
            impl Type {
                #[doc = r" Get the "]
                #[doc = "Transmission type.. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Transmission type.. This type has no unit defined"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: String) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Number of forward gears in the transmission. -1 = CVT.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct GearCount {
                v: u8,
            }
            impl GearCount {
                #[doc = r" Get the "]
                #[doc = "Number of forward gears in the transmission. -1 = CVT.. This type has no unit defined"]
                pub fn value(&self) -> &u8 {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Number of forward gears in the transmission. -1 = CVT.. This type has no unit defined"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: u8) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &u8) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: u8) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Drive type.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct DriveType {
                v: String,
            }
            impl DriveType {
                #[doc = r" Get the "]
                #[doc = "Drive type.. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Drive type.. This type has no unit defined"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: String) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Vehicle speed, as sensed by the gearbox.. The unit of this type is km/h"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Speed {
                v: crate::v2::units::KilometrePerHour<i32>,
                timestamp: crate::v2::Timestamp,
            }
            impl Speed {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Vehicle speed, as sensed by the gearbox.. The unit of this type is km/h"]
                pub fn value(&self) -> &crate::v2::units::KilometrePerHour<i32> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Vehicle speed, as sensed by the gearbox.. The unit of this type is km/h"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::KilometrePerHour<i32>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v2::units::KilometrePerHour<i32>) -> bool {
                    v.0 <= 250i32 && v.0 >= -250i32
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::KilometrePerHour<i32>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Odometer reading, total distance travelled during the lifetime of the transmission.. The unit of this type is km"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct TravelledDistance {
                v: crate::v2::units::Kilometre<f32>,
                timestamp: crate::v2::Timestamp,
            }
            impl TravelledDistance {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Odometer reading, total distance travelled during the lifetime of the transmission.. The unit of this type is km"]
                pub fn value(&self) -> &crate::v2::units::Kilometre<f32> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Odometer reading, total distance travelled during the lifetime of the transmission.. The unit of this type is km"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Kilometre<f32>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Kilometre<f32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Kilometre<f32>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Current gear. 0=Neutral. -1=Reverse. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Gear {
                v: i8,
                timestamp: crate::v2::Timestamp,
            }
            impl Gear {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Current gear. 0=Neutral. -1=Reverse. This type has no unit defined"]
                pub fn value(&self) -> &i8 {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Current gear. 0=Neutral. -1=Reverse. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: i8, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &i8) -> bool {
                    *v <= 16i8 && *v >= -1i8
                }
                #[doc = r" create a new instance"]
                pub fn new(value: i8, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "The current gear. 0=Neutral, 1/2/..=Forward, -1/..=Reverse. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct CurrentGear {
                v: i8,
                timestamp: crate::v2::Timestamp,
            }
            impl CurrentGear {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "The current gear. 0=Neutral, 1/2/..=Forward, -1/..=Reverse. This type has no unit defined"]
                pub fn value(&self) -> &i8 {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "The current gear. 0=Neutral, 1/2/..=Forward, -1/..=Reverse. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: i8, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &i8) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: i8, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "The selected gear. 0=Neutral, 1/2/..=Forward, -1/..=Reverse, 126=Park, 127=Drive. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct SelectedGear {
                v: i8,
                timestamp: crate::v2::Timestamp,
            }
            impl SelectedGear {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "The selected gear. 0=Neutral, 1/2/..=Forward, -1/..=Reverse, 126=Park, 127=Drive. This type has no unit defined"]
                pub fn value(&self) -> &i8 {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "The selected gear. 0=Neutral, 1/2/..=Forward, -1/..=Reverse, 126=Park, 127=Drive. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: i8, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &i8) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: i8, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Current gearbox performance mode.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct PerformanceMode {
                v: String,
                timestamp: crate::v2::Timestamp,
            }
            impl PerformanceMode {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Current gearbox performance mode.. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Current gearbox performance mode.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: String,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Is the gearbox in automatic or manual (paddle) mode.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct GearChangeMode {
                v: String,
                timestamp: crate::v2::Timestamp,
            }
            impl GearChangeMode {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is the gearbox in automatic or manual (paddle) mode.. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Is the gearbox in automatic or manual (paddle) mode.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: String,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "The current gearbox temperature. The unit of this type is celsius"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Temperature {
                v: crate::v2::units::Celsius<i16>,
                timestamp: crate::v2::Timestamp,
            }
            impl Temperature {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "The current gearbox temperature. The unit of this type is celsius"]
                pub fn value(&self) -> &crate::v2::units::Celsius<i16> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "The current gearbox temperature. The unit of this type is celsius"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Celsius<i16>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v2::units::Celsius<i16>) -> bool {
                    v.0 <= 200i16 && v.0 >= -50i16
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Celsius<i16>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Clutch wear as a percent. 0 = no wear. 100 = worn.. The unit of this type is percent"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct ClutchWear {
                v: crate::v2::units::Percent<u8>,
                timestamp: crate::v2::Timestamp,
            }
            impl ClutchWear {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Clutch wear as a percent. 0 = no wear. 100 = worn.. The unit of this type is percent"]
                pub fn value(&self) -> &crate::v2::units::Percent<u8> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Clutch wear as a percent. 0 = no wear. 100 = worn.. The unit of this type is percent"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Percent<u8>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Percent<u8>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Percent<u8>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod combustionengine {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Displacement in cubic centimetres.. The unit of this type is cm^3"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Displacement {
                v: u16,
            }
            impl Displacement {
                #[doc = r" Get the "]
                #[doc = "Displacement in cubic centimetres.. The unit of this type is cm^3"]
                pub fn value(&self) -> &u16 {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Displacement in cubic centimetres.. The unit of this type is cm^3"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: u16) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &u16) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: u16) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Stroke length in millimetres.. The unit of this type is mm"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct StrokeLength {
                v: crate::v2::units::Millimetre<f32>,
            }
            impl StrokeLength {
                #[doc = r" Get the "]
                #[doc = "Stroke length in millimetres.. The unit of this type is mm"]
                pub fn value(&self) -> &crate::v2::units::Millimetre<f32> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Stroke length in millimetres.. The unit of this type is mm"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: crate::v2::units::Millimetre<f32>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Millimetre<f32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: crate::v2::units::Millimetre<f32>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Bore in millimetres.. The unit of this type is mm"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Bore {
                v: crate::v2::units::Millimetre<f32>,
            }
            impl Bore {
                #[doc = r" Get the "]
                #[doc = "Bore in millimetres.. The unit of this type is mm"]
                pub fn value(&self) -> &crate::v2::units::Millimetre<f32> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Bore in millimetres.. The unit of this type is mm"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: crate::v2::units::Millimetre<f32>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Millimetre<f32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: crate::v2::units::Millimetre<f32>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Engine configuration.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Configuration {
                v: String,
            }
            impl Configuration {
                #[doc = r" Get the "]
                #[doc = "Engine configuration.. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Engine configuration.. This type has no unit defined"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: String) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Number of cylinders.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct NumberOfCylinders {
                v: u16,
            }
            impl NumberOfCylinders {
                #[doc = r" Get the "]
                #[doc = "Number of cylinders.. This type has no unit defined"]
                pub fn value(&self) -> &u16 {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Number of cylinders.. This type has no unit defined"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: u16) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &u16) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: u16) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Number of valves per cylinder.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct NumberOfValvesPerCylinder {
                v: u16,
            }
            impl NumberOfValvesPerCylinder {
                #[doc = r" Get the "]
                #[doc = "Number of valves per cylinder.. This type has no unit defined"]
                pub fn value(&self) -> &u16 {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Number of valves per cylinder.. This type has no unit defined"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: u16) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &u16) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: u16) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Engine compression ratio.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct CompressionRatio {
                v: String,
            }
            impl CompressionRatio {
                #[doc = r" Get the "]
                #[doc = "Engine compression ratio.. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Engine compression ratio.. This type has no unit defined"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: String) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Vehicle oil level.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct EngineOilLevel {
                v: String,
            }
            impl EngineOilLevel {
                #[doc = r" Get the "]
                #[doc = "Vehicle oil level.. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Vehicle oil level.. This type has no unit defined"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: String) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Remaining engine oil life in seconds. Negative values can be used to indicate that lifetime has been exceeded.. The unit of this type is s"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct OilLifeRemaining {
                v: crate::v2::units::Second<i32>,
                timestamp: crate::v2::Timestamp,
            }
            impl OilLifeRemaining {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Remaining engine oil life in seconds. Negative values can be used to indicate that lifetime has been exceeded.. The unit of this type is s"]
                pub fn value(&self) -> &crate::v2::units::Second<i32> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Remaining engine oil life in seconds. Negative values can be used to indicate that lifetime has been exceeded.. The unit of this type is s"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Second<i32>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Second<i32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Second<i32>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Engine oil capacity in liters.. The unit of this type is l"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct EngineOilCapacity {
                v: crate::v2::units::Litre<f32>,
            }
            impl EngineOilCapacity {
                #[doc = r" Get the "]
                #[doc = "Engine oil capacity in liters.. The unit of this type is l"]
                pub fn value(&self) -> &crate::v2::units::Litre<f32> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Engine oil capacity in liters.. The unit of this type is l"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: crate::v2::units::Litre<f32>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Litre<f32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: crate::v2::units::Litre<f32>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Engine coolant capacity in liters.. The unit of this type is l"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct EngineCoolantCapacity {
                v: crate::v2::units::Litre<f32>,
            }
            impl EngineCoolantCapacity {
                #[doc = r" Get the "]
                #[doc = "Engine coolant capacity in liters.. The unit of this type is l"]
                pub fn value(&self) -> &crate::v2::units::Litre<f32> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Engine coolant capacity in liters.. The unit of this type is l"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: crate::v2::units::Litre<f32>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Litre<f32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: crate::v2::units::Litre<f32>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Peak power, in kilowatts, that engine can generate.. The unit of this type is kW"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct MaxPower {
                v: crate::v2::units::Kilowatt<u16>,
            }
            impl MaxPower {
                #[doc = r" Get the "]
                #[doc = "Peak power, in kilowatts, that engine can generate.. The unit of this type is kW"]
                pub fn value(&self) -> &crate::v2::units::Kilowatt<u16> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Peak power, in kilowatts, that engine can generate.. The unit of this type is kW"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: crate::v2::units::Kilowatt<u16>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Kilowatt<u16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: crate::v2::units::Kilowatt<u16>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Peak power, in newton meter, that the engine can generate.. The unit of this type is Nm"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct MaxTorque {
                v: crate::v2::units::NewtonMetre<u16>,
            }
            impl MaxTorque {
                #[doc = r" Get the "]
                #[doc = "Peak power, in newton meter, that the engine can generate.. The unit of this type is Nm"]
                pub fn value(&self) -> &crate::v2::units::NewtonMetre<u16> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Peak power, in newton meter, that the engine can generate.. The unit of this type is Nm"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: crate::v2::units::NewtonMetre<u16>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::NewtonMetre<u16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: crate::v2::units::NewtonMetre<u16>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Type of aspiration (natural, turbocharger, supercharger etc).. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct AspirationType {
                v: String,
            }
            impl AspirationType {
                #[doc = r" Get the "]
                #[doc = "Type of aspiration (natural, turbocharger, supercharger etc).. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Type of aspiration (natural, turbocharger, supercharger etc).. This type has no unit defined"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: String) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Type of fuel that the engine runs on.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct FuelType {
                v: String,
            }
            impl FuelType {
                #[doc = r" Get the "]
                #[doc = "Type of fuel that the engine runs on.. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Type of fuel that the engine runs on.. This type has no unit defined"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: String) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod dieselparticulatefilter {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Inlet temperature of Diesel Particulate Filter.. The unit of this type is celsius"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct InletTemperature {
                    v: crate::v2::units::Celsius<f32>,
                    timestamp: crate::v2::Timestamp,
                }
                impl InletTemperature {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Inlet temperature of Diesel Particulate Filter.. The unit of this type is celsius"]
                    pub fn value(&self) -> &crate::v2::units::Celsius<f32> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Inlet temperature of Diesel Particulate Filter.. The unit of this type is celsius"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Celsius<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Celsius<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Celsius<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Outlet temperature of Diesel Particulate Filter.. The unit of this type is celsius"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct OutletTemperature {
                    v: crate::v2::units::Celsius<f32>,
                    timestamp: crate::v2::Timestamp,
                }
                impl OutletTemperature {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Outlet temperature of Diesel Particulate Filter.. The unit of this type is celsius"]
                    pub fn value(&self) -> &crate::v2::units::Celsius<f32> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Outlet temperature of Diesel Particulate Filter.. The unit of this type is celsius"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Celsius<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Celsius<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Celsius<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Delta Pressure of Diesel Particulate Filter.. The unit of this type is Pa"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct DeltaPressure {
                    v: crate::v2::units::Pascal<f32>,
                    timestamp: crate::v2::Timestamp,
                }
                impl DeltaPressure {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Delta Pressure of Diesel Particulate Filter.. The unit of this type is Pa"]
                    pub fn value(&self) -> &crate::v2::units::Pascal<f32> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Delta Pressure of Diesel Particulate Filter.. The unit of this type is Pa"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Pascal<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Pascal<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Pascal<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod engine {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Engine speed measured as rotations per minute.. The unit of this type is rpm"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Speed {
                    v: crate::v2::units::RPM<u16>,
                    timestamp: crate::v2::Timestamp,
                }
                impl Speed {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Engine speed measured as rotations per minute.. The unit of this type is rpm"]
                    pub fn value(&self) -> &crate::v2::units::RPM<u16> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Engine speed measured as rotations per minute.. The unit of this type is rpm"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::RPM<u16>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v2::units::RPM<u16>) -> bool {
                        v.0 <= 20000u16 && v.0 >= 0u16
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::RPM<u16>,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Engine coolant temperature.. The unit of this type is celsius"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct ECT {
                    v: crate::v2::units::Celsius<i16>,
                    timestamp: crate::v2::Timestamp,
                }
                impl ECT {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Engine coolant temperature.. The unit of this type is celsius"]
                    pub fn value(&self) -> &crate::v2::units::Celsius<i16> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Engine coolant temperature.. The unit of this type is celsius"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Celsius<i16>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v2::units::Celsius<i16>) -> bool {
                        v.0 <= 200i16 && v.0 >= -50i16
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Celsius<i16>,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Engine oil temperature.. The unit of this type is celsius"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct EOT {
                    v: crate::v2::units::Celsius<i16>,
                    timestamp: crate::v2::Timestamp,
                }
                impl EOT {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Engine oil temperature.. The unit of this type is celsius"]
                    pub fn value(&self) -> &crate::v2::units::Celsius<i16> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Engine oil temperature.. The unit of this type is celsius"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Celsius<i16>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v2::units::Celsius<i16>) -> bool {
                        v.0 <= 300i16 && v.0 >= -50i16
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Celsius<i16>,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Manifold air pressure possibly boosted using forced induction.. The unit of this type is kPa"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct MAP {
                    v: crate::v2::units::KiloPascal<i16>,
                    timestamp: crate::v2::Timestamp,
                }
                impl MAP {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Manifold air pressure possibly boosted using forced induction.. The unit of this type is kPa"]
                    pub fn value(&self) -> &crate::v2::units::KiloPascal<i16> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Manifold air pressure possibly boosted using forced induction.. The unit of this type is kPa"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::KiloPascal<i16>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v2::units::KiloPascal<i16>) -> bool {
                        v.0 <= 1000i16 && v.0 >= 0i16
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::KiloPascal<i16>,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Grams of air drawn into engine per second.. The unit of this type is g/s"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct MAF {
                    v: crate::v2::units::GramPerSec<i16>,
                    timestamp: crate::v2::Timestamp,
                }
                impl MAF {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Grams of air drawn into engine per second.. The unit of this type is g/s"]
                    pub fn value(&self) -> &crate::v2::units::GramPerSec<i16> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Grams of air drawn into engine per second.. The unit of this type is g/s"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::GramPerSec<i16>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v2::units::GramPerSec<i16>) -> bool {
                        v.0 <= 3000i16 && v.0 >= 0i16
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::GramPerSec<i16>,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Current throttle position.. The unit of this type is percent"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct TPS {
                    v: crate::v2::units::Percent<i8>,
                    timestamp: crate::v2::Timestamp,
                }
                impl TPS {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Current throttle position.. The unit of this type is percent"]
                    pub fn value(&self) -> &crate::v2::units::Percent<i8> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Current throttle position.. The unit of this type is percent"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Percent<i8>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v2::units::Percent<i8>) -> bool {
                        v.0 <= 100i8 && v.0 >= 0i8
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Percent<i8>,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Engine oil pressure.. The unit of this type is kPa"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct EOP {
                    v: crate::v2::units::KiloPascal<i16>,
                    timestamp: crate::v2::Timestamp,
                }
                impl EOP {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Engine oil pressure.. The unit of this type is kPa"]
                    pub fn value(&self) -> &crate::v2::units::KiloPascal<i16> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Engine oil pressure.. The unit of this type is kPa"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::KiloPascal<i16>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v2::units::KiloPascal<i16>) -> bool {
                        v.0 <= 1000i16 && v.0 >= 0i16
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::KiloPascal<i16>,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Current engine power output.. The unit of this type is kW"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Power {
                    v: crate::v2::units::Kilowatt<i16>,
                    timestamp: crate::v2::Timestamp,
                }
                impl Power {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Current engine power output.. The unit of this type is kW"]
                    pub fn value(&self) -> &crate::v2::units::Kilowatt<i16> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Current engine power output.. The unit of this type is kW"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Kilowatt<i16>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v2::units::Kilowatt<i16>) -> bool {
                        v.0 <= 2000i16 && v.0 >= 0i16
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Kilowatt<i16>,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Current engine torque.. The unit of this type is Nm"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Torque {
                    v: crate::v2::units::NewtonMetre<i16>,
                    timestamp: crate::v2::Timestamp,
                }
                impl Torque {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Current engine torque.. The unit of this type is Nm"]
                    pub fn value(&self) -> &crate::v2::units::NewtonMetre<i16> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Current engine torque.. The unit of this type is Nm"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::NewtonMetre<i16>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v2::units::NewtonMetre<i16>) -> bool {
                        v.0 <= 3000i16 && v.0 >= 0i16
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::NewtonMetre<i16>,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
            }
        }
    }
    #[allow(non_snake_case)]
    pub mod currentlocation {
        use cdds_derive::Topic;
        use cyclonedds_rs::*;
        #[doc = "Current latitude of vehicle.. The unit of this type is degrees"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Latitude {
            v: f64,
            timestamp: crate::v2::Timestamp,
        }
        impl Latitude {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Current latitude of vehicle.. The unit of this type is degrees"]
            pub fn value(&self) -> &f64 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Current latitude of vehicle.. The unit of this type is degrees"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: f64, maybe_timestamp: Option<crate::v2::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. Return true if the value is"]
            #[doc = r"within bounds."]
            pub fn bounds_check(v: &f64) -> bool {
                *v <= 90f64 && *v >= -90f64
            }
            #[doc = r" create a new instance"]
            pub fn new(value: f64, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Current longitude of vehicle.. The unit of this type is degrees"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Longitude {
            v: f64,
            timestamp: crate::v2::Timestamp,
        }
        impl Longitude {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Current longitude of vehicle.. The unit of this type is degrees"]
            pub fn value(&self) -> &f64 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Current longitude of vehicle.. The unit of this type is degrees"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: f64, maybe_timestamp: Option<crate::v2::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. Return true if the value is"]
            #[doc = r"within bounds."]
            pub fn bounds_check(v: &f64) -> bool {
                *v <= 180f64 && *v >= -180f64
            }
            #[doc = r" create a new instance"]
            pub fn new(value: f64, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Current magnetic compass heading.. The unit of this type is degrees"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Heading {
            v: f64,
            timestamp: crate::v2::Timestamp,
        }
        impl Heading {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Current magnetic compass heading.. The unit of this type is degrees"]
            pub fn value(&self) -> &f64 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Current magnetic compass heading.. The unit of this type is degrees"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: f64, maybe_timestamp: Option<crate::v2::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. Return true if the value is"]
            #[doc = r"within bounds."]
            pub fn bounds_check(v: &f64) -> bool {
                *v <= 360f64 && *v >= 0f64
            }
            #[doc = r" create a new instance"]
            pub fn new(value: f64, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Accuracy level of the latitude and longitude coordinates.. The unit of this type is m"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Accuracy {
            v: crate::v2::units::Metre<f64>,
            timestamp: crate::v2::Timestamp,
        }
        impl Accuracy {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Accuracy level of the latitude and longitude coordinates.. The unit of this type is m"]
            pub fn value(&self) -> &crate::v2::units::Metre<f64> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Accuracy level of the latitude and longitude coordinates.. The unit of this type is m"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Metre<f64>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Metre<f64>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Metre<f64>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Current elevation of the position.. The unit of this type is m"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Altitude {
            v: crate::v2::units::Metre<f64>,
            timestamp: crate::v2::Timestamp,
        }
        impl Altitude {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Current elevation of the position.. The unit of this type is m"]
            pub fn value(&self) -> &crate::v2::units::Metre<f64> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Current elevation of the position.. The unit of this type is m"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Metre<f64>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Metre<f64>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Metre<f64>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
    }
    #[allow(non_snake_case)]
    pub mod trailer {
        use cdds_derive::Topic;
        use cyclonedds_rs::*;
        #[doc = "Signal indicating if trailer is connected or not.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Connected {
            v: bool,
            timestamp: crate::v2::Timestamp,
        }
        impl Connected {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Signal indicating if trailer is connected or not.. This type has no unit defined"]
            pub fn value(&self) -> &bool {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Signal indicating if trailer is connected or not.. This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &bool) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
    }
    #[allow(non_snake_case)]
    pub mod angularvelocity {
        use cdds_derive::Topic;
        use cyclonedds_rs::*;
        #[doc = "Vehicle rotation rate along X (longitudinal).. The unit of this type is degrees/s"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Roll {
            v: i16,
            timestamp: crate::v2::Timestamp,
        }
        impl Roll {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Vehicle rotation rate along X (longitudinal).. The unit of this type is degrees/s"]
            pub fn value(&self) -> &i16 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Vehicle rotation rate along X (longitudinal).. The unit of this type is degrees/s"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: i16, maybe_timestamp: Option<crate::v2::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &i16) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: i16, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Vehicle rotation rate along Y (lateral).. The unit of this type is degrees/s"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Pitch {
            v: i16,
            timestamp: crate::v2::Timestamp,
        }
        impl Pitch {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Vehicle rotation rate along Y (lateral).. The unit of this type is degrees/s"]
            pub fn value(&self) -> &i16 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Vehicle rotation rate along Y (lateral).. The unit of this type is degrees/s"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: i16, maybe_timestamp: Option<crate::v2::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &i16) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: i16, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Vehicle rotation rate along Z (vertical).. The unit of this type is degrees/s"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Yaw {
            v: i16,
            timestamp: crate::v2::Timestamp,
        }
        impl Yaw {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Vehicle rotation rate along Z (vertical).. The unit of this type is degrees/s"]
            pub fn value(&self) -> &i16 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Vehicle rotation rate along Z (vertical).. The unit of this type is degrees/s"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: i16, maybe_timestamp: Option<crate::v2::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &i16) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: i16, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
    }
    #[allow(non_snake_case)]
    pub mod acceleration {
        use cdds_derive::Topic;
        use cyclonedds_rs::*;
        #[doc = "Vehicle acceleration in X (longitudinal acceleration).. The unit of this type is m/s^2"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Longitudinal {
            v: crate::v2::units::MeterPerSecondSq<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl Longitudinal {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Vehicle acceleration in X (longitudinal acceleration).. The unit of this type is m/s^2"]
            pub fn value(&self) -> &crate::v2::units::MeterPerSecondSq<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Vehicle acceleration in X (longitudinal acceleration).. The unit of this type is m/s^2"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::MeterPerSecondSq<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::MeterPerSecondSq<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::MeterPerSecondSq<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Vehicle acceleration in Y (lateral acceleration).. The unit of this type is m/s^2"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Lateral {
            v: crate::v2::units::MeterPerSecondSq<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl Lateral {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Vehicle acceleration in Y (lateral acceleration).. The unit of this type is m/s^2"]
            pub fn value(&self) -> &crate::v2::units::MeterPerSecondSq<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Vehicle acceleration in Y (lateral acceleration).. The unit of this type is m/s^2"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::MeterPerSecondSq<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::MeterPerSecondSq<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::MeterPerSecondSq<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Vehicle acceleration in Z (vertical acceleration).. The unit of this type is m/s^2"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Vertical {
            v: crate::v2::units::MeterPerSecondSq<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl Vertical {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Vehicle acceleration in Z (vertical acceleration).. The unit of this type is m/s^2"]
            pub fn value(&self) -> &crate::v2::units::MeterPerSecondSq<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Vehicle acceleration in Z (vertical acceleration).. The unit of this type is m/s^2"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::MeterPerSecondSq<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::MeterPerSecondSq<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::MeterPerSecondSq<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
    }
    #[allow(non_snake_case)]
    pub mod vehicleidentification {
        use cdds_derive::Topic;
        use cyclonedds_rs::*;
        #[doc = "17-character Vehicle Identification Number (VIN) as defined by ISO 3779. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct VIN {
            v: String,
        }
        impl VIN {
            #[doc = r" Get the "]
            #[doc = "17-character Vehicle Identification Number (VIN) as defined by ISO 3779. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "17-character Vehicle Identification Number (VIN) as defined by ISO 3779. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "3-character World Manufacturer Identification (WMI) as defined by ISO 3780. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct WMI {
            v: String,
        }
        impl WMI {
            #[doc = r" Get the "]
            #[doc = "3-character World Manufacturer Identification (WMI) as defined by ISO 3780. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "3-character World Manufacturer Identification (WMI) as defined by ISO 3780. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "Vehicle brand or manufacturer. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Brand {
            v: String,
        }
        impl Brand {
            #[doc = r" Get the "]
            #[doc = "Vehicle brand or manufacturer. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Vehicle brand or manufacturer. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "Vehicle model. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Model {
            v: String,
        }
        impl Model {
            #[doc = r" Get the "]
            #[doc = "Vehicle model. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Vehicle model. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "Model year of the vehicle. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Year {
            v: u16,
        }
        impl Year {
            #[doc = r" Get the "]
            #[doc = "Model year of the vehicle. This type has no unit defined"]
            pub fn value(&self) -> &u16 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Model year of the vehicle. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u16) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u16) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u16) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "The ACRISS Car Classification Code is a code used by many car rental companies.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct ACRISSCode {
            v: String,
        }
        impl ACRISSCode {
            #[doc = r" Get the "]
            #[doc = "The ACRISS Car Classification Code is a code used by many car rental companies.. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "The ACRISS Car Classification Code is a code used by many car rental companies.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "Indicates the design and body style of the vehicle (e.g. station wagon, hatchback, etc.).. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct bodyType {
            v: String,
        }
        impl bodyType {
            #[doc = r" Get the "]
            #[doc = "Indicates the design and body style of the vehicle (e.g. station wagon, hatchback, etc.).. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Indicates the design and body style of the vehicle (e.g. station wagon, hatchback, etc.).. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "The date of the first registration of the vehicle with the respective public authorities.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct dateVehicleFirstRegistered {
            v: String,
        }
        impl dateVehicleFirstRegistered {
            #[doc = r" Get the "]
            #[doc = "The date of the first registration of the vehicle with the respective public authorities.. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "The date of the first registration of the vehicle with the respective public authorities.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "Indicates that the vehicle meets the respective emission standard.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct meetsEmissionStandard {
            v: String,
        }
        impl meetsEmissionStandard {
            #[doc = r" Get the "]
            #[doc = "Indicates that the vehicle meets the respective emission standard.. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Indicates that the vehicle meets the respective emission standard.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "The date of production of the item, e.g. vehicle.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct productionDate {
            v: String,
        }
        impl productionDate {
            #[doc = r" Get the "]
            #[doc = "The date of production of the item, e.g. vehicle.. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "The date of production of the item, e.g. vehicle.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "The date the item e.g. vehicle was purchased by the current owner.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct purchaseDate {
            v: String,
        }
        impl purchaseDate {
            #[doc = r" Get the "]
            #[doc = "The date the item e.g. vehicle was purchased by the current owner.. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "The date the item e.g. vehicle was purchased by the current owner.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "The release date of a vehicle model (often used to differentiate versions of the same make and model).. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct vehicleModelDate {
            v: String,
        }
        impl vehicleModelDate {
            #[doc = r" Get the "]
            #[doc = "The release date of a vehicle model (often used to differentiate versions of the same make and model).. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "The release date of a vehicle model (often used to differentiate versions of the same make and model).. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "A short text indicating the configuration of the vehicle, e.g. '5dr hatchback ST 2.5 MT 225 hp' or 'limited edition'.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct vehicleConfiguration {
            v: String,
        }
        impl vehicleConfiguration {
            #[doc = r" Get the "]
            #[doc = "A short text indicating the configuration of the vehicle, e.g. '5dr hatchback ST 2.5 MT 225 hp' or 'limited edition'.. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "A short text indicating the configuration of the vehicle, e.g. '5dr hatchback ST 2.5 MT 225 hp' or 'limited edition'.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "The number of passengers that can be seated in the vehicle, both in terms of the physical space available, and in terms of limitations set by law.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct vehicleSeatingCapacity {
            v: u16,
        }
        impl vehicleSeatingCapacity {
            #[doc = r" Get the "]
            #[doc = "The number of passengers that can be seated in the vehicle, both in terms of the physical space available, and in terms of limitations set by law.. This type has no unit defined"]
            pub fn value(&self) -> &u16 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "The number of passengers that can be seated in the vehicle, both in terms of the physical space available, and in terms of limitations set by law.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u16) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u16) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u16) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "Indicates whether the vehicle has been used for special purposes, like commercial rental, driving school.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct vehicleSpecialUsage {
            v: String,
        }
        impl vehicleSpecialUsage {
            #[doc = r" Get the "]
            #[doc = "Indicates whether the vehicle has been used for special purposes, like commercial rental, driving school.. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Indicates whether the vehicle has been used for special purposes, like commercial rental, driving school.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "The color or color combination of the interior of the vehicle.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct vehicleinteriorColor {
            v: String,
        }
        impl vehicleinteriorColor {
            #[doc = r" Get the "]
            #[doc = "The color or color combination of the interior of the vehicle.. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "The color or color combination of the interior of the vehicle.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "The type or material of the interior of the vehicle (e.g. synthetic fabric, leather, wood, etc.).. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct vehicleinteriorType {
            v: String,
        }
        impl vehicleinteriorType {
            #[doc = r" Get the "]
            #[doc = "The type or material of the interior of the vehicle (e.g. synthetic fabric, leather, wood, etc.).. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "The type or material of the interior of the vehicle (e.g. synthetic fabric, leather, wood, etc.).. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "A textual description of known damages, both repaired and unrepaired.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct knownVehicleDamages {
            v: String,
        }
        impl knownVehicleDamages {
            #[doc = r" Get the "]
            #[doc = "A textual description of known damages, both repaired and unrepaired.. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "A textual description of known damages, both repaired and unrepaired.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
    }
    #[allow(non_snake_case)]
    pub mod versionvss {
        use cdds_derive::Topic;
        use cyclonedds_rs::*;
        #[doc = "Supported Version of VSS - Major version. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Major {
            v: u32,
        }
        impl Major {
            #[doc = r" Get the "]
            #[doc = "Supported Version of VSS - Major version. This type has no unit defined"]
            pub fn value(&self) -> &u32 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Supported Version of VSS - Major version. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u32) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u32) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u32) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "Supported Version of VSS - Minor version. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Minor {
            v: u32,
        }
        impl Minor {
            #[doc = r" Get the "]
            #[doc = "Supported Version of VSS - Minor version. This type has no unit defined"]
            pub fn value(&self) -> &u32 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Supported Version of VSS - Minor version. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u32) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u32) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u32) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "Supported Version of VSS - Patch version. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Patch {
            v: u32,
        }
        impl Patch {
            #[doc = r" Get the "]
            #[doc = "Supported Version of VSS - Patch version. This type has no unit defined"]
            pub fn value(&self) -> &u32 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Supported Version of VSS - Patch version. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u32) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u32) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u32) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "Label to further describe the version. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Label {
            v: String,
        }
        impl Label {
            #[doc = r" Get the "]
            #[doc = "Label to further describe the version. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Label to further describe the version. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
    }
}
