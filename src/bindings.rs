#[allow(non_snake_case)]
pub mod vehicle {
    use cdds_derive::Topic;
    use cyclonedds_rs::*;
    #[doc = "State of the supply voltage of the control units (usually 12V).. This type has no unit defined"]
    #[allow(non_camel_case_types)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct LowVoltageSystemState {
        v: String,
        timestamp: crate::v2::Timestamp,
    }
    impl LowVoltageSystemState {
        pub fn timestamp(&self) -> &crate::v2::Timestamp {
            &self.timestamp
        }
        #[doc = r" Get the "]
        #[doc = "State of the supply voltage of the control units (usually 12V).. This type has no unit defined"]
        pub fn value(&self) -> &String {
            &self.v
        }
        #[doc = r" Set the"]
        #[doc = "State of the supply voltage of the control units (usually 12V).. This type has no unit defined"]
        #[doc = r" . Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(&mut self, value: String, maybe_timestamp: Option<crate::v2::Timestamp>) {
            assert!(Self::bounds_check(&value));
            self.v = value;
            if let Some(ts) = maybe_timestamp {
                self.timestamp = ts;
            }
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &String) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(value: String, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self {
                    v: value,
                    timestamp: timestamp.unwrap_or_default(),
                })
            } else {
                None
            }
        }
    }
    #[doc = "Vehicle speed.. The unit of this type is km/h"]
    #[allow(non_camel_case_types)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct Speed {
        v: crate::v2::units::KilometrePerHour<f32>,
        timestamp: crate::v2::Timestamp,
    }
    impl Speed {
        pub fn timestamp(&self) -> &crate::v2::Timestamp {
            &self.timestamp
        }
        #[doc = r" Get the "]
        #[doc = "Vehicle speed.. The unit of this type is km/h"]
        pub fn value(&self) -> &crate::v2::units::KilometrePerHour<f32> {
            &self.v
        }
        #[doc = r" Set the"]
        #[doc = "Vehicle speed.. The unit of this type is km/h"]
        #[doc = r" . Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(
            &mut self,
            value: crate::v2::units::KilometrePerHour<f32>,
            maybe_timestamp: Option<crate::v2::Timestamp>,
        ) {
            assert!(Self::bounds_check(&value));
            self.v = value;
            if let Some(ts) = maybe_timestamp {
                self.timestamp = ts;
            }
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &crate::v2::units::KilometrePerHour<f32>) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(
            value: crate::v2::units::KilometrePerHour<f32>,
            timestamp: Option<crate::v2::Timestamp>,
        ) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self {
                    v: value,
                    timestamp: timestamp.unwrap_or_default(),
                })
            } else {
                None
            }
        }
    }
    #[doc = "Odometer reading, total distance travelled during the lifetime of the vehicle.. The unit of this type is km"]
    #[allow(non_camel_case_types)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct TravelledDistance {
        v: crate::v2::units::Kilometre<f32>,
        timestamp: crate::v2::Timestamp,
    }
    impl TravelledDistance {
        pub fn timestamp(&self) -> &crate::v2::Timestamp {
            &self.timestamp
        }
        #[doc = r" Get the "]
        #[doc = "Odometer reading, total distance travelled during the lifetime of the vehicle.. The unit of this type is km"]
        pub fn value(&self) -> &crate::v2::units::Kilometre<f32> {
            &self.v
        }
        #[doc = r" Set the"]
        #[doc = "Odometer reading, total distance travelled during the lifetime of the vehicle.. The unit of this type is km"]
        #[doc = r" . Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(
            &mut self,
            value: crate::v2::units::Kilometre<f32>,
            maybe_timestamp: Option<crate::v2::Timestamp>,
        ) {
            assert!(Self::bounds_check(&value));
            self.v = value;
            if let Some(ts) = maybe_timestamp {
                self.timestamp = ts;
            }
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &crate::v2::units::Kilometre<f32>) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(
            value: crate::v2::units::Kilometre<f32>,
            timestamp: Option<crate::v2::Timestamp>,
        ) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self {
                    v: value,
                    timestamp: timestamp.unwrap_or_default(),
                })
            } else {
                None
            }
        }
    }
    #[doc = "Current trip meter reading.. The unit of this type is km"]
    #[allow(non_camel_case_types)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct TripMeterReading {
        v: crate::v2::units::Kilometre<f32>,
        timestamp: crate::v2::Timestamp,
    }
    impl TripMeterReading {
        pub fn timestamp(&self) -> &crate::v2::Timestamp {
            &self.timestamp
        }
        #[doc = r" Get the "]
        #[doc = "Current trip meter reading.. The unit of this type is km"]
        pub fn value(&self) -> &crate::v2::units::Kilometre<f32> {
            &self.v
        }
        #[doc = r" Set the"]
        #[doc = "Current trip meter reading.. The unit of this type is km"]
        #[doc = r" . Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(
            &mut self,
            value: crate::v2::units::Kilometre<f32>,
            maybe_timestamp: Option<crate::v2::Timestamp>,
        ) {
            assert!(Self::bounds_check(&value));
            self.v = value;
            if let Some(ts) = maybe_timestamp {
                self.timestamp = ts;
            }
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &crate::v2::units::Kilometre<f32>) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(
            value: crate::v2::units::Kilometre<f32>,
            timestamp: Option<crate::v2::Timestamp>,
        ) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self {
                    v: value,
                    timestamp: timestamp.unwrap_or_default(),
                })
            } else {
                None
            }
        }
    }
    #[doc = "Vehicle breakdown or any similar event causing vehicle to stop on the road, that might pose a risk to other road users. True = Vehicle broken down on the road, due to e.g. engine problems, flat tire, out of gas, brake problems. False = Vehicle not broken down.. This type has no unit defined"]
    #[allow(non_camel_case_types)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct IsBrokenDown {
        v: bool,
        timestamp: crate::v2::Timestamp,
    }
    impl IsBrokenDown {
        pub fn timestamp(&self) -> &crate::v2::Timestamp {
            &self.timestamp
        }
        #[doc = r" Get the "]
        #[doc = "Vehicle breakdown or any similar event causing vehicle to stop on the road, that might pose a risk to other road users. True = Vehicle broken down on the road, due to e.g. engine problems, flat tire, out of gas, brake problems. False = Vehicle not broken down.. This type has no unit defined"]
        pub fn value(&self) -> &bool {
            &self.v
        }
        #[doc = r" Set the"]
        #[doc = "Vehicle breakdown or any similar event causing vehicle to stop on the road, that might pose a risk to other road users. True = Vehicle broken down on the road, due to e.g. engine problems, flat tire, out of gas, brake problems. False = Vehicle not broken down.. This type has no unit defined"]
        #[doc = r" . Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
            assert!(Self::bounds_check(&value));
            self.v = value;
            if let Some(ts) = maybe_timestamp {
                self.timestamp = ts;
            }
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &bool) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self {
                    v: value,
                    timestamp: timestamp.unwrap_or_default(),
                })
            } else {
                None
            }
        }
    }
    #[doc = "Indicates whether the vehicle is stationary or moving.. This type has no unit defined"]
    #[allow(non_camel_case_types)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct IsMoving {
        v: bool,
        timestamp: crate::v2::Timestamp,
    }
    impl IsMoving {
        pub fn timestamp(&self) -> &crate::v2::Timestamp {
            &self.timestamp
        }
        #[doc = r" Get the "]
        #[doc = "Indicates whether the vehicle is stationary or moving.. This type has no unit defined"]
        pub fn value(&self) -> &bool {
            &self.v
        }
        #[doc = r" Set the"]
        #[doc = "Indicates whether the vehicle is stationary or moving.. This type has no unit defined"]
        #[doc = r" . Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
            assert!(Self::bounds_check(&value));
            self.v = value;
            if let Some(ts) = maybe_timestamp {
                self.timestamp = ts;
            }
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &bool) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self {
                    v: value,
                    timestamp: timestamp.unwrap_or_default(),
                })
            } else {
                None
            }
        }
    }
    #[doc = "Average speed for the current trip.. The unit of this type is km/h"]
    #[allow(non_camel_case_types)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct AverageSpeed {
        v: crate::v2::units::KilometrePerHour<f32>,
        timestamp: crate::v2::Timestamp,
    }
    impl AverageSpeed {
        pub fn timestamp(&self) -> &crate::v2::Timestamp {
            &self.timestamp
        }
        #[doc = r" Get the "]
        #[doc = "Average speed for the current trip.. The unit of this type is km/h"]
        pub fn value(&self) -> &crate::v2::units::KilometrePerHour<f32> {
            &self.v
        }
        #[doc = r" Set the"]
        #[doc = "Average speed for the current trip.. The unit of this type is km/h"]
        #[doc = r" . Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(
            &mut self,
            value: crate::v2::units::KilometrePerHour<f32>,
            maybe_timestamp: Option<crate::v2::Timestamp>,
        ) {
            assert!(Self::bounds_check(&value));
            self.v = value;
            if let Some(ts) = maybe_timestamp {
                self.timestamp = ts;
            }
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &crate::v2::units::KilometrePerHour<f32>) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(
            value: crate::v2::units::KilometrePerHour<f32>,
            timestamp: Option<crate::v2::Timestamp>,
        ) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self {
                    v: value,
                    timestamp: timestamp.unwrap_or_default(),
                })
            } else {
                None
            }
        }
    }
    #[doc = "The permitted total weight of cargo and installations (e.g. a roof rack) on top of the vehicle.. The unit of this type is kg"]
    #[allow(non_camel_case_types)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct RoofLoad {
        v: crate::v2::units::Kilogram<i16>,
    }
    impl RoofLoad {
        #[doc = r" Get the "]
        #[doc = "The permitted total weight of cargo and installations (e.g. a roof rack) on top of the vehicle.. The unit of this type is kg"]
        pub fn value(&self) -> &crate::v2::units::Kilogram<i16> {
            &self.v
        }
        #[doc = r" Set the"]
        #[doc = "The permitted total weight of cargo and installations (e.g. a roof rack) on top of the vehicle.. The unit of this type is kg"]
        #[doc = r" Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(&mut self, value: crate::v2::units::Kilogram<i16>) {
            assert!(Self::bounds_check(&value));
            self.v = value;
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &crate::v2::units::Kilogram<i16>) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(value: crate::v2::units::Kilogram<i16>) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self { v: value })
            } else {
                None
            }
        }
    }
    #[doc = "The available volume for cargo or luggage. For automobiles, this is usually the trunk volume.. The unit of this type is l"]
    #[allow(non_camel_case_types)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct CargoVolume {
        v: crate::v2::units::Litre<f32>,
    }
    impl CargoVolume {
        #[doc = r" Get the "]
        #[doc = "The available volume for cargo or luggage. For automobiles, this is usually the trunk volume.. The unit of this type is l"]
        pub fn value(&self) -> &crate::v2::units::Litre<f32> {
            &self.v
        }
        #[doc = r" Set the"]
        #[doc = "The available volume for cargo or luggage. For automobiles, this is usually the trunk volume.. The unit of this type is l"]
        #[doc = r" Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(&mut self, value: crate::v2::units::Litre<f32>) {
            assert!(Self::bounds_check(&value));
            self.v = value;
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. Return true if the value is"]
        #[doc = r"within bounds."]
        pub fn bounds_check(v: &crate::v2::units::Litre<f32>) -> bool {
            true && v.0 >= 0f32
        }
        #[doc = r" create a new instance"]
        pub fn new(value: crate::v2::units::Litre<f32>) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self { v: value })
            } else {
                None
            }
        }
    }
    #[doc = "The CO2 emissions.. The unit of this type is g/km"]
    #[allow(non_camel_case_types)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct EmissionsCO2 {
        v: i16,
    }
    impl EmissionsCO2 {
        #[doc = r" Get the "]
        #[doc = "The CO2 emissions.. The unit of this type is g/km"]
        pub fn value(&self) -> &i16 {
            &self.v
        }
        #[doc = r" Set the"]
        #[doc = "The CO2 emissions.. The unit of this type is g/km"]
        #[doc = r" Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(&mut self, value: i16) {
            assert!(Self::bounds_check(&value));
            self.v = value;
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &i16) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(value: i16) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self { v: value })
            } else {
                None
            }
        }
    }
    #[doc = "Current overall Vehicle weight. Including passengers, cargo and other load inside the car.. The unit of this type is kg"]
    #[allow(non_camel_case_types)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct CurrentOverallWeight {
        v: crate::v2::units::Kilogram<u16>,
        timestamp: crate::v2::Timestamp,
    }
    impl CurrentOverallWeight {
        pub fn timestamp(&self) -> &crate::v2::Timestamp {
            &self.timestamp
        }
        #[doc = r" Get the "]
        #[doc = "Current overall Vehicle weight. Including passengers, cargo and other load inside the car.. The unit of this type is kg"]
        pub fn value(&self) -> &crate::v2::units::Kilogram<u16> {
            &self.v
        }
        #[doc = r" Set the"]
        #[doc = "Current overall Vehicle weight. Including passengers, cargo and other load inside the car.. The unit of this type is kg"]
        #[doc = r" . Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(
            &mut self,
            value: crate::v2::units::Kilogram<u16>,
            maybe_timestamp: Option<crate::v2::Timestamp>,
        ) {
            assert!(Self::bounds_check(&value));
            self.v = value;
            if let Some(ts) = maybe_timestamp {
                self.timestamp = ts;
            }
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &crate::v2::units::Kilogram<u16>) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(
            value: crate::v2::units::Kilogram<u16>,
            timestamp: Option<crate::v2::Timestamp>,
        ) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self {
                    v: value,
                    timestamp: timestamp.unwrap_or_default(),
                })
            } else {
                None
            }
        }
    }
    #[doc = "Vehicle curb weight, including all liquids and full tank of fuel, but no cargo or passengers.. The unit of this type is kg"]
    #[allow(non_camel_case_types)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct CurbWeight {
        v: crate::v2::units::Kilogram<u16>,
    }
    impl CurbWeight {
        #[doc = r" Get the "]
        #[doc = "Vehicle curb weight, including all liquids and full tank of fuel, but no cargo or passengers.. The unit of this type is kg"]
        pub fn value(&self) -> &crate::v2::units::Kilogram<u16> {
            &self.v
        }
        #[doc = r" Set the"]
        #[doc = "Vehicle curb weight, including all liquids and full tank of fuel, but no cargo or passengers.. The unit of this type is kg"]
        #[doc = r" Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(&mut self, value: crate::v2::units::Kilogram<u16>) {
            assert!(Self::bounds_check(&value));
            self.v = value;
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &crate::v2::units::Kilogram<u16>) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(value: crate::v2::units::Kilogram<u16>) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self { v: value })
            } else {
                None
            }
        }
    }
    #[doc = "Curb weight of vehicle, including all liquids and full tank of fuel and full load of cargo and passengers.. The unit of this type is kg"]
    #[allow(non_camel_case_types)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct GrossWeight {
        v: crate::v2::units::Kilogram<u16>,
    }
    impl GrossWeight {
        #[doc = r" Get the "]
        #[doc = "Curb weight of vehicle, including all liquids and full tank of fuel and full load of cargo and passengers.. The unit of this type is kg"]
        pub fn value(&self) -> &crate::v2::units::Kilogram<u16> {
            &self.v
        }
        #[doc = r" Set the"]
        #[doc = "Curb weight of vehicle, including all liquids and full tank of fuel and full load of cargo and passengers.. The unit of this type is kg"]
        #[doc = r" Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(&mut self, value: crate::v2::units::Kilogram<u16>) {
            assert!(Self::bounds_check(&value));
            self.v = value;
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &crate::v2::units::Kilogram<u16>) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(value: crate::v2::units::Kilogram<u16>) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self { v: value })
            } else {
                None
            }
        }
    }
    #[doc = "Maximum weight of trailer.. The unit of this type is kg"]
    #[allow(non_camel_case_types)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct MaxTowWeight {
        v: crate::v2::units::Kilogram<u16>,
    }
    impl MaxTowWeight {
        #[doc = r" Get the "]
        #[doc = "Maximum weight of trailer.. The unit of this type is kg"]
        pub fn value(&self) -> &crate::v2::units::Kilogram<u16> {
            &self.v
        }
        #[doc = r" Set the"]
        #[doc = "Maximum weight of trailer.. The unit of this type is kg"]
        #[doc = r" Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(&mut self, value: crate::v2::units::Kilogram<u16>) {
            assert!(Self::bounds_check(&value));
            self.v = value;
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &crate::v2::units::Kilogram<u16>) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(value: crate::v2::units::Kilogram<u16>) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self { v: value })
            } else {
                None
            }
        }
    }
    #[doc = "Maximum vertical weight on the tow ball of a trailer.. The unit of this type is kg"]
    #[allow(non_camel_case_types)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct MaxTowBallWeight {
        v: crate::v2::units::Kilogram<u16>,
    }
    impl MaxTowBallWeight {
        #[doc = r" Get the "]
        #[doc = "Maximum vertical weight on the tow ball of a trailer.. The unit of this type is kg"]
        pub fn value(&self) -> &crate::v2::units::Kilogram<u16> {
            &self.v
        }
        #[doc = r" Set the"]
        #[doc = "Maximum vertical weight on the tow ball of a trailer.. The unit of this type is kg"]
        #[doc = r" Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(&mut self, value: crate::v2::units::Kilogram<u16>) {
            assert!(Self::bounds_check(&value));
            self.v = value;
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &crate::v2::units::Kilogram<u16>) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(value: crate::v2::units::Kilogram<u16>) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self { v: value })
            } else {
                None
            }
        }
    }
    #[doc = "Overall vehicle length.. The unit of this type is mm"]
    #[allow(non_camel_case_types)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct Length {
        v: crate::v2::units::Millimetre<u16>,
    }
    impl Length {
        #[doc = r" Get the "]
        #[doc = "Overall vehicle length.. The unit of this type is mm"]
        pub fn value(&self) -> &crate::v2::units::Millimetre<u16> {
            &self.v
        }
        #[doc = r" Set the"]
        #[doc = "Overall vehicle length.. The unit of this type is mm"]
        #[doc = r" Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(&mut self, value: crate::v2::units::Millimetre<u16>) {
            assert!(Self::bounds_check(&value));
            self.v = value;
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &crate::v2::units::Millimetre<u16>) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(value: crate::v2::units::Millimetre<u16>) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self { v: value })
            } else {
                None
            }
        }
    }
    #[doc = "Overall vehicle height.. The unit of this type is mm"]
    #[allow(non_camel_case_types)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct Height {
        v: crate::v2::units::Millimetre<u16>,
    }
    impl Height {
        #[doc = r" Get the "]
        #[doc = "Overall vehicle height.. The unit of this type is mm"]
        pub fn value(&self) -> &crate::v2::units::Millimetre<u16> {
            &self.v
        }
        #[doc = r" Set the"]
        #[doc = "Overall vehicle height.. The unit of this type is mm"]
        #[doc = r" Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(&mut self, value: crate::v2::units::Millimetre<u16>) {
            assert!(Self::bounds_check(&value));
            self.v = value;
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &crate::v2::units::Millimetre<u16>) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(value: crate::v2::units::Millimetre<u16>) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self { v: value })
            } else {
                None
            }
        }
    }
    #[doc = "Overall vehicle width.. The unit of this type is mm"]
    #[allow(non_camel_case_types)]
    #[derive(Default, Deserialize, Serialize, Topic)]
    pub struct Width {
        v: crate::v2::units::Millimetre<u16>,
    }
    impl Width {
        #[doc = r" Get the "]
        #[doc = "Overall vehicle width.. The unit of this type is mm"]
        pub fn value(&self) -> &crate::v2::units::Millimetre<u16> {
            &self.v
        }
        #[doc = r" Set the"]
        #[doc = "Overall vehicle width.. The unit of this type is mm"]
        #[doc = r" Ensure that the value is within bounds as per the"]
        #[doc = r" specification. This function will panic in case the value is out"]
        #[doc = r" of bounds."]
        pub fn set(&mut self, value: crate::v2::units::Millimetre<u16>) {
            assert!(Self::bounds_check(&value));
            self.v = value;
        }
        #[doc = r"check if the given value is within the limits defined"]
        #[doc = r"in the specification. This particular type has not"]
        #[doc = r"specified the min or max limits so the function just"]
        #[doc = r" returns true"]
        const fn bounds_check(_v: &crate::v2::units::Millimetre<u16>) -> bool {
            true
        }
        #[doc = r" create a new instance"]
        pub fn new(value: crate::v2::units::Millimetre<u16>) -> Option<Self> {
            if Self::bounds_check(&value) {
                Some(Self { v: value })
            } else {
                None
            }
        }
    }
    #[allow(non_snake_case)]
    pub mod connectivity {
        use cdds_derive::Topic;
        use cyclonedds_rs::*;
        #[doc = "Indicates if connectivity between vehicle and cloud is available. True = Connectivity is available. False = Connectivity is not available.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct IsConnectivityAvailable {
            v: bool,
            timestamp: crate::v2::Timestamp,
        }
        impl IsConnectivityAvailable {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Indicates if connectivity between vehicle and cloud is available. True = Connectivity is available. False = Connectivity is not available.. This type has no unit defined"]
            pub fn value(&self) -> &bool {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Indicates if connectivity between vehicle and cloud is available. True = Connectivity is available. False = Connectivity is not available.. This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &bool) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
    }
    #[allow(non_snake_case)]
    pub mod service {
        use cdds_derive::Topic;
        use cyclonedds_rs::*;
        #[doc = "Indicates if vehicle needs service (of any kind). True = Service needed now or in the near future. False = No known need for service.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct IsServiceDue {
            v: bool,
            timestamp: crate::v2::Timestamp,
        }
        impl IsServiceDue {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Indicates if vehicle needs service (of any kind). True = Service needed now or in the near future. False = No known need for service.. This type has no unit defined"]
            pub fn value(&self) -> &bool {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Indicates if vehicle needs service (of any kind). True = Service needed now or in the near future. False = No known need for service.. This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &bool) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Remaining distance to service (of any kind). Negative values indicate service overdue.. The unit of this type is km"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct DistanceToService {
            v: crate::v2::units::Kilometre<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl DistanceToService {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Remaining distance to service (of any kind). Negative values indicate service overdue.. The unit of this type is km"]
            pub fn value(&self) -> &crate::v2::units::Kilometre<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Remaining distance to service (of any kind). Negative values indicate service overdue.. The unit of this type is km"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Kilometre<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Kilometre<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Kilometre<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Remaining time to service (of any kind). Negative values indicate service overdue.. The unit of this type is s"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct TimeToService {
            v: crate::v2::units::Second<i32>,
            timestamp: crate::v2::Timestamp,
        }
        impl TimeToService {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Remaining time to service (of any kind). Negative values indicate service overdue.. The unit of this type is s"]
            pub fn value(&self) -> &crate::v2::units::Second<i32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Remaining time to service (of any kind). Negative values indicate service overdue.. The unit of this type is s"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Second<i32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Second<i32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Second<i32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
    }
    #[allow(non_snake_case)]
    pub mod exterior {
        use cdds_derive::Topic;
        use cyclonedds_rs::*;
        #[doc = "Air temperature outside the vehicle.. The unit of this type is celsius"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct AirTemperature {
            v: crate::v2::units::Celsius<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl AirTemperature {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Air temperature outside the vehicle.. The unit of this type is celsius"]
            pub fn value(&self) -> &crate::v2::units::Celsius<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Air temperature outside the vehicle.. The unit of this type is celsius"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Celsius<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Celsius<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Celsius<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Relative humidity outside the vehicle. 0 = Dry, 100 = Air fully saturated.. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Humidity {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl Humidity {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Relative humidity outside the vehicle. 0 = Dry, 100 = Air fully saturated.. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Relative humidity outside the vehicle. 0 = Dry, 100 = Air fully saturated.. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. Return true if the value is"]
            #[doc = r"within bounds."]
            pub fn bounds_check(v: &crate::v2::units::Percent<f32>) -> bool {
                v.0 <= 100f32 && v.0 >= 0f32
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Light intensity outside the vehicle. 0 = No light detected, 100 = Fully lit.. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct LightIntensity {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl LightIntensity {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Light intensity outside the vehicle. 0 = No light detected, 100 = Fully lit.. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Light intensity outside the vehicle. 0 = No light detected, 100 = Fully lit.. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. Return true if the value is"]
            #[doc = r"within bounds."]
            pub fn bounds_check(v: &crate::v2::units::Percent<f32>) -> bool {
                v.0 <= 100f32 && v.0 >= 0f32
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
    }
    #[allow(non_snake_case)]
    pub mod driver {
        use cdds_derive::Topic;
        use cyclonedds_rs::*;
        #[doc = "Distraction level of the driver will be the level how much the driver is distracted, by multiple factors. E.g. Driving situation, acustical or optical signales inside the cockpit, phone calls.. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct DistractionLevel {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl DistractionLevel {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Distraction level of the driver will be the level how much the driver is distracted, by multiple factors. E.g. Driving situation, acustical or optical signales inside the cockpit, phone calls.. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Distraction level of the driver will be the level how much the driver is distracted, by multiple factors. E.g. Driving situation, acustical or optical signales inside the cockpit, phone calls.. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. Return true if the value is"]
            #[doc = r"within bounds."]
            pub fn bounds_check(v: &crate::v2::units::Percent<f32>) -> bool {
                v.0 <= 100f32 && v.0 >= 0f32
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Has driver the eyes on road or not?. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct IsEyesOnRoad {
            v: bool,
            timestamp: crate::v2::Timestamp,
        }
        impl IsEyesOnRoad {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Has driver the eyes on road or not?. This type has no unit defined"]
            pub fn value(&self) -> &bool {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Has driver the eyes on road or not?. This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &bool) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Probability of attentiveness of the driver.. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct AttentiveProbability {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl AttentiveProbability {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Probability of attentiveness of the driver.. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Probability of attentiveness of the driver.. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. Return true if the value is"]
            #[doc = r"within bounds."]
            pub fn bounds_check(v: &crate::v2::units::Percent<f32>) -> bool {
                v.0 <= 100f32 && v.0 >= 0f32
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Fatigueness level of driver. Evaluated by multiple factors like trip time, behaviour of steering, eye status.. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct FatigueLevel {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl FatigueLevel {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Fatigueness level of driver. Evaluated by multiple factors like trip time, behaviour of steering, eye status.. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Fatigueness level of driver. Evaluated by multiple factors like trip time, behaviour of steering, eye status.. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. Return true if the value is"]
            #[doc = r"within bounds."]
            pub fn bounds_check(v: &crate::v2::units::Percent<f32>) -> bool {
                v.0 <= 100f32 && v.0 >= 0f32
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Heart rate of the driver.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct HeartRate {
            v: u16,
            timestamp: crate::v2::Timestamp,
        }
        impl HeartRate {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Heart rate of the driver.. This type has no unit defined"]
            pub fn value(&self) -> &u16 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Heart rate of the driver.. This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u16, maybe_timestamp: Option<crate::v2::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u16) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u16, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod identifier {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Subject for the authentication of the occupant. E.g. UserID 7331677.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Subject {
                v: String,
                timestamp: crate::v2::Timestamp,
            }
            impl Subject {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Subject for the authentication of the occupant. E.g. UserID 7331677.. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Subject for the authentication of the occupant. E.g. UserID 7331677.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: String,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Unique Issuer for the authentication of the occupant. E.g. https://accounts.funcorp.com.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Issuer {
                v: String,
                timestamp: crate::v2::Timestamp,
            }
            impl Issuer {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Unique Issuer for the authentication of the occupant. E.g. https://accounts.funcorp.com.. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Unique Issuer for the authentication of the occupant. E.g. https://accounts.funcorp.com.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: String,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
    }
    #[allow(non_snake_case)]
    pub mod obd {
        use cdds_derive::Topic;
        use cyclonedds_rs::*;
        #[doc = "PID 00 - Bit array of the supported pids 01 to 20. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct PidsA {
            v: u32,
            timestamp: crate::v2::Timestamp,
        }
        impl PidsA {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 00 - Bit array of the supported pids 01 to 20. This type has no unit defined"]
            pub fn value(&self) -> &u32 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 00 - Bit array of the supported pids 01 to 20. This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u32, maybe_timestamp: Option<crate::v2::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u32) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u32, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "List of currently active DTCs formatted according OBD II (SAE-J2012DA_201812) standard ([P|C|B|U]XXXXX ). This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct DTCList {
            v: Vec<String>,
            timestamp: crate::v2::Timestamp,
        }
        impl DTCList {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "List of currently active DTCs formatted according OBD II (SAE-J2012DA_201812) standard ([P|C|B|U]XXXXX ). This type has no unit defined"]
            pub fn value(&self) -> &Vec<String> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "List of currently active DTCs formatted according OBD II (SAE-J2012DA_201812) standard ([P|C|B|U]XXXXX ). This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: Vec<String>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &Vec<String>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: Vec<String>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 02 - DTC that triggered the freeze frame. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct FreezeDTC {
            v: String,
            timestamp: crate::v2::Timestamp,
        }
        impl FreezeDTC {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 02 - DTC that triggered the freeze frame. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 02 - DTC that triggered the freeze frame. This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String, maybe_timestamp: Option<crate::v2::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 03 - Fuel status. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct FuelStatus {
            v: String,
            timestamp: crate::v2::Timestamp,
        }
        impl FuelStatus {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 03 - Fuel status. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 03 - Fuel status. This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String, maybe_timestamp: Option<crate::v2::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 04 - Engine load in percent - 0 = no load, 100 = full load. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct EngineLoad {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl EngineLoad {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 04 - Engine load in percent - 0 = no load, 100 = full load. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 04 - Engine load in percent - 0 = no load, 100 = full load. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 05 - Coolant temperature. The unit of this type is celsius"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct CoolantTemperature {
            v: crate::v2::units::Celsius<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl CoolantTemperature {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 05 - Coolant temperature. The unit of this type is celsius"]
            pub fn value(&self) -> &crate::v2::units::Celsius<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 05 - Coolant temperature. The unit of this type is celsius"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Celsius<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Celsius<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Celsius<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 06 - Short Term (immediate) Fuel Trim - Bank 1 - negative percent leaner, positive percent richer. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct ShortTermFuelTrim1 {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl ShortTermFuelTrim1 {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 06 - Short Term (immediate) Fuel Trim - Bank 1 - negative percent leaner, positive percent richer. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 06 - Short Term (immediate) Fuel Trim - Bank 1 - negative percent leaner, positive percent richer. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 07 - Long Term (learned) Fuel Trim - Bank 1 - negative percent leaner, positive percent richer. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct LongTermFuelTrim1 {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl LongTermFuelTrim1 {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 07 - Long Term (learned) Fuel Trim - Bank 1 - negative percent leaner, positive percent richer. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 07 - Long Term (learned) Fuel Trim - Bank 1 - negative percent leaner, positive percent richer. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 08 - Short Term (immediate) Fuel Trim - Bank 2 - negative percent leaner, positive percent richer. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct ShortTermFuelTrim2 {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl ShortTermFuelTrim2 {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 08 - Short Term (immediate) Fuel Trim - Bank 2 - negative percent leaner, positive percent richer. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 08 - Short Term (immediate) Fuel Trim - Bank 2 - negative percent leaner, positive percent richer. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 09 - Long Term (learned) Fuel Trim - Bank 2 - negative percent leaner, positive percent richer. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct LongTermFuelTrim2 {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl LongTermFuelTrim2 {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 09 - Long Term (learned) Fuel Trim - Bank 2 - negative percent leaner, positive percent richer. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 09 - Long Term (learned) Fuel Trim - Bank 2 - negative percent leaner, positive percent richer. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 0A - Fuel pressure. The unit of this type is kPa"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct FuelPressure {
            v: crate::v2::units::KiloPascal<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl FuelPressure {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 0A - Fuel pressure. The unit of this type is kPa"]
            pub fn value(&self) -> &crate::v2::units::KiloPascal<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 0A - Fuel pressure. The unit of this type is kPa"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::KiloPascal<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::KiloPascal<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::KiloPascal<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 0B - Intake manifold pressure. The unit of this type is kPa"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct MAP {
            v: crate::v2::units::KiloPascal<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl MAP {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 0B - Intake manifold pressure. The unit of this type is kPa"]
            pub fn value(&self) -> &crate::v2::units::KiloPascal<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 0B - Intake manifold pressure. The unit of this type is kPa"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::KiloPascal<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::KiloPascal<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::KiloPascal<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 0C - Engine speed measured as rotations per minute. The unit of this type is rpm"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct EngineSpeed {
            v: crate::v2::units::RPM<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl EngineSpeed {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 0C - Engine speed measured as rotations per minute. The unit of this type is rpm"]
            pub fn value(&self) -> &crate::v2::units::RPM<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 0C - Engine speed measured as rotations per minute. The unit of this type is rpm"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::RPM<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::RPM<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::RPM<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 0D - Vehicle speed. The unit of this type is km/h"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Speed {
            v: crate::v2::units::KilometrePerHour<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl Speed {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 0D - Vehicle speed. The unit of this type is km/h"]
            pub fn value(&self) -> &crate::v2::units::KilometrePerHour<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 0D - Vehicle speed. The unit of this type is km/h"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::KilometrePerHour<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::KilometrePerHour<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::KilometrePerHour<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 0E - Time advance. The unit of this type is degrees"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct TimingAdvance {
            v: f32,
            timestamp: crate::v2::Timestamp,
        }
        impl TimingAdvance {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 0E - Time advance. The unit of this type is degrees"]
            pub fn value(&self) -> &f32 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 0E - Time advance. The unit of this type is degrees"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: f32, maybe_timestamp: Option<crate::v2::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &f32) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: f32, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 0F - Intake temperature. The unit of this type is celsius"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct IntakeTemp {
            v: crate::v2::units::Celsius<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl IntakeTemp {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 0F - Intake temperature. The unit of this type is celsius"]
            pub fn value(&self) -> &crate::v2::units::Celsius<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 0F - Intake temperature. The unit of this type is celsius"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Celsius<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Celsius<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Celsius<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 10 - Grams of air drawn into engine per second. The unit of this type is g/s"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct MAF {
            v: crate::v2::units::GramPerSec<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl MAF {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 10 - Grams of air drawn into engine per second. The unit of this type is g/s"]
            pub fn value(&self) -> &crate::v2::units::GramPerSec<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 10 - Grams of air drawn into engine per second. The unit of this type is g/s"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::GramPerSec<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::GramPerSec<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::GramPerSec<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 11 - Throttle position - 0 = closed throttle, 100 = open throttle. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct ThrottlePosition {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl ThrottlePosition {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 11 - Throttle position - 0 = closed throttle, 100 = open throttle. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 11 - Throttle position - 0 = closed throttle, 100 = open throttle. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 12 - Secondary air status. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct AirStatus {
            v: String,
            timestamp: crate::v2::Timestamp,
        }
        impl AirStatus {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 12 - Secondary air status. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 12 - Secondary air status. This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String, maybe_timestamp: Option<crate::v2::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 13 - Presence of oxygen sensors in 2 banks. [A0..A3] == Bank 1, Sensors 1-4. [A4..A7] == Bank 2, Sensors 1-4. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct OxygenSensorsIn2Banks {
            v: u8,
            timestamp: crate::v2::Timestamp,
        }
        impl OxygenSensorsIn2Banks {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 13 - Presence of oxygen sensors in 2 banks. [A0..A3] == Bank 1, Sensors 1-4. [A4..A7] == Bank 2, Sensors 1-4. This type has no unit defined"]
            pub fn value(&self) -> &u8 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 13 - Presence of oxygen sensors in 2 banks. [A0..A3] == Bank 1, Sensors 1-4. [A4..A7] == Bank 2, Sensors 1-4. This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u8, maybe_timestamp: Option<crate::v2::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u8) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u8, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 1C - OBD standards this vehicle conforms to. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct OBDStandards {
            v: u8,
        }
        impl OBDStandards {
            #[doc = r" Get the "]
            #[doc = "PID 1C - OBD standards this vehicle conforms to. This type has no unit defined"]
            pub fn value(&self) -> &u8 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 1C - OBD standards this vehicle conforms to. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u8) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u8) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u8) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 1D - Presence of oxygen sensors in 4 banks. Similar to PID 13, but [A0..A7] == [B1S1, B1S2, B2S1, B2S2, B3S1, B3S2, B4S1, B4S2]. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct OxygenSensorsIn4Banks {
            v: u8,
            timestamp: crate::v2::Timestamp,
        }
        impl OxygenSensorsIn4Banks {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 1D - Presence of oxygen sensors in 4 banks. Similar to PID 13, but [A0..A7] == [B1S1, B1S2, B2S1, B2S2, B3S1, B3S2, B4S1, B4S2]. This type has no unit defined"]
            pub fn value(&self) -> &u8 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 1D - Presence of oxygen sensors in 4 banks. Similar to PID 13, but [A0..A7] == [B1S1, B1S2, B2S1, B2S2, B3S1, B3S2, B4S1, B4S2]. This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u8, maybe_timestamp: Option<crate::v2::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u8) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u8, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 1E - Auxiliary input status (power take off). This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct IsPTOActive {
            v: bool,
            timestamp: crate::v2::Timestamp,
        }
        impl IsPTOActive {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 1E - Auxiliary input status (power take off). This type has no unit defined"]
            pub fn value(&self) -> &bool {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 1E - Auxiliary input status (power take off). This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &bool) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 1F - Engine run time. The unit of this type is s"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct RunTime {
            v: crate::v2::units::Second<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl RunTime {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 1F - Engine run time. The unit of this type is s"]
            pub fn value(&self) -> &crate::v2::units::Second<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 1F - Engine run time. The unit of this type is s"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Second<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Second<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Second<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 20 - Bit array of the supported pids 21 to 40. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct PidsB {
            v: u32,
            timestamp: crate::v2::Timestamp,
        }
        impl PidsB {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 20 - Bit array of the supported pids 21 to 40. This type has no unit defined"]
            pub fn value(&self) -> &u32 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 20 - Bit array of the supported pids 21 to 40. This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u32, maybe_timestamp: Option<crate::v2::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u32) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u32, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 21 - Distance traveled with MIL on. The unit of this type is km"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct DistanceWithMIL {
            v: crate::v2::units::Kilometre<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl DistanceWithMIL {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 21 - Distance traveled with MIL on. The unit of this type is km"]
            pub fn value(&self) -> &crate::v2::units::Kilometre<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 21 - Distance traveled with MIL on. The unit of this type is km"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Kilometre<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Kilometre<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Kilometre<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 22 - Fuel rail pressure relative to vacuum. The unit of this type is kPa"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct FuelRailPressureVac {
            v: crate::v2::units::KiloPascal<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl FuelRailPressureVac {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 22 - Fuel rail pressure relative to vacuum. The unit of this type is kPa"]
            pub fn value(&self) -> &crate::v2::units::KiloPascal<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 22 - Fuel rail pressure relative to vacuum. The unit of this type is kPa"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::KiloPascal<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::KiloPascal<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::KiloPascal<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 23 - Fuel rail pressure direct inject. The unit of this type is kPa"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct FuelRailPressureDirect {
            v: crate::v2::units::KiloPascal<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl FuelRailPressureDirect {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 23 - Fuel rail pressure direct inject. The unit of this type is kPa"]
            pub fn value(&self) -> &crate::v2::units::KiloPascal<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 23 - Fuel rail pressure direct inject. The unit of this type is kPa"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::KiloPascal<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::KiloPascal<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::KiloPascal<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 2C - Commanded exhaust gas recirculation (EGR). The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct CommandedEGR {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl CommandedEGR {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 2C - Commanded exhaust gas recirculation (EGR). The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 2C - Commanded exhaust gas recirculation (EGR). The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 2D - Exhaust gas recirculation (EGR) error. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct EGRError {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl EGRError {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 2D - Exhaust gas recirculation (EGR) error. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 2D - Exhaust gas recirculation (EGR) error. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 2E - Commanded evaporative purge (EVAP) valve. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct CommandedEVAP {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl CommandedEVAP {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 2E - Commanded evaporative purge (EVAP) valve. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 2E - Commanded evaporative purge (EVAP) valve. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 2F - Fuel level in the fuel tank. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct FuelLevel {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl FuelLevel {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 2F - Fuel level in the fuel tank. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 2F - Fuel level in the fuel tank. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 30 - Number of warm-ups since codes cleared. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct WarmupsSinceDTCClear {
            v: u8,
            timestamp: crate::v2::Timestamp,
        }
        impl WarmupsSinceDTCClear {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 30 - Number of warm-ups since codes cleared. This type has no unit defined"]
            pub fn value(&self) -> &u8 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 30 - Number of warm-ups since codes cleared. This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u8, maybe_timestamp: Option<crate::v2::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u8) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u8, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 31 - Distance traveled since codes cleared. The unit of this type is km"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct DistanceSinceDTCClear {
            v: crate::v2::units::Kilometre<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl DistanceSinceDTCClear {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 31 - Distance traveled since codes cleared. The unit of this type is km"]
            pub fn value(&self) -> &crate::v2::units::Kilometre<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 31 - Distance traveled since codes cleared. The unit of this type is km"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Kilometre<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Kilometre<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Kilometre<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 32 - Evaporative purge (EVAP) system pressure. The unit of this type is Pa"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct EVAPVaporPressure {
            v: crate::v2::units::Pascal<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl EVAPVaporPressure {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 32 - Evaporative purge (EVAP) system pressure. The unit of this type is Pa"]
            pub fn value(&self) -> &crate::v2::units::Pascal<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 32 - Evaporative purge (EVAP) system pressure. The unit of this type is Pa"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Pascal<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Pascal<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Pascal<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 33 - Barometric pressure. The unit of this type is kPa"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct BarometricPressure {
            v: crate::v2::units::KiloPascal<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl BarometricPressure {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 33 - Barometric pressure. The unit of this type is kPa"]
            pub fn value(&self) -> &crate::v2::units::KiloPascal<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 33 - Barometric pressure. The unit of this type is kPa"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::KiloPascal<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::KiloPascal<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::KiloPascal<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 40 - Bit array of the supported pids 41 to 60. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct PidsC {
            v: u32,
            timestamp: crate::v2::Timestamp,
        }
        impl PidsC {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 40 - Bit array of the supported pids 41 to 60. This type has no unit defined"]
            pub fn value(&self) -> &u32 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 40 - Bit array of the supported pids 41 to 60. This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u32, maybe_timestamp: Option<crate::v2::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u32) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u32, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 42 - Control module voltage. The unit of this type is V"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct ControlModuleVoltage {
            v: crate::v2::units::Volt<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl ControlModuleVoltage {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 42 - Control module voltage. The unit of this type is V"]
            pub fn value(&self) -> &crate::v2::units::Volt<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 42 - Control module voltage. The unit of this type is V"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Volt<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Volt<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Volt<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 43 - Absolute load value. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct AbsoluteLoad {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl AbsoluteLoad {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 43 - Absolute load value. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 43 - Absolute load value. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 44 - Commanded equivalence ratio. The unit of this type is ratio"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct CommandedEquivalenceRatio {
            v: crate::v2::units::Ratio<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl CommandedEquivalenceRatio {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 44 - Commanded equivalence ratio. The unit of this type is ratio"]
            pub fn value(&self) -> &crate::v2::units::Ratio<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 44 - Commanded equivalence ratio. The unit of this type is ratio"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Ratio<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Ratio<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Ratio<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 45 - Relative throttle position. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct RelativeThrottlePosition {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl RelativeThrottlePosition {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 45 - Relative throttle position. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 45 - Relative throttle position. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 46 - Ambient air temperature. The unit of this type is celsius"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct AmbientAirTemperature {
            v: crate::v2::units::Celsius<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl AmbientAirTemperature {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 46 - Ambient air temperature. The unit of this type is celsius"]
            pub fn value(&self) -> &crate::v2::units::Celsius<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 46 - Ambient air temperature. The unit of this type is celsius"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Celsius<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Celsius<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Celsius<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 47 - Absolute throttle position B. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct ThrottlePositionB {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl ThrottlePositionB {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 47 - Absolute throttle position B. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 47 - Absolute throttle position B. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 48 - Absolute throttle position C. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct ThrottlePositionC {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl ThrottlePositionC {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 48 - Absolute throttle position C. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 48 - Absolute throttle position C. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 49 - Accelerator pedal position D. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct AcceleratorPositionD {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl AcceleratorPositionD {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 49 - Accelerator pedal position D. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 49 - Accelerator pedal position D. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 4A - Accelerator pedal position E. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct AcceleratorPositionE {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl AcceleratorPositionE {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 4A - Accelerator pedal position E. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 4A - Accelerator pedal position E. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 4B - Accelerator pedal position F. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct AcceleratorPositionF {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl AcceleratorPositionF {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 4B - Accelerator pedal position F. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 4B - Accelerator pedal position F. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 4C - Commanded throttle actuator. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct ThrottleActuator {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl ThrottleActuator {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 4C - Commanded throttle actuator. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 4C - Commanded throttle actuator. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 4D - Run time with MIL on. The unit of this type is min"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct RunTimeMIL {
            v: crate::v2::units::Minute<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl RunTimeMIL {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 4D - Run time with MIL on. The unit of this type is min"]
            pub fn value(&self) -> &crate::v2::units::Minute<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 4D - Run time with MIL on. The unit of this type is min"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Minute<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Minute<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Minute<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 4E - Time since trouble codes cleared. The unit of this type is min"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct TimeSinceDTCCleared {
            v: crate::v2::units::Minute<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl TimeSinceDTCCleared {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 4E - Time since trouble codes cleared. The unit of this type is min"]
            pub fn value(&self) -> &crate::v2::units::Minute<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 4E - Time since trouble codes cleared. The unit of this type is min"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Minute<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Minute<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Minute<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 50 - Maximum flow for mass air flow sensor. The unit of this type is g/s"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct MaxMAF {
            v: crate::v2::units::GramPerSec<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl MaxMAF {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 50 - Maximum flow for mass air flow sensor. The unit of this type is g/s"]
            pub fn value(&self) -> &crate::v2::units::GramPerSec<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 50 - Maximum flow for mass air flow sensor. The unit of this type is g/s"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::GramPerSec<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::GramPerSec<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::GramPerSec<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 51 - Fuel type. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct FuelType {
            v: String,
            timestamp: crate::v2::Timestamp,
        }
        impl FuelType {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 51 - Fuel type. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 51 - Fuel type. This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String, maybe_timestamp: Option<crate::v2::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 52 - Percentage of ethanol in the fuel. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct EthanolPercent {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl EthanolPercent {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 52 - Percentage of ethanol in the fuel. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 52 - Percentage of ethanol in the fuel. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 53 - Absolute evaporative purge (EVAP) system pressure. The unit of this type is kPa"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct EVAPVaporPressureAbsolute {
            v: crate::v2::units::KiloPascal<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl EVAPVaporPressureAbsolute {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 53 - Absolute evaporative purge (EVAP) system pressure. The unit of this type is kPa"]
            pub fn value(&self) -> &crate::v2::units::KiloPascal<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 53 - Absolute evaporative purge (EVAP) system pressure. The unit of this type is kPa"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::KiloPascal<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::KiloPascal<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::KiloPascal<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 54 - Alternate evaporative purge (EVAP) system pressure. The unit of this type is Pa"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct EVAPVaporPressureAlternate {
            v: crate::v2::units::Pascal<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl EVAPVaporPressureAlternate {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 54 - Alternate evaporative purge (EVAP) system pressure. The unit of this type is Pa"]
            pub fn value(&self) -> &crate::v2::units::Pascal<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 54 - Alternate evaporative purge (EVAP) system pressure. The unit of this type is Pa"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Pascal<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Pascal<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Pascal<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 55 (byte A) - Short term secondary O2 trim - Bank 1. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct ShortTermO2Trim1 {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl ShortTermO2Trim1 {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 55 (byte A) - Short term secondary O2 trim - Bank 1. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 55 (byte A) - Short term secondary O2 trim - Bank 1. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 55 (byte B) - Short term secondary O2 trim - Bank 3. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct ShortTermO2Trim3 {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl ShortTermO2Trim3 {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 55 (byte B) - Short term secondary O2 trim - Bank 3. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 55 (byte B) - Short term secondary O2 trim - Bank 3. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 56 (byte A) - Long term secondary O2 trim - Bank 1. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct LongTermO2Trim1 {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl LongTermO2Trim1 {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 56 (byte A) - Long term secondary O2 trim - Bank 1. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 56 (byte A) - Long term secondary O2 trim - Bank 1. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 56 (byte B) - Long term secondary O2 trim - Bank 3. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct LongTermO2Trim3 {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl LongTermO2Trim3 {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 56 (byte B) - Long term secondary O2 trim - Bank 3. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 56 (byte B) - Long term secondary O2 trim - Bank 3. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 57 (byte A) - Short term secondary O2 trim - Bank 2. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct ShortTermO2Trim2 {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl ShortTermO2Trim2 {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 57 (byte A) - Short term secondary O2 trim - Bank 2. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 57 (byte A) - Short term secondary O2 trim - Bank 2. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 57 (byte B) - Short term secondary O2 trim - Bank 4. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct ShortTermO2Trim4 {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl ShortTermO2Trim4 {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 57 (byte B) - Short term secondary O2 trim - Bank 4. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 57 (byte B) - Short term secondary O2 trim - Bank 4. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 58 (byte A) - Long term secondary O2 trim - Bank 2. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct LongTermO2Trim2 {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl LongTermO2Trim2 {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 58 (byte A) - Long term secondary O2 trim - Bank 2. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 58 (byte A) - Long term secondary O2 trim - Bank 2. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 58 (byte B) - Long term secondary O2 trim - Bank 4. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct LongTermO2Trim4 {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl LongTermO2Trim4 {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 58 (byte B) - Long term secondary O2 trim - Bank 4. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 58 (byte B) - Long term secondary O2 trim - Bank 4. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 59 - Absolute fuel rail pressure. The unit of this type is kPa"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct FuelRailPressureAbsolute {
            v: crate::v2::units::KiloPascal<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl FuelRailPressureAbsolute {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 59 - Absolute fuel rail pressure. The unit of this type is kPa"]
            pub fn value(&self) -> &crate::v2::units::KiloPascal<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 59 - Absolute fuel rail pressure. The unit of this type is kPa"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::KiloPascal<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::KiloPascal<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::KiloPascal<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 5A - Relative accelerator pedal position. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct RelativeAcceleratorPosition {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl RelativeAcceleratorPosition {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 5A - Relative accelerator pedal position. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 5A - Relative accelerator pedal position. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 5B - Remaining life of hybrid battery. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct HybridBatteryRemaining {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl HybridBatteryRemaining {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 5B - Remaining life of hybrid battery. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 5B - Remaining life of hybrid battery. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 5C - Engine oil temperature. The unit of this type is celsius"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct OilTemperature {
            v: crate::v2::units::Celsius<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl OilTemperature {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 5C - Engine oil temperature. The unit of this type is celsius"]
            pub fn value(&self) -> &crate::v2::units::Celsius<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 5C - Engine oil temperature. The unit of this type is celsius"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Celsius<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Celsius<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Celsius<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 5D - Fuel injection timing. The unit of this type is degrees"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct FuelInjectionTiming {
            v: f32,
            timestamp: crate::v2::Timestamp,
        }
        impl FuelInjectionTiming {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 5D - Fuel injection timing. The unit of this type is degrees"]
            pub fn value(&self) -> &f32 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 5D - Fuel injection timing. The unit of this type is degrees"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: f32, maybe_timestamp: Option<crate::v2::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &f32) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: f32, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "PID 5E - Engine fuel rate. The unit of this type is l/h"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct FuelRate {
            v: crate::v2::units::LiterPerHour<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl FuelRate {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "PID 5E - Engine fuel rate. The unit of this type is l/h"]
            pub fn value(&self) -> &crate::v2::units::LiterPerHour<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "PID 5E - Engine fuel rate. The unit of this type is l/h"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::LiterPerHour<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::LiterPerHour<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::LiterPerHour<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod drivecyclestatus {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Malfunction Indicator Light (MIL) - False = Off, True = On. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsMILOn {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsMILOn {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Malfunction Indicator Light (MIL) - False = Off, True = On. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Malfunction Indicator Light (MIL) - False = Off, True = On. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Number of sensor Trouble Codes (DTC). This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct DTCCount {
                v: u8,
                timestamp: crate::v2::Timestamp,
            }
            impl DTCCount {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Number of sensor Trouble Codes (DTC). This type has no unit defined"]
                pub fn value(&self) -> &u8 {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Number of sensor Trouble Codes (DTC). This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: u8, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &u8) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: u8, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Type of the ignition for ICE - spark = spark plug ignition, compression = self-igniting (Diesel engines). This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IgnitionType {
                v: String,
                timestamp: crate::v2::Timestamp,
            }
            impl IgnitionType {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Type of the ignition for ICE - spark = spark plug ignition, compression = self-igniting (Diesel engines). This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Type of the ignition for ICE - spark = spark plug ignition, compression = self-igniting (Diesel engines). This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: String,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod catalyst {
            #[allow(non_snake_case)]
            pub mod bank2 {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "PID 3D - Catalyst temperature from bank 2, sensor 1. The unit of this type is celsius"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Temperature1 {
                    v: crate::v2::units::Celsius<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    bank: u8,
                }
                impl Temperature1 {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 3D - Catalyst temperature from bank 2, sensor 1. The unit of this type is celsius"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,bank)"]
                    pub fn value(&self) -> (&crate::v2::units::Celsius<f32>, &u8) {
                        (&self.v, &self.bank)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 3D - Catalyst temperature from bank 2, sensor 1. The unit of this type is celsius"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Celsius<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        bank: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.bank = bank;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Celsius<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Celsius<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        bank: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                bank,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 3F - Catalyst temperature from bank 2, sensor 2. The unit of this type is celsius"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Temperature2 {
                    v: crate::v2::units::Celsius<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    bank: u8,
                }
                impl Temperature2 {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 3F - Catalyst temperature from bank 2, sensor 2. The unit of this type is celsius"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,bank)"]
                    pub fn value(&self) -> (&crate::v2::units::Celsius<f32>, &u8) {
                        (&self.v, &self.bank)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 3F - Catalyst temperature from bank 2, sensor 2. The unit of this type is celsius"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Celsius<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        bank: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.bank = bank;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Celsius<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Celsius<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        bank: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                bank,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod bank1 {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "PID 3C - Catalyst temperature from bank 1, sensor 1. The unit of this type is celsius"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Temperature1 {
                    v: crate::v2::units::Celsius<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    bank: u8,
                }
                impl Temperature1 {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 3C - Catalyst temperature from bank 1, sensor 1. The unit of this type is celsius"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,bank)"]
                    pub fn value(&self) -> (&crate::v2::units::Celsius<f32>, &u8) {
                        (&self.v, &self.bank)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 3C - Catalyst temperature from bank 1, sensor 1. The unit of this type is celsius"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Celsius<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        bank: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.bank = bank;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Celsius<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Celsius<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        bank: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                bank,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 3E - Catalyst temperature from bank 1, sensor 2. The unit of this type is celsius"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Temperature2 {
                    v: crate::v2::units::Celsius<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    bank: u8,
                }
                impl Temperature2 {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 3E - Catalyst temperature from bank 1, sensor 2. The unit of this type is celsius"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,bank)"]
                    pub fn value(&self) -> (&crate::v2::units::Celsius<f32>, &u8) {
                        (&self.v, &self.bank)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 3E - Catalyst temperature from bank 1, sensor 2. The unit of this type is celsius"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Celsius<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        bank: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.bank = bank;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Celsius<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Celsius<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        bank: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                bank,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod o2wr {
            #[allow(non_snake_case)]
            pub mod sensor8 {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Lambda {
                    v: f32,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Lambda {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&f32, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: f32,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &f32) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: f32,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Voltage {
                    v: crate::v2::units::Volt<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Voltage {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Volt<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Volt<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Volt<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Volt<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Current {
                    v: crate::v2::units::Amp<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Current {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Amp<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Amp<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Amp<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Amp<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod sensor7 {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Lambda {
                    v: f32,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Lambda {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&f32, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: f32,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &f32) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: f32,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Voltage {
                    v: crate::v2::units::Volt<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Voltage {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Volt<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Volt<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Volt<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Volt<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Current {
                    v: crate::v2::units::Amp<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Current {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Amp<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Amp<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Amp<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Amp<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod sensor6 {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Lambda {
                    v: f32,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Lambda {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&f32, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: f32,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &f32) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: f32,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Voltage {
                    v: crate::v2::units::Volt<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Voltage {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Volt<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Volt<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Volt<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Volt<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Current {
                    v: crate::v2::units::Amp<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Current {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Amp<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Amp<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Amp<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Amp<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod sensor5 {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Lambda {
                    v: f32,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Lambda {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&f32, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: f32,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &f32) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: f32,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Voltage {
                    v: crate::v2::units::Volt<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Voltage {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Volt<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Volt<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Volt<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Volt<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Current {
                    v: crate::v2::units::Amp<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Current {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Amp<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Amp<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Amp<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Amp<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod sensor4 {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Lambda {
                    v: f32,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Lambda {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&f32, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: f32,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &f32) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: f32,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Voltage {
                    v: crate::v2::units::Volt<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Voltage {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Volt<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Volt<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Volt<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Volt<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Current {
                    v: crate::v2::units::Amp<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Current {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Amp<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Amp<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Amp<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Amp<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod sensor3 {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Lambda {
                    v: f32,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Lambda {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&f32, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: f32,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &f32) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: f32,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Voltage {
                    v: crate::v2::units::Volt<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Voltage {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Volt<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Volt<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Volt<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Volt<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Current {
                    v: crate::v2::units::Amp<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Current {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Amp<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Amp<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Amp<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Amp<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod sensor2 {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Lambda {
                    v: f32,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Lambda {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&f32, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: f32,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &f32) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: f32,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Voltage {
                    v: crate::v2::units::Volt<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Voltage {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Volt<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Volt<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Volt<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Volt<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Current {
                    v: crate::v2::units::Amp<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Current {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Amp<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Amp<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Amp<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Amp<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod sensor1 {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Lambda {
                    v: f32,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Lambda {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&f32, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 2x (byte AB) and PID 3x (byte AB) - Lambda for wide range/band oxygen sensor. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: f32,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &f32) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: f32,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Voltage {
                    v: crate::v2::units::Volt<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Voltage {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Volt<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 2x (byte CD) - Voltage for wide range/band oxygen sensor. The unit of this type is V"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Volt<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Volt<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Volt<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Current {
                    v: crate::v2::units::Amp<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Current {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Amp<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 3x (byte CD) - Current for wide range/band oxygen sensor. The unit of this type is A"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Amp<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Amp<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Amp<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod o2 {
            #[allow(non_snake_case)]
            pub mod sensor8 {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "PID 1x (byte A) - Sensor voltage. The unit of this type is V"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Voltage {
                    v: crate::v2::units::Volt<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Voltage {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 1x (byte A) - Sensor voltage. The unit of this type is V"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Volt<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 1x (byte A) - Sensor voltage. The unit of this type is V"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Volt<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Volt<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Volt<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 1x (byte B) - Short term fuel trim. The unit of this type is percent"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct ShortTermFuelTrim {
                    v: crate::v2::units::Percent<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl ShortTermFuelTrim {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 1x (byte B) - Short term fuel trim. The unit of this type is percent"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Percent<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 1x (byte B) - Short term fuel trim. The unit of this type is percent"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Percent<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Percent<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod sensor7 {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "PID 1x (byte A) - Sensor voltage. The unit of this type is V"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Voltage {
                    v: crate::v2::units::Volt<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Voltage {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 1x (byte A) - Sensor voltage. The unit of this type is V"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Volt<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 1x (byte A) - Sensor voltage. The unit of this type is V"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Volt<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Volt<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Volt<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 1x (byte B) - Short term fuel trim. The unit of this type is percent"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct ShortTermFuelTrim {
                    v: crate::v2::units::Percent<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl ShortTermFuelTrim {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 1x (byte B) - Short term fuel trim. The unit of this type is percent"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Percent<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 1x (byte B) - Short term fuel trim. The unit of this type is percent"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Percent<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Percent<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod sensor6 {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "PID 1x (byte A) - Sensor voltage. The unit of this type is V"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Voltage {
                    v: crate::v2::units::Volt<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Voltage {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 1x (byte A) - Sensor voltage. The unit of this type is V"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Volt<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 1x (byte A) - Sensor voltage. The unit of this type is V"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Volt<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Volt<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Volt<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 1x (byte B) - Short term fuel trim. The unit of this type is percent"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct ShortTermFuelTrim {
                    v: crate::v2::units::Percent<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl ShortTermFuelTrim {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 1x (byte B) - Short term fuel trim. The unit of this type is percent"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Percent<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 1x (byte B) - Short term fuel trim. The unit of this type is percent"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Percent<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Percent<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod sensor5 {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "PID 1x (byte A) - Sensor voltage. The unit of this type is V"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Voltage {
                    v: crate::v2::units::Volt<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Voltage {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 1x (byte A) - Sensor voltage. The unit of this type is V"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Volt<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 1x (byte A) - Sensor voltage. The unit of this type is V"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Volt<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Volt<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Volt<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 1x (byte B) - Short term fuel trim. The unit of this type is percent"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct ShortTermFuelTrim {
                    v: crate::v2::units::Percent<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl ShortTermFuelTrim {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 1x (byte B) - Short term fuel trim. The unit of this type is percent"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Percent<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 1x (byte B) - Short term fuel trim. The unit of this type is percent"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Percent<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Percent<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod sensor4 {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "PID 1x (byte A) - Sensor voltage. The unit of this type is V"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Voltage {
                    v: crate::v2::units::Volt<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl Voltage {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 1x (byte A) - Sensor voltage. The unit of this type is V"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Volt<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 1x (byte A) - Sensor voltage. The unit of this type is V"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Volt<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Volt<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Volt<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "PID 1x (byte B) - Short term fuel trim. The unit of this type is percent"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct ShortTermFuelTrim {
                    v: crate::v2::units::Percent<f32>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    sensor: u8,
                }
                impl ShortTermFuelTrim {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "PID 1x (byte B) - Short term fuel trim. The unit of this type is percent"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,sensor)"]
                    pub fn value(&self) -> (&crate::v2::units::Percent<f32>, &u8) {
                        (&self.v, &self.sensor)
                    }
                    #[doc = r" Set the"]
                    #[doc = "PID 1x (byte B) - Short term fuel trim. The unit of this type is percent"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Percent<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.sensor = sensor;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Percent<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Percent<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                        sensor: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                sensor,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod status {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Malfunction Indicator Light (MIL) False = Off, True = On. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsMILOn {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsMILOn {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Malfunction Indicator Light (MIL) False = Off, True = On. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Malfunction Indicator Light (MIL) False = Off, True = On. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Number of sensor Trouble Codes (DTC). This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct DTCCount {
                v: u8,
                timestamp: crate::v2::Timestamp,
            }
            impl DTCCount {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Number of sensor Trouble Codes (DTC). This type has no unit defined"]
                pub fn value(&self) -> &u8 {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Number of sensor Trouble Codes (DTC). This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: u8, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &u8) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: u8, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Type of the ignition for ICE - spark = spark plug ignition, compression = self-igniting (Diesel engines). This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IgnitionType {
                v: String,
                timestamp: crate::v2::Timestamp,
            }
            impl IgnitionType {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Type of the ignition for ICE - spark = spark plug ignition, compression = self-igniting (Diesel engines). This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Type of the ignition for ICE - spark = spark plug ignition, compression = self-igniting (Diesel engines). This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: String,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
    }
    #[allow(non_snake_case)]
    pub mod chassis {
        use cdds_derive::Topic;
        use cyclonedds_rs::*;
        #[doc = "Overall wheel base, in mm.. The unit of this type is mm"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Wheelbase {
            v: crate::v2::units::Millimetre<u16>,
        }
        impl Wheelbase {
            #[doc = r" Get the "]
            #[doc = "Overall wheel base, in mm.. The unit of this type is mm"]
            pub fn value(&self) -> &crate::v2::units::Millimetre<u16> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Overall wheel base, in mm.. The unit of this type is mm"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: crate::v2::units::Millimetre<u16>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Millimetre<u16>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: crate::v2::units::Millimetre<u16>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "Overall wheel tracking, in mm.. The unit of this type is mm"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Track {
            v: crate::v2::units::Millimetre<u16>,
        }
        impl Track {
            #[doc = r" Get the "]
            #[doc = "Overall wheel tracking, in mm.. The unit of this type is mm"]
            pub fn value(&self) -> &crate::v2::units::Millimetre<u16> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Overall wheel tracking, in mm.. The unit of this type is mm"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: crate::v2::units::Millimetre<u16>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Millimetre<u16>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: crate::v2::units::Millimetre<u16>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "Number of axles on the vehicle. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct AxleCount {
            v: u8,
        }
        impl AxleCount {
            #[doc = r" Get the "]
            #[doc = "Number of axles on the vehicle. This type has no unit defined"]
            pub fn value(&self) -> &u8 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Number of axles on the vehicle. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u8) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u8) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u8) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod brake {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Brake pedal position as percent. 0 = Not depressed. 100 = Fully depressed.. The unit of this type is percent"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct PedalPosition {
                v: crate::v2::units::Percent<u8>,
                timestamp: crate::v2::Timestamp,
            }
            impl PedalPosition {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Brake pedal position as percent. 0 = Not depressed. 100 = Fully depressed.. The unit of this type is percent"]
                pub fn value(&self) -> &crate::v2::units::Percent<u8> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Brake pedal position as percent. 0 = Not depressed. 100 = Fully depressed.. The unit of this type is percent"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Percent<u8>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v2::units::Percent<u8>) -> bool {
                    v.0 <= 100u8 && v.0 >= 0u8
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Percent<u8>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates if emergency braking initiated by driver is detected. True = Emergency braking detected. False = Emergency braking not detected.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsDriverEmergencyBrakingDetected {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsDriverEmergencyBrakingDetected {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if emergency braking initiated by driver is detected. True = Emergency braking detected. False = Emergency braking not detected.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if emergency braking initiated by driver is detected. True = Emergency braking detected. False = Emergency braking not detected.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod accelerator {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Accelerator pedal position as percent. 0 = Not depressed. 100 = Fully depressed.. The unit of this type is percent"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct PedalPosition {
                v: crate::v2::units::Percent<u8>,
                timestamp: crate::v2::Timestamp,
            }
            impl PedalPosition {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Accelerator pedal position as percent. 0 = Not depressed. 100 = Fully depressed.. The unit of this type is percent"]
                pub fn value(&self) -> &crate::v2::units::Percent<u8> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Accelerator pedal position as percent. 0 = Not depressed. 100 = Fully depressed.. The unit of this type is percent"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Percent<u8>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v2::units::Percent<u8>) -> bool {
                    v.0 <= 100u8 && v.0 >= 0u8
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Percent<u8>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod steeringwheel {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Steering wheel angle. Positive = degrees to the left. Negative = degrees to the right.. The unit of this type is degrees"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Angle {
                v: i16,
                timestamp: crate::v2::Timestamp,
            }
            impl Angle {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Steering wheel angle. Positive = degrees to the left. Negative = degrees to the right.. The unit of this type is degrees"]
                pub fn value(&self) -> &i16 {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Steering wheel angle. Positive = degrees to the left. Negative = degrees to the right.. The unit of this type is degrees"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: i16, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &i16) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: i16, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Steering wheel column tilt. 0 = Lowest position. 100 = Highest position.. The unit of this type is percent"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Tilt {
                v: crate::v2::units::Percent<u8>,
                timestamp: crate::v2::Timestamp,
            }
            impl Tilt {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Steering wheel column tilt. 0 = Lowest position. 100 = Highest position.. The unit of this type is percent"]
                pub fn value(&self) -> &crate::v2::units::Percent<u8> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Steering wheel column tilt. 0 = Lowest position. 100 = Highest position.. The unit of this type is percent"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Percent<u8>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v2::units::Percent<u8>) -> bool {
                    v.0 <= 100u8 && v.0 >= 0u8
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Percent<u8>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Steering wheel column extension from dashboard. 0 = Closest to dashboard. 100 = Furthest from dashboard.. The unit of this type is percent"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Extension {
                v: crate::v2::units::Percent<u8>,
                timestamp: crate::v2::Timestamp,
            }
            impl Extension {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Steering wheel column extension from dashboard. 0 = Closest to dashboard. 100 = Furthest from dashboard.. The unit of this type is percent"]
                pub fn value(&self) -> &crate::v2::units::Percent<u8> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Steering wheel column extension from dashboard. 0 = Closest to dashboard. 100 = Furthest from dashboard.. The unit of this type is percent"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Percent<u8>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v2::units::Percent<u8>) -> bool {
                    v.0 <= 100u8 && v.0 >= 0u8
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Percent<u8>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Position of the steering wheel on the left or right side of the vehicle.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Position {
                v: String,
            }
            impl Position {
                #[doc = r" Get the "]
                #[doc = "Position of the steering wheel on the left or right side of the vehicle.. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Position of the steering wheel on the left or right side of the vehicle.. This type has no unit defined"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: String) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod parkingbrake {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Parking brake status. True = Parking Brake is Engaged. False = Parking Brake is not Engaged.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsEngaged {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsEngaged {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Parking brake status. True = Parking Brake is Engaged. False = Parking Brake is not Engaged.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Parking brake status. True = Parking Brake is Engaged. False = Parking Brake is not Engaged.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod axle {
            #[allow(non_snake_case)]
            pub mod wheel {
                #[allow(non_snake_case)]
                pub mod brake {
                    use cdds_derive::Topic;
                    use cyclonedds_rs::*;
                    #[doc = "Brake fluid level as percent. 0 = Empty. 100 = Full.. The unit of this type is percent"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct FluidLevel {
                        v: crate::v2::units::Percent<u8>,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key]
                        row: u8,
                        #[topic_key_enum]
                        side: crate::v2::Side,
                    }
                    impl FluidLevel {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Brake fluid level as percent. 0 = Empty. 100 = Full.. The unit of this type is percent"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, side)"]
                        pub fn value(
                            &self,
                        ) -> (&crate::v2::units::Percent<u8>, &u8, &crate::v2::Side)
                        {
                            (&self.v, &self.row, &self.side)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Brake fluid level as percent. 0 = Empty. 100 = Full.. The unit of this type is percent"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: crate::v2::units::Percent<u8>,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            side: crate::v2::Side,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.row = row;
                            self.side = side;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. Return true if the value is"]
                        #[doc = r"within bounds."]
                        pub fn bounds_check(v: &crate::v2::units::Percent<u8>) -> bool {
                            v.0 <= 100u8 && true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: crate::v2::units::Percent<u8>,
                            timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            side: crate::v2::Side,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    side,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Brake fluid level status. True = Brake fluid level low. False = Brake fluid level OK.. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct IsFluidLevelLow {
                        v: bool,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key]
                        row: u8,
                        #[topic_key_enum]
                        side: crate::v2::Side,
                    }
                    impl IsFluidLevelLow {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Brake fluid level status. True = Brake fluid level low. False = Brake fluid level OK.. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, side)"]
                        pub fn value(&self) -> (&bool, &u8, &crate::v2::Side) {
                            (&self.v, &self.row, &self.side)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Brake fluid level status. True = Brake fluid level low. False = Brake fluid level OK.. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            side: crate::v2::Side,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.row = row;
                            self.side = side;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            side: crate::v2::Side,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    side,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Brake pad wear as percent. 0 = No Wear. 100 = Worn.. The unit of this type is percent"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct PadWear {
                        v: crate::v2::units::Percent<u8>,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key]
                        row: u8,
                        #[topic_key_enum]
                        side: crate::v2::Side,
                    }
                    impl PadWear {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Brake pad wear as percent. 0 = No Wear. 100 = Worn.. The unit of this type is percent"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, side)"]
                        pub fn value(
                            &self,
                        ) -> (&crate::v2::units::Percent<u8>, &u8, &crate::v2::Side)
                        {
                            (&self.v, &self.row, &self.side)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Brake pad wear as percent. 0 = No Wear. 100 = Worn.. The unit of this type is percent"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: crate::v2::units::Percent<u8>,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            side: crate::v2::Side,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.row = row;
                            self.side = side;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. Return true if the value is"]
                        #[doc = r"within bounds."]
                        pub fn bounds_check(v: &crate::v2::units::Percent<u8>) -> bool {
                            v.0 <= 100u8 && true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: crate::v2::units::Percent<u8>,
                            timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            side: crate::v2::Side,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    side,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Brake pad wear status. True = Worn. False = Not Worn.. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct IsBrakesWorn {
                        v: bool,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key]
                        row: u8,
                        #[topic_key_enum]
                        side: crate::v2::Side,
                    }
                    impl IsBrakesWorn {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Brake pad wear status. True = Worn. False = Not Worn.. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, side)"]
                        pub fn value(&self) -> (&bool, &u8, &crate::v2::Side) {
                            (&self.v, &self.row, &self.side)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Brake pad wear status. True = Worn. False = Not Worn.. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            side: crate::v2::Side,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.row = row;
                            self.side = side;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            side: crate::v2::Side,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    side,
                                })
                            } else {
                                None
                            }
                        }
                    }
                }
                #[allow(non_snake_case)]
                pub mod tire {
                    use cdds_derive::Topic;
                    use cyclonedds_rs::*;
                    #[doc = "Tire pressure in kilo-Pascal.. The unit of this type is kPa"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Pressure {
                        v: crate::v2::units::KiloPascal<u16>,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key]
                        row: u8,
                        #[topic_key_enum]
                        side: crate::v2::Side,
                    }
                    impl Pressure {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Tire pressure in kilo-Pascal.. The unit of this type is kPa"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, side)"]
                        pub fn value(
                            &self,
                        ) -> (&crate::v2::units::KiloPascal<u16>, &u8, &crate::v2::Side)
                        {
                            (&self.v, &self.row, &self.side)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Tire pressure in kilo-Pascal.. The unit of this type is kPa"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: crate::v2::units::KiloPascal<u16>,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            side: crate::v2::Side,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.row = row;
                            self.side = side;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &crate::v2::units::KiloPascal<u16>) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: crate::v2::units::KiloPascal<u16>,
                            timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            side: crate::v2::Side,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    side,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Tire Pressure Status. True = Low tire pressure. False = Good tire pressure.. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct IsPressureLow {
                        v: bool,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key]
                        row: u8,
                        #[topic_key_enum]
                        side: crate::v2::Side,
                    }
                    impl IsPressureLow {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Tire Pressure Status. True = Low tire pressure. False = Good tire pressure.. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, side)"]
                        pub fn value(&self) -> (&bool, &u8, &crate::v2::Side) {
                            (&self.v, &self.row, &self.side)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Tire Pressure Status. True = Low tire pressure. False = Good tire pressure.. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            side: crate::v2::Side,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.row = row;
                            self.side = side;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            side: crate::v2::Side,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    side,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Tire temperature in Celsius.. The unit of this type is celsius"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Temperature {
                        v: crate::v2::units::Celsius<f32>,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key]
                        row: u8,
                        #[topic_key_enum]
                        side: crate::v2::Side,
                    }
                    impl Temperature {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Tire temperature in Celsius.. The unit of this type is celsius"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, side)"]
                        pub fn value(
                            &self,
                        ) -> (&crate::v2::units::Celsius<f32>, &u8, &crate::v2::Side)
                        {
                            (&self.v, &self.row, &self.side)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Tire temperature in Celsius.. The unit of this type is celsius"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: crate::v2::units::Celsius<f32>,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            side: crate::v2::Side,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.row = row;
                            self.side = side;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &crate::v2::units::Celsius<f32>) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: crate::v2::units::Celsius<f32>,
                            timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            side: crate::v2::Side,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    side,
                                })
                            } else {
                                None
                            }
                        }
                    }
                }
            }
        }
    }
    #[allow(non_snake_case)]
    pub mod adas {
        use cdds_derive::Topic;
        use cyclonedds_rs::*;
        #[doc = "Indicates the currently active level of autonomy according to SAE J3016 taxonomy.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct ActiveAutonomyLevel {
            v: String,
            timestamp: crate::v2::Timestamp,
        }
        impl ActiveAutonomyLevel {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Indicates the currently active level of autonomy according to SAE J3016 taxonomy.. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Indicates the currently active level of autonomy according to SAE J3016 taxonomy.. This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String, maybe_timestamp: Option<crate::v2::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Indicates the highest level of autonomy according to SAE J3016 taxonomy the vehicle is capable of.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct SupportedAutonomyLevel {
            v: String,
        }
        impl SupportedAutonomyLevel {
            #[doc = r" Get the "]
            #[doc = "Indicates the highest level of autonomy according to SAE J3016 taxonomy the vehicle is capable of.. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Indicates the highest level of autonomy according to SAE J3016 taxonomy the vehicle is capable of.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod eba {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Indicates if EBA is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsEnabled {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsEnabled {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if EBA is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if EBA is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates if EBA incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsError {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsError {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if EBA incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if EBA incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates if EBA is currently regulating brake pressure. True = Engaged. False = Not Engaged.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsEngaged {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsEngaged {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if EBA is currently regulating brake pressure. True = Engaged. False = Not Engaged.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if EBA is currently regulating brake pressure. True = Engaged. False = Not Engaged.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod ebd {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Indicates if EBD is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsEnabled {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsEnabled {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if EBD is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if EBD is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates if EBD incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsError {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsError {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if EBD incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if EBD incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates if EBD is currently regulating vehicle brakeforce distribution. True = Engaged. False = Not Engaged.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsEngaged {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsEngaged {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if EBD is currently regulating vehicle brakeforce distribution. True = Engaged. False = Not Engaged.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if EBD is currently regulating vehicle brakeforce distribution. True = Engaged. False = Not Engaged.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod esc {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Indicates if ESC is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsEnabled {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsEnabled {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if ESC is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if ESC is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates if ESC incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsError {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsError {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if ESC incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if ESC incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates if ESC is currently regulating vehicle stability. True = Engaged. False = Not Engaged.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsEngaged {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsEngaged {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if ESC is currently regulating vehicle stability. True = Engaged. False = Not Engaged.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if ESC is currently regulating vehicle stability. True = Engaged. False = Not Engaged.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates if the ESC system is detecting strong cross winds. True = Strong cross winds detected. False = No strong cross winds detected.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsStrongCrossWindDetected {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsStrongCrossWindDetected {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if the ESC system is detecting strong cross winds. True = Strong cross winds detected. False = No strong cross winds detected.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if the ESC system is detecting strong cross winds. True = Strong cross winds detected. False = No strong cross winds detected.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod roadfriction {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Most probable road friction, as calculated by the ESC system. Exact meaning of most probable is implementation specific. 0 = no friction, 100 = maximum friction.. The unit of this type is percent"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct MostProbable {
                    v: crate::v2::units::Percent<f32>,
                    timestamp: crate::v2::Timestamp,
                }
                impl MostProbable {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Most probable road friction, as calculated by the ESC system. Exact meaning of most probable is implementation specific. 0 = no friction, 100 = maximum friction.. The unit of this type is percent"]
                    pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Most probable road friction, as calculated by the ESC system. Exact meaning of most probable is implementation specific. 0 = no friction, 100 = maximum friction.. The unit of this type is percent"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Percent<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v2::units::Percent<f32>) -> bool {
                        v.0 <= 100f32 && v.0 >= 0f32
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Percent<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Lower bound road friction, as calculated by the ESC system. 5% possibility that road friction is below this value. 0 = no friction, 100 = maximum friction.. The unit of this type is percent"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct LowerBound {
                    v: crate::v2::units::Percent<f32>,
                    timestamp: crate::v2::Timestamp,
                }
                impl LowerBound {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Lower bound road friction, as calculated by the ESC system. 5% possibility that road friction is below this value. 0 = no friction, 100 = maximum friction.. The unit of this type is percent"]
                    pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Lower bound road friction, as calculated by the ESC system. 5% possibility that road friction is below this value. 0 = no friction, 100 = maximum friction.. The unit of this type is percent"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Percent<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v2::units::Percent<f32>) -> bool {
                        v.0 <= 100f32 && v.0 >= 0f32
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Percent<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Upper bound road friction, as calculated by the ESC system. 95% possibility that road friction is below this value. 0 = no friction, 100 = maximum friction.. The unit of this type is percent"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct UpperBound {
                    v: crate::v2::units::Percent<f32>,
                    timestamp: crate::v2::Timestamp,
                }
                impl UpperBound {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Upper bound road friction, as calculated by the ESC system. 95% possibility that road friction is below this value. 0 = no friction, 100 = maximum friction.. The unit of this type is percent"]
                    pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Upper bound road friction, as calculated by the ESC system. 95% possibility that road friction is below this value. 0 = no friction, 100 = maximum friction.. The unit of this type is percent"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Percent<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v2::units::Percent<f32>) -> bool {
                        v.0 <= 100f32 && v.0 >= 0f32
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Percent<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod tcs {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Indicates if TCS is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsEnabled {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsEnabled {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if TCS is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if TCS is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates if TCS incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsError {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsError {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if TCS incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if TCS incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates if TCS is currently regulating traction. True = Engaged. False = Not Engaged.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsEngaged {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsEngaged {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if TCS is currently regulating traction. True = Engaged. False = Not Engaged.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if TCS is currently regulating traction. True = Engaged. False = Not Engaged.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod abs {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Indicates if ABS is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsEnabled {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsEnabled {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if ABS is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if ABS is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates if ABS incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsError {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsError {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if ABS incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if ABS incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates if ABS is currently regulating brake pressure. True = Engaged. False = Not Engaged.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsEngaged {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsEngaged {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if ABS is currently regulating brake pressure. True = Engaged. False = Not Engaged.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if ABS is currently regulating brake pressure. True = Engaged. False = Not Engaged.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod obstacledetection {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Indicates if obstacle sensor system is enabled (i.e. monitoring for obstacles). True = Enabled. False = Disabled.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsEnabled {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsEnabled {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if obstacle sensor system is enabled (i.e. monitoring for obstacles). True = Enabled. False = Disabled.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if obstacle sensor system is enabled (i.e. monitoring for obstacles). True = Enabled. False = Disabled.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates if obstacle sensor system registered an obstacle.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsWarning {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsWarning {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if obstacle sensor system registered an obstacle.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if obstacle sensor system registered an obstacle.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates if obstacle sensor system incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsError {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsError {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if obstacle sensor system incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if obstacle sensor system incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod lanedeparturedetection {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Indicates if lane departure detection system is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsEnabled {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsEnabled {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if lane departure detection system is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if lane departure detection system is enabled. True = Enabled. False = Disabled.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates if lane departure detection registered a lane departure.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsWarning {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsWarning {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if lane departure detection registered a lane departure.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if lane departure detection registered a lane departure.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates if lane departure system incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsError {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsError {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if lane departure system incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if lane departure system incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod cruisecontrol {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Indicates if cruise control system is enabled (e.g. ready to receive configurations and settings) True = Enabled. False = Disabled.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsEnabled {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsEnabled {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if cruise control system is enabled (e.g. ready to receive configurations and settings) True = Enabled. False = Disabled.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if cruise control system is enabled (e.g. ready to receive configurations and settings) True = Enabled. False = Disabled.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates if cruise control system is active (i.e. actively controls speed). True = Active. False = Inactive.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsActive {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsActive {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if cruise control system is active (i.e. actively controls speed). True = Active. False = Inactive.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if cruise control system is active (i.e. actively controls speed). True = Active. False = Inactive.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Set cruise control speed in kilometers per hour.. The unit of this type is km/h"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct SpeedSet {
                v: crate::v2::units::KilometrePerHour<f32>,
                timestamp: crate::v2::Timestamp,
            }
            impl SpeedSet {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Set cruise control speed in kilometers per hour.. The unit of this type is km/h"]
                pub fn value(&self) -> &crate::v2::units::KilometrePerHour<f32> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Set cruise control speed in kilometers per hour.. The unit of this type is km/h"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::KilometrePerHour<f32>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::KilometrePerHour<f32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::KilometrePerHour<f32>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates if cruise control system incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsError {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsError {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates if cruise control system incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicates if cruise control system incurred an error condition. True = Error. False = No Error.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
    }
    #[allow(non_snake_case)]
    pub mod cabin {
        use cdds_derive::Topic;
        use cyclonedds_rs::*;
        #[doc = "Number of doors in vehicle.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct DoorCount {
            v: u8,
        }
        impl DoorCount {
            #[doc = r" Get the "]
            #[doc = "Number of doors in vehicle.. This type has no unit defined"]
            pub fn value(&self) -> &u8 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Number of doors in vehicle.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u8) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u8) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u8) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "The position of the driver seat in row 1.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct DriverPosition {
            v: u8,
        }
        impl DriverPosition {
            #[doc = r" Get the "]
            #[doc = "The position of the driver seat in row 1.. This type has no unit defined"]
            pub fn value(&self) -> &u8 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "The position of the driver seat in row 1.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u8) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u8) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u8) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "Number of seat rows in vehicle.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct SeatRowCount {
            v: u8,
        }
        impl SeatRowCount {
            #[doc = r" Get the "]
            #[doc = "Number of seat rows in vehicle.. This type has no unit defined"]
            pub fn value(&self) -> &u8 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Number of seat rows in vehicle.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u8) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u8) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u8) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "Number of seats across each row from the front to the rear.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct SeatPosCount {
            v: Vec<u8>,
        }
        impl SeatPosCount {
            #[doc = r" Get the "]
            #[doc = "Number of seats across each row from the front to the rear.. This type has no unit defined"]
            pub fn value(&self) -> &Vec<u8> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Number of seats across each row from the front to the rear.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: Vec<u8>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &Vec<u8>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: Vec<u8>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod convertible {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Roof status on convertible vehicles.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Status {
                v: String,
                timestamp: crate::v2::Timestamp,
            }
            impl Status {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Roof status on convertible vehicles.. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Roof status on convertible vehicles.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: String,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod seat {
            #[allow(non_snake_case)]
            pub mod occupant {
                #[allow(non_snake_case)]
                pub mod identifier {
                    use cdds_derive::Topic;
                    use cyclonedds_rs::*;
                    #[doc = "Subject for the authentication of the occupant. E.g. UserID 7331677.. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Subject {
                        v: String,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key]
                        row: u8,
                        #[topic_key]
                        pos: u8,
                    }
                    impl Subject {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Subject for the authentication of the occupant. E.g. UserID 7331677.. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, pos)"]
                        pub fn value(&self) -> (&String, &u8, &u8) {
                            (&self.v, &self.row, &self.pos)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Subject for the authentication of the occupant. E.g. UserID 7331677.. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: String,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.row = row;
                            self.pos = pos;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &String) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: String,
                            timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    pos,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Unique Issuer for the authentication of the occupant. E.g. https://accounts.funcorp.com.. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Issuer {
                        v: String,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key]
                        row: u8,
                        #[topic_key]
                        pos: u8,
                    }
                    impl Issuer {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Unique Issuer for the authentication of the occupant. E.g. https://accounts.funcorp.com.. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, pos)"]
                        pub fn value(&self) -> (&String, &u8, &u8) {
                            (&self.v, &self.row, &self.pos)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Unique Issuer for the authentication of the occupant. E.g. https://accounts.funcorp.com.. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: String,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.row = row;
                            self.pos = pos;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &String) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: String,
                            timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    pos,
                                })
                            } else {
                                None
                            }
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod backrest {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Backrest recline compared to seat z-axis (seat vertical axis). 0 degrees = Upright/Vertical backrest. Negative degrees for forward recline. Positive degrees for backward recline.. The unit of this type is degrees"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Recline {
                    v: f32,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    row: u8,
                    #[topic_key]
                    pos: u8,
                }
                impl Recline {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Backrest recline compared to seat z-axis (seat vertical axis). 0 degrees = Upright/Vertical backrest. Negative degrees for forward recline. Positive degrees for backward recline.. The unit of this type is degrees"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, pos)"]
                    pub fn value(&self) -> (&f32, &u8, &u8) {
                        (&self.v, &self.row, &self.pos)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Backrest recline compared to seat z-axis (seat vertical axis). 0 degrees = Upright/Vertical backrest. Negative degrees for forward recline. Positive degrees for backward recline.. The unit of this type is degrees"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: f32,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.row = row;
                        self.pos = pos;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &f32) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: f32,
                        timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                pos,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[allow(non_snake_case)]
                pub mod sidebolster {
                    use cdds_derive::Topic;
                    use cyclonedds_rs::*;
                    #[doc = "Side bolster support. 0 = Minimum support (widest side bolster setting). 100 = Maximum support.. The unit of this type is percent"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Support {
                        v: crate::v2::units::Percent<f32>,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key]
                        row: u8,
                        #[topic_key]
                        pos: u8,
                    }
                    impl Support {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Side bolster support. 0 = Minimum support (widest side bolster setting). 100 = Maximum support.. The unit of this type is percent"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, pos)"]
                        pub fn value(&self) -> (&crate::v2::units::Percent<f32>, &u8, &u8) {
                            (&self.v, &self.row, &self.pos)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Side bolster support. 0 = Minimum support (widest side bolster setting). 100 = Maximum support.. The unit of this type is percent"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: crate::v2::units::Percent<f32>,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.row = row;
                            self.pos = pos;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. Return true if the value is"]
                        #[doc = r"within bounds."]
                        pub fn bounds_check(v: &crate::v2::units::Percent<f32>) -> bool {
                            v.0 <= 100f32 && v.0 >= 0f32
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: crate::v2::units::Percent<f32>,
                            timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    pos,
                                })
                            } else {
                                None
                            }
                        }
                    }
                }
                #[allow(non_snake_case)]
                pub mod lumbar {
                    use cdds_derive::Topic;
                    use cyclonedds_rs::*;
                    #[doc = "Lumbar support (in/out position). 0 = Innermost position. 100 = Outermost position.. The unit of this type is percent"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Support {
                        v: crate::v2::units::Percent<f32>,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key]
                        row: u8,
                        #[topic_key]
                        pos: u8,
                    }
                    impl Support {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Lumbar support (in/out position). 0 = Innermost position. 100 = Outermost position.. The unit of this type is percent"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, pos)"]
                        pub fn value(&self) -> (&crate::v2::units::Percent<f32>, &u8, &u8) {
                            (&self.v, &self.row, &self.pos)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Lumbar support (in/out position). 0 = Innermost position. 100 = Outermost position.. The unit of this type is percent"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: crate::v2::units::Percent<f32>,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.row = row;
                            self.pos = pos;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. Return true if the value is"]
                        #[doc = r"within bounds."]
                        pub fn bounds_check(v: &crate::v2::units::Percent<f32>) -> bool {
                            v.0 <= 100f32 && v.0 >= 0f32
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: crate::v2::units::Percent<f32>,
                            timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    pos,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Height of lumbar support. Position is relative within available movable range of the lumbar support. 0 = Lowermost position supported.. The unit of this type is mm"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Height {
                        v: crate::v2::units::Millimetre<u8>,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key]
                        row: u8,
                        #[topic_key]
                        pos: u8,
                    }
                    impl Height {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Height of lumbar support. Position is relative within available movable range of the lumbar support. 0 = Lowermost position supported.. The unit of this type is mm"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, pos)"]
                        pub fn value(&self) -> (&crate::v2::units::Millimetre<u8>, &u8, &u8) {
                            (&self.v, &self.row, &self.pos)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Height of lumbar support. Position is relative within available movable range of the lumbar support. 0 = Lowermost position supported.. The unit of this type is mm"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: crate::v2::units::Millimetre<u8>,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.row = row;
                            self.pos = pos;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. Return true if the value is"]
                        #[doc = r"within bounds."]
                        pub fn bounds_check(v: &crate::v2::units::Millimetre<u8>) -> bool {
                            true && v.0 >= 0u8
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: crate::v2::units::Millimetre<u8>,
                            timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    pos,
                                })
                            } else {
                                None
                            }
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod seating {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Length adjustment of seating. 0 = Adjustable part of seating in rearmost position (Shortest length of seating).. The unit of this type is mm"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Length {
                    v: crate::v2::units::Millimetre<u16>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    row: u8,
                    #[topic_key]
                    pos: u8,
                }
                impl Length {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Length adjustment of seating. 0 = Adjustable part of seating in rearmost position (Shortest length of seating).. The unit of this type is mm"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, pos)"]
                    pub fn value(&self) -> (&crate::v2::units::Millimetre<u16>, &u8, &u8) {
                        (&self.v, &self.row, &self.pos)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Length adjustment of seating. 0 = Adjustable part of seating in rearmost position (Shortest length of seating).. The unit of this type is mm"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Millimetre<u16>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.row = row;
                        self.pos = pos;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v2::units::Millimetre<u16>) -> bool {
                        true && v.0 >= 0u16
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Millimetre<u16>,
                        timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                pos,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod headrest {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Position of headrest relative to movable range of the head rest. 0 = Bottommost position supported.. The unit of this type is mm"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Height {
                    v: crate::v2::units::Millimetre<u8>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    row: u8,
                    #[topic_key]
                    pos: u8,
                }
                impl Height {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Position of headrest relative to movable range of the head rest. 0 = Bottommost position supported.. The unit of this type is mm"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, pos)"]
                    pub fn value(&self) -> (&crate::v2::units::Millimetre<u8>, &u8, &u8) {
                        (&self.v, &self.row, &self.pos)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Position of headrest relative to movable range of the head rest. 0 = Bottommost position supported.. The unit of this type is mm"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Millimetre<u8>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.row = row;
                        self.pos = pos;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v2::units::Millimetre<u8>) -> bool {
                        true && v.0 >= 0u8
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Millimetre<u8>,
                        timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                pos,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Headrest angle, relative to backrest, 0 degrees if parallel to backrest, Positive degrees = tilted forward.. The unit of this type is degrees"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Angle {
                    v: f32,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    row: u8,
                    #[topic_key]
                    pos: u8,
                }
                impl Angle {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Headrest angle, relative to backrest, 0 degrees if parallel to backrest, Positive degrees = tilted forward.. The unit of this type is degrees"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, pos)"]
                    pub fn value(&self) -> (&f32, &u8, &u8) {
                        (&self.v, &self.row, &self.pos)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Headrest angle, relative to backrest, 0 degrees if parallel to backrest, Positive degrees = tilted forward.. The unit of this type is degrees"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: f32,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.row = row;
                        self.pos = pos;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &f32) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: f32,
                        timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                pos,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod airbag {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Airbag deployment status. True = Airbag deployed. False = Airbag not deployed.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct IsDeployed {
                    v: bool,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    row: u8,
                    #[topic_key]
                    pos: u8,
                }
                impl IsDeployed {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Airbag deployment status. True = Airbag deployed. False = Airbag not deployed.. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, pos)"]
                    pub fn value(&self) -> (&bool, &u8, &u8) {
                        (&self.v, &self.row, &self.pos)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Airbag deployment status. True = Airbag deployed. False = Airbag not deployed.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.row = row;
                        self.pos = pos;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                pos,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod switch {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Warmer switch for Seat heater (SingleSeat.Heating).. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct IsWarmerEngaged {
                    v: bool,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    row: u8,
                    #[topic_key]
                    pos: u8,
                }
                impl IsWarmerEngaged {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Warmer switch for Seat heater (SingleSeat.Heating).. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, pos)"]
                    pub fn value(&self) -> (&bool, &u8, &u8) {
                        (&self.v, &self.row, &self.pos)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Warmer switch for Seat heater (SingleSeat.Heating).. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.row = row;
                        self.pos = pos;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                pos,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Cooler switch for Seat heater (SingleSeat.Heating).. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct IsCoolerEngaged {
                    v: bool,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    row: u8,
                    #[topic_key]
                    pos: u8,
                }
                impl IsCoolerEngaged {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Cooler switch for Seat heater (SingleSeat.Heating).. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, pos)"]
                    pub fn value(&self) -> (&bool, &u8, &u8) {
                        (&self.v, &self.row, &self.pos)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Cooler switch for Seat heater (SingleSeat.Heating).. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.row = row;
                        self.pos = pos;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                pos,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Seat forward switch engaged (SingleSeat.Position).. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct IsForwardEngaged {
                    v: bool,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    row: u8,
                    #[topic_key]
                    pos: u8,
                }
                impl IsForwardEngaged {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Seat forward switch engaged (SingleSeat.Position).. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, pos)"]
                    pub fn value(&self) -> (&bool, &u8, &u8) {
                        (&self.v, &self.row, &self.pos)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Seat forward switch engaged (SingleSeat.Position).. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.row = row;
                        self.pos = pos;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                pos,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Seat backward switch engaged (SingleSeat.Position).. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct IsBackwardEngaged {
                    v: bool,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    row: u8,
                    #[topic_key]
                    pos: u8,
                }
                impl IsBackwardEngaged {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Seat backward switch engaged (SingleSeat.Position).. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, pos)"]
                    pub fn value(&self) -> (&bool, &u8, &u8) {
                        (&self.v, &self.row, &self.pos)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Seat backward switch engaged (SingleSeat.Position).. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.row = row;
                        self.pos = pos;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                pos,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Seat up switch engaged (SingleSeat.Height).. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct IsUpEngaged {
                    v: bool,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    row: u8,
                    #[topic_key]
                    pos: u8,
                }
                impl IsUpEngaged {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Seat up switch engaged (SingleSeat.Height).. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, pos)"]
                    pub fn value(&self) -> (&bool, &u8, &u8) {
                        (&self.v, &self.row, &self.pos)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Seat up switch engaged (SingleSeat.Height).. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.row = row;
                        self.pos = pos;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                pos,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Seat down switch engaged (SingleSeat.Height).. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct IsDownEngaged {
                    v: bool,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    row: u8,
                    #[topic_key]
                    pos: u8,
                }
                impl IsDownEngaged {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Seat down switch engaged (SingleSeat.Height).. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, pos)"]
                    pub fn value(&self) -> (&bool, &u8, &u8) {
                        (&self.v, &self.row, &self.pos)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Seat down switch engaged (SingleSeat.Height).. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.row = row;
                        self.pos = pos;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                pos,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Tilt forward switch engaged (SingleSeat.Tilt).. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct IsTiltForwardEngaged {
                    v: bool,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    row: u8,
                    #[topic_key]
                    pos: u8,
                }
                impl IsTiltForwardEngaged {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Tilt forward switch engaged (SingleSeat.Tilt).. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, pos)"]
                    pub fn value(&self) -> (&bool, &u8, &u8) {
                        (&self.v, &self.row, &self.pos)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Tilt forward switch engaged (SingleSeat.Tilt).. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.row = row;
                        self.pos = pos;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                pos,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Tilt backward switch engaged (SingleSeat.Tilt).. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct IsTiltBackwardEngaged {
                    v: bool,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    row: u8,
                    #[topic_key]
                    pos: u8,
                }
                impl IsTiltBackwardEngaged {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Tilt backward switch engaged (SingleSeat.Tilt).. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, pos)"]
                    pub fn value(&self) -> (&bool, &u8, &u8) {
                        (&self.v, &self.row, &self.pos)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Tilt backward switch engaged (SingleSeat.Tilt).. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.row = row;
                        self.pos = pos;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        pos: u8,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                pos,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[allow(non_snake_case)]
                pub mod massage {
                    use cdds_derive::Topic;
                    use cyclonedds_rs::*;
                    #[doc = "Increase massage level switch engaged (SingleSeat.Massage).. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct IsIncreaseEngaged {
                        v: bool,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key]
                        row: u8,
                        #[topic_key]
                        pos: u8,
                    }
                    impl IsIncreaseEngaged {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Increase massage level switch engaged (SingleSeat.Massage).. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, pos)"]
                        pub fn value(&self) -> (&bool, &u8, &u8) {
                            (&self.v, &self.row, &self.pos)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Increase massage level switch engaged (SingleSeat.Massage).. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.row = row;
                            self.pos = pos;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    pos,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Decrease massage level switch engaged (SingleSeat.Massage).. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct IsDecreaseEngaged {
                        v: bool,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key]
                        row: u8,
                        #[topic_key]
                        pos: u8,
                    }
                    impl IsDecreaseEngaged {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Decrease massage level switch engaged (SingleSeat.Massage).. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, pos)"]
                        pub fn value(&self) -> (&bool, &u8, &u8) {
                            (&self.v, &self.row, &self.pos)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Decrease massage level switch engaged (SingleSeat.Massage).. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.row = row;
                            self.pos = pos;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    pos,
                                })
                            } else {
                                None
                            }
                        }
                    }
                }
                #[allow(non_snake_case)]
                pub mod headrest {
                    use cdds_derive::Topic;
                    use cyclonedds_rs::*;
                    #[doc = "Head rest up switch engaged (SingleSeat.Headrest.Height).. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct IsUpEngaged {
                        v: bool,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key]
                        row: u8,
                        #[topic_key]
                        pos: u8,
                    }
                    impl IsUpEngaged {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Head rest up switch engaged (SingleSeat.Headrest.Height).. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, pos)"]
                        pub fn value(&self) -> (&bool, &u8, &u8) {
                            (&self.v, &self.row, &self.pos)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Head rest up switch engaged (SingleSeat.Headrest.Height).. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.row = row;
                            self.pos = pos;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    pos,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Head rest down switch engaged (SingleSeat.Headrest.Height).. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct IsDownEngaged {
                        v: bool,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key]
                        row: u8,
                        #[topic_key]
                        pos: u8,
                    }
                    impl IsDownEngaged {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Head rest down switch engaged (SingleSeat.Headrest.Height).. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, pos)"]
                        pub fn value(&self) -> (&bool, &u8, &u8) {
                            (&self.v, &self.row, &self.pos)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Head rest down switch engaged (SingleSeat.Headrest.Height).. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.row = row;
                            self.pos = pos;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    pos,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Head rest forward switch engaged (SingleSeat.Headrest.Angle).. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct IsForwardEngaged {
                        v: bool,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key]
                        row: u8,
                        #[topic_key]
                        pos: u8,
                    }
                    impl IsForwardEngaged {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Head rest forward switch engaged (SingleSeat.Headrest.Angle).. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, pos)"]
                        pub fn value(&self) -> (&bool, &u8, &u8) {
                            (&self.v, &self.row, &self.pos)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Head rest forward switch engaged (SingleSeat.Headrest.Angle).. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.row = row;
                            self.pos = pos;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    pos,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Head rest backward switch engaged (SingleSeat.Headrest.Angle).. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct IsBackwardEngaged {
                        v: bool,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key]
                        row: u8,
                        #[topic_key]
                        pos: u8,
                    }
                    impl IsBackwardEngaged {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Head rest backward switch engaged (SingleSeat.Headrest.Angle).. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, pos)"]
                        pub fn value(&self) -> (&bool, &u8, &u8) {
                            (&self.v, &self.row, &self.pos)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Head rest backward switch engaged (SingleSeat.Headrest.Angle).. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.row = row;
                            self.pos = pos;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    pos,
                                })
                            } else {
                                None
                            }
                        }
                    }
                }
                #[allow(non_snake_case)]
                pub mod seating {
                    use cdds_derive::Topic;
                    use cyclonedds_rs::*;
                    #[doc = "Is switch to increase seating length engaged (SingleSeat.Seating.Length).. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct IsForwardEngaged {
                        v: bool,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key]
                        row: u8,
                        #[topic_key]
                        pos: u8,
                    }
                    impl IsForwardEngaged {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Is switch to increase seating length engaged (SingleSeat.Seating.Length).. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, pos)"]
                        pub fn value(&self) -> (&bool, &u8, &u8) {
                            (&self.v, &self.row, &self.pos)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Is switch to increase seating length engaged (SingleSeat.Seating.Length).. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.row = row;
                            self.pos = pos;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    pos,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Is switch to decrease seating length engaged (SingleSeat.Seating.Length).. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct IsBackwardEngaged {
                        v: bool,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key]
                        row: u8,
                        #[topic_key]
                        pos: u8,
                    }
                    impl IsBackwardEngaged {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Is switch to decrease seating length engaged (SingleSeat.Seating.Length).. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, pos)"]
                        pub fn value(&self) -> (&bool, &u8, &u8) {
                            (&self.v, &self.row, &self.pos)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Is switch to decrease seating length engaged (SingleSeat.Seating.Length).. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.row = row;
                            self.pos = pos;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    pos,
                                })
                            } else {
                                None
                            }
                        }
                    }
                }
                #[allow(non_snake_case)]
                pub mod backrest {
                    use cdds_derive::Topic;
                    use cyclonedds_rs::*;
                    #[doc = "Backrest recline forward switch engaged (SingleSeat.Backrest.Recline).. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct IsReclineForwardEngaged {
                        v: bool,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key]
                        row: u8,
                        #[topic_key]
                        pos: u8,
                    }
                    impl IsReclineForwardEngaged {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Backrest recline forward switch engaged (SingleSeat.Backrest.Recline).. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, pos)"]
                        pub fn value(&self) -> (&bool, &u8, &u8) {
                            (&self.v, &self.row, &self.pos)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Backrest recline forward switch engaged (SingleSeat.Backrest.Recline).. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.row = row;
                            self.pos = pos;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    pos,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Backrest recline backward switch engaged (SingleSeat.Backrest.Recline).. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct IsReclineBackwardEngaged {
                        v: bool,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key]
                        row: u8,
                        #[topic_key]
                        pos: u8,
                    }
                    impl IsReclineBackwardEngaged {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Backrest recline backward switch engaged (SingleSeat.Backrest.Recline).. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,row, pos)"]
                        pub fn value(&self) -> (&bool, &u8, &u8) {
                            (&self.v, &self.row, &self.pos)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Backrest recline backward switch engaged (SingleSeat.Backrest.Recline).. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.row = row;
                            self.pos = pos;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v2::Timestamp>,
                            row: u8,
                            pos: u8,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    row,
                                    pos,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[allow(non_snake_case)]
                    pub mod sidebolster {
                        use cdds_derive::Topic;
                        use cyclonedds_rs::*;
                        #[doc = "Is switch for more side bolster support engaged (SingleSeat.Backrest.SideBolster.Support).. This type has no unit defined"]
                        #[allow(non_camel_case_types)]
                        #[derive(Default, Deserialize, Serialize, Topic)]
                        pub struct IsMoreSupportEngaged {
                            v: bool,
                            timestamp: crate::v2::Timestamp,
                            #[topic_key]
                            row: u8,
                            #[topic_key]
                            pos: u8,
                        }
                        impl IsMoreSupportEngaged {
                            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                                &self.timestamp
                            }
                            #[doc = r" Get the "]
                            #[doc = "Is switch for more side bolster support engaged (SingleSeat.Backrest.SideBolster.Support).. This type has no unit defined"]
                            #[doc = r" The return value is a tuple that contains a"]
                            #[doc = r" reference to the value and the additional keys the topic"]
                            #[doc = r" may have. The value is always the first entry and is"]
                            #[doc = "(value,row, pos)"]
                            pub fn value(&self) -> (&bool, &u8, &u8) {
                                (&self.v, &self.row, &self.pos)
                            }
                            #[doc = r" Set the"]
                            #[doc = "Is switch for more side bolster support engaged (SingleSeat.Backrest.SideBolster.Support).. This type has no unit defined"]
                            #[doc = r" . Ensure that the value is within bounds as per the"]
                            #[doc = r" specification. This function will panic in case the value is out"]
                            #[doc = r" of bounds."]
                            pub fn set(
                                &mut self,
                                value: bool,
                                maybe_timestamp: Option<crate::v2::Timestamp>,
                                row: u8,
                                pos: u8,
                            ) {
                                assert!(Self::bounds_check(&value));
                                self.v = value;
                                self.row = row;
                                self.pos = pos;
                                if let Some(ts) = maybe_timestamp {
                                    self.timestamp = ts;
                                }
                            }
                            #[doc = r"check if the given value is within the limits defined"]
                            #[doc = r"in the specification. This particular type has not"]
                            #[doc = r"specified the min or max limits so the function just"]
                            #[doc = r" returns true"]
                            const fn bounds_check(_v: &bool) -> bool {
                                true
                            }
                            #[doc = r" create a new instance"]
                            pub fn new(
                                value: bool,
                                timestamp: Option<crate::v2::Timestamp>,
                                row: u8,
                                pos: u8,
                            ) -> Option<Self> {
                                if Self::bounds_check(&value) {
                                    Some(Self {
                                        v: value,
                                        timestamp: timestamp.unwrap_or_default(),
                                        row,
                                        pos,
                                    })
                                } else {
                                    None
                                }
                            }
                        }
                        #[doc = "Is switch for less side bolster support engaged (SingleSeat.Backrest.SideBolster.Support).. This type has no unit defined"]
                        #[allow(non_camel_case_types)]
                        #[derive(Default, Deserialize, Serialize, Topic)]
                        pub struct IsLessSupportEngaged {
                            v: bool,
                            timestamp: crate::v2::Timestamp,
                            #[topic_key]
                            row: u8,
                            #[topic_key]
                            pos: u8,
                        }
                        impl IsLessSupportEngaged {
                            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                                &self.timestamp
                            }
                            #[doc = r" Get the "]
                            #[doc = "Is switch for less side bolster support engaged (SingleSeat.Backrest.SideBolster.Support).. This type has no unit defined"]
                            #[doc = r" The return value is a tuple that contains a"]
                            #[doc = r" reference to the value and the additional keys the topic"]
                            #[doc = r" may have. The value is always the first entry and is"]
                            #[doc = "(value,row, pos)"]
                            pub fn value(&self) -> (&bool, &u8, &u8) {
                                (&self.v, &self.row, &self.pos)
                            }
                            #[doc = r" Set the"]
                            #[doc = "Is switch for less side bolster support engaged (SingleSeat.Backrest.SideBolster.Support).. This type has no unit defined"]
                            #[doc = r" . Ensure that the value is within bounds as per the"]
                            #[doc = r" specification. This function will panic in case the value is out"]
                            #[doc = r" of bounds."]
                            pub fn set(
                                &mut self,
                                value: bool,
                                maybe_timestamp: Option<crate::v2::Timestamp>,
                                row: u8,
                                pos: u8,
                            ) {
                                assert!(Self::bounds_check(&value));
                                self.v = value;
                                self.row = row;
                                self.pos = pos;
                                if let Some(ts) = maybe_timestamp {
                                    self.timestamp = ts;
                                }
                            }
                            #[doc = r"check if the given value is within the limits defined"]
                            #[doc = r"in the specification. This particular type has not"]
                            #[doc = r"specified the min or max limits so the function just"]
                            #[doc = r" returns true"]
                            const fn bounds_check(_v: &bool) -> bool {
                                true
                            }
                            #[doc = r" create a new instance"]
                            pub fn new(
                                value: bool,
                                timestamp: Option<crate::v2::Timestamp>,
                                row: u8,
                                pos: u8,
                            ) -> Option<Self> {
                                if Self::bounds_check(&value) {
                                    Some(Self {
                                        v: value,
                                        timestamp: timestamp.unwrap_or_default(),
                                        row,
                                        pos,
                                    })
                                } else {
                                    None
                                }
                            }
                        }
                    }
                    #[allow(non_snake_case)]
                    pub mod lumbar {
                        use cdds_derive::Topic;
                        use cyclonedds_rs::*;
                        #[doc = "Is switch for more lumbar support engaged (SingleSeat.Backrest.Lumbar.Support).. This type has no unit defined"]
                        #[allow(non_camel_case_types)]
                        #[derive(Default, Deserialize, Serialize, Topic)]
                        pub struct IsMoreSupportEngaged {
                            v: bool,
                            timestamp: crate::v2::Timestamp,
                            #[topic_key]
                            row: u8,
                            #[topic_key]
                            pos: u8,
                        }
                        impl IsMoreSupportEngaged {
                            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                                &self.timestamp
                            }
                            #[doc = r" Get the "]
                            #[doc = "Is switch for more lumbar support engaged (SingleSeat.Backrest.Lumbar.Support).. This type has no unit defined"]
                            #[doc = r" The return value is a tuple that contains a"]
                            #[doc = r" reference to the value and the additional keys the topic"]
                            #[doc = r" may have. The value is always the first entry and is"]
                            #[doc = "(value,row, pos)"]
                            pub fn value(&self) -> (&bool, &u8, &u8) {
                                (&self.v, &self.row, &self.pos)
                            }
                            #[doc = r" Set the"]
                            #[doc = "Is switch for more lumbar support engaged (SingleSeat.Backrest.Lumbar.Support).. This type has no unit defined"]
                            #[doc = r" . Ensure that the value is within bounds as per the"]
                            #[doc = r" specification. This function will panic in case the value is out"]
                            #[doc = r" of bounds."]
                            pub fn set(
                                &mut self,
                                value: bool,
                                maybe_timestamp: Option<crate::v2::Timestamp>,
                                row: u8,
                                pos: u8,
                            ) {
                                assert!(Self::bounds_check(&value));
                                self.v = value;
                                self.row = row;
                                self.pos = pos;
                                if let Some(ts) = maybe_timestamp {
                                    self.timestamp = ts;
                                }
                            }
                            #[doc = r"check if the given value is within the limits defined"]
                            #[doc = r"in the specification. This particular type has not"]
                            #[doc = r"specified the min or max limits so the function just"]
                            #[doc = r" returns true"]
                            const fn bounds_check(_v: &bool) -> bool {
                                true
                            }
                            #[doc = r" create a new instance"]
                            pub fn new(
                                value: bool,
                                timestamp: Option<crate::v2::Timestamp>,
                                row: u8,
                                pos: u8,
                            ) -> Option<Self> {
                                if Self::bounds_check(&value) {
                                    Some(Self {
                                        v: value,
                                        timestamp: timestamp.unwrap_or_default(),
                                        row,
                                        pos,
                                    })
                                } else {
                                    None
                                }
                            }
                        }
                        #[doc = "Is switch for less lumbar support engaged (SingleSeat.Backrest.Lumbar.Support).. This type has no unit defined"]
                        #[allow(non_camel_case_types)]
                        #[derive(Default, Deserialize, Serialize, Topic)]
                        pub struct IsLessSupportEngaged {
                            v: bool,
                            timestamp: crate::v2::Timestamp,
                            #[topic_key]
                            row: u8,
                            #[topic_key]
                            pos: u8,
                        }
                        impl IsLessSupportEngaged {
                            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                                &self.timestamp
                            }
                            #[doc = r" Get the "]
                            #[doc = "Is switch for less lumbar support engaged (SingleSeat.Backrest.Lumbar.Support).. This type has no unit defined"]
                            #[doc = r" The return value is a tuple that contains a"]
                            #[doc = r" reference to the value and the additional keys the topic"]
                            #[doc = r" may have. The value is always the first entry and is"]
                            #[doc = "(value,row, pos)"]
                            pub fn value(&self) -> (&bool, &u8, &u8) {
                                (&self.v, &self.row, &self.pos)
                            }
                            #[doc = r" Set the"]
                            #[doc = "Is switch for less lumbar support engaged (SingleSeat.Backrest.Lumbar.Support).. This type has no unit defined"]
                            #[doc = r" . Ensure that the value is within bounds as per the"]
                            #[doc = r" specification. This function will panic in case the value is out"]
                            #[doc = r" of bounds."]
                            pub fn set(
                                &mut self,
                                value: bool,
                                maybe_timestamp: Option<crate::v2::Timestamp>,
                                row: u8,
                                pos: u8,
                            ) {
                                assert!(Self::bounds_check(&value));
                                self.v = value;
                                self.row = row;
                                self.pos = pos;
                                if let Some(ts) = maybe_timestamp {
                                    self.timestamp = ts;
                                }
                            }
                            #[doc = r"check if the given value is within the limits defined"]
                            #[doc = r"in the specification. This particular type has not"]
                            #[doc = r"specified the min or max limits so the function just"]
                            #[doc = r" returns true"]
                            const fn bounds_check(_v: &bool) -> bool {
                                true
                            }
                            #[doc = r" create a new instance"]
                            pub fn new(
                                value: bool,
                                timestamp: Option<crate::v2::Timestamp>,
                                row: u8,
                                pos: u8,
                            ) -> Option<Self> {
                                if Self::bounds_check(&value) {
                                    Some(Self {
                                        v: value,
                                        timestamp: timestamp.unwrap_or_default(),
                                        row,
                                        pos,
                                    })
                                } else {
                                    None
                                }
                            }
                        }
                        #[doc = "Lumbar up switch engaged (SingleSeat.Backrest.Lumbar.Support).. This type has no unit defined"]
                        #[allow(non_camel_case_types)]
                        #[derive(Default, Deserialize, Serialize, Topic)]
                        pub struct IsUpEngaged {
                            v: bool,
                            timestamp: crate::v2::Timestamp,
                            #[topic_key]
                            row: u8,
                            #[topic_key]
                            pos: u8,
                        }
                        impl IsUpEngaged {
                            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                                &self.timestamp
                            }
                            #[doc = r" Get the "]
                            #[doc = "Lumbar up switch engaged (SingleSeat.Backrest.Lumbar.Support).. This type has no unit defined"]
                            #[doc = r" The return value is a tuple that contains a"]
                            #[doc = r" reference to the value and the additional keys the topic"]
                            #[doc = r" may have. The value is always the first entry and is"]
                            #[doc = "(value,row, pos)"]
                            pub fn value(&self) -> (&bool, &u8, &u8) {
                                (&self.v, &self.row, &self.pos)
                            }
                            #[doc = r" Set the"]
                            #[doc = "Lumbar up switch engaged (SingleSeat.Backrest.Lumbar.Support).. This type has no unit defined"]
                            #[doc = r" . Ensure that the value is within bounds as per the"]
                            #[doc = r" specification. This function will panic in case the value is out"]
                            #[doc = r" of bounds."]
                            pub fn set(
                                &mut self,
                                value: bool,
                                maybe_timestamp: Option<crate::v2::Timestamp>,
                                row: u8,
                                pos: u8,
                            ) {
                                assert!(Self::bounds_check(&value));
                                self.v = value;
                                self.row = row;
                                self.pos = pos;
                                if let Some(ts) = maybe_timestamp {
                                    self.timestamp = ts;
                                }
                            }
                            #[doc = r"check if the given value is within the limits defined"]
                            #[doc = r"in the specification. This particular type has not"]
                            #[doc = r"specified the min or max limits so the function just"]
                            #[doc = r" returns true"]
                            const fn bounds_check(_v: &bool) -> bool {
                                true
                            }
                            #[doc = r" create a new instance"]
                            pub fn new(
                                value: bool,
                                timestamp: Option<crate::v2::Timestamp>,
                                row: u8,
                                pos: u8,
                            ) -> Option<Self> {
                                if Self::bounds_check(&value) {
                                    Some(Self {
                                        v: value,
                                        timestamp: timestamp.unwrap_or_default(),
                                        row,
                                        pos,
                                    })
                                } else {
                                    None
                                }
                            }
                        }
                        #[doc = "Lumbar down switch engaged (SingleSeat.Backrest.Lumbar.Support).. This type has no unit defined"]
                        #[allow(non_camel_case_types)]
                        #[derive(Default, Deserialize, Serialize, Topic)]
                        pub struct IsDownEngaged {
                            v: bool,
                            timestamp: crate::v2::Timestamp,
                            #[topic_key]
                            row: u8,
                            #[topic_key]
                            pos: u8,
                        }
                        impl IsDownEngaged {
                            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                                &self.timestamp
                            }
                            #[doc = r" Get the "]
                            #[doc = "Lumbar down switch engaged (SingleSeat.Backrest.Lumbar.Support).. This type has no unit defined"]
                            #[doc = r" The return value is a tuple that contains a"]
                            #[doc = r" reference to the value and the additional keys the topic"]
                            #[doc = r" may have. The value is always the first entry and is"]
                            #[doc = "(value,row, pos)"]
                            pub fn value(&self) -> (&bool, &u8, &u8) {
                                (&self.v, &self.row, &self.pos)
                            }
                            #[doc = r" Set the"]
                            #[doc = "Lumbar down switch engaged (SingleSeat.Backrest.Lumbar.Support).. This type has no unit defined"]
                            #[doc = r" . Ensure that the value is within bounds as per the"]
                            #[doc = r" specification. This function will panic in case the value is out"]
                            #[doc = r" of bounds."]
                            pub fn set(
                                &mut self,
                                value: bool,
                                maybe_timestamp: Option<crate::v2::Timestamp>,
                                row: u8,
                                pos: u8,
                            ) {
                                assert!(Self::bounds_check(&value));
                                self.v = value;
                                self.row = row;
                                self.pos = pos;
                                if let Some(ts) = maybe_timestamp {
                                    self.timestamp = ts;
                                }
                            }
                            #[doc = r"check if the given value is within the limits defined"]
                            #[doc = r"in the specification. This particular type has not"]
                            #[doc = r"specified the min or max limits so the function just"]
                            #[doc = r" returns true"]
                            const fn bounds_check(_v: &bool) -> bool {
                                true
                            }
                            #[doc = r" create a new instance"]
                            pub fn new(
                                value: bool,
                                timestamp: Option<crate::v2::Timestamp>,
                                row: u8,
                                pos: u8,
                            ) -> Option<Self> {
                                if Self::bounds_check(&value) {
                                    Some(Self {
                                        v: value,
                                        timestamp: timestamp.unwrap_or_default(),
                                        row,
                                        pos,
                                    })
                                } else {
                                    None
                                }
                            }
                        }
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod door {
            #[allow(non_snake_case)]
            pub mod window {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Is window open or closed?. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct IsOpen {
                    v: bool,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    row: u8,
                    #[topic_key_enum]
                    side: crate::v2::Side,
                }
                impl IsOpen {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Is window open or closed?. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, side)"]
                    pub fn value(&self) -> (&bool, &u8, &crate::v2::Side) {
                        (&self.v, &self.row, &self.side)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Is window open or closed?. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        side: crate::v2::Side,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.row = row;
                        self.side = side;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        side: crate::v2::Side,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                side,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Window position. 0 = Fully closed 100 = Fully opened.. The unit of this type is percent"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Position {
                    v: crate::v2::units::Percent<u8>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    row: u8,
                    #[topic_key_enum]
                    side: crate::v2::Side,
                }
                impl Position {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Window position. 0 = Fully closed 100 = Fully opened.. The unit of this type is percent"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, side)"]
                    pub fn value(&self) -> (&crate::v2::units::Percent<u8>, &u8, &crate::v2::Side) {
                        (&self.v, &self.row, &self.side)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Window position. 0 = Fully closed 100 = Fully opened.. The unit of this type is percent"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Percent<u8>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        side: crate::v2::Side,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.row = row;
                        self.side = side;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v2::units::Percent<u8>) -> bool {
                        v.0 <= 100u8 && v.0 >= 0u8
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Percent<u8>,
                        timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        side: crate::v2::Side,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                side,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Is window child lock engaged. True = Engaged. False = Disengaged.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct IsChildLockEngaged {
                    v: bool,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    row: u8,
                    #[topic_key_enum]
                    side: crate::v2::Side,
                }
                impl IsChildLockEngaged {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Is window child lock engaged. True = Engaged. False = Disengaged.. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, side)"]
                    pub fn value(&self) -> (&bool, &u8, &crate::v2::Side) {
                        (&self.v, &self.row, &self.side)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Is window child lock engaged. True = Engaged. False = Disengaged.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        side: crate::v2::Side,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.row = row;
                        self.side = side;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        side: crate::v2::Side,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                side,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Switch controlling sliding action such as window, sunroof, or blind.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Switch {
                    v: String,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    row: u8,
                    #[topic_key_enum]
                    side: crate::v2::Side,
                }
                impl Switch {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Switch controlling sliding action such as window, sunroof, or blind.. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, side)"]
                    pub fn value(&self) -> (&String, &u8, &crate::v2::Side) {
                        (&self.v, &self.row, &self.side)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Switch controlling sliding action such as window, sunroof, or blind.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        side: crate::v2::Side,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.row = row;
                        self.side = side;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        side: crate::v2::Side,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                side,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod shade {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Switch controlling sliding action such as window, sunroof, or blind.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Switch {
                    v: String,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    row: u8,
                    #[topic_key_enum]
                    side: crate::v2::Side,
                }
                impl Switch {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Switch controlling sliding action such as window, sunroof, or blind.. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, side)"]
                    pub fn value(&self) -> (&String, &u8, &crate::v2::Side) {
                        (&self.v, &self.row, &self.side)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Switch controlling sliding action such as window, sunroof, or blind.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        side: crate::v2::Side,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.row = row;
                        self.side = side;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        side: crate::v2::Side,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                side,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Position of window blind. 0 = Fully retracted. 100 = Fully deployed.. The unit of this type is percent"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Position {
                    v: crate::v2::units::Percent<u8>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key]
                    row: u8,
                    #[topic_key_enum]
                    side: crate::v2::Side,
                }
                impl Position {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Position of window blind. 0 = Fully retracted. 100 = Fully deployed.. The unit of this type is percent"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,row, side)"]
                    pub fn value(&self) -> (&crate::v2::units::Percent<u8>, &u8, &crate::v2::Side) {
                        (&self.v, &self.row, &self.side)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Position of window blind. 0 = Fully retracted. 100 = Fully deployed.. The unit of this type is percent"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Percent<u8>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        side: crate::v2::Side,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.row = row;
                        self.side = side;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v2::units::Percent<u8>) -> bool {
                        v.0 <= 100u8 && v.0 >= 0u8
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Percent<u8>,
                        timestamp: Option<crate::v2::Timestamp>,
                        row: u8,
                        side: crate::v2::Side,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                row,
                                side,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod lights {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Is glove box light on. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsGloveBoxOn {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsGloveBoxOn {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is glove box light on. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Is glove box light on. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Is trunk light light on. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsTrunkOn {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsTrunkOn {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is trunk light light on. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Is trunk light light on. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Is central dome light light on. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsDomeOn {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsDomeOn {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is central dome light light on. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Is central dome light light on. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "How much ambient light is detected in cabin. 0 = No ambient light. 100 = Full brightness. The unit of this type is percent"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct AmbientLight {
                v: crate::v2::units::Percent<u8>,
                timestamp: crate::v2::Timestamp,
            }
            impl AmbientLight {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "How much ambient light is detected in cabin. 0 = No ambient light. 100 = Full brightness. The unit of this type is percent"]
                pub fn value(&self) -> &crate::v2::units::Percent<u8> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "How much ambient light is detected in cabin. 0 = No ambient light. 100 = Full brightness. The unit of this type is percent"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Percent<u8>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v2::units::Percent<u8>) -> bool {
                    v.0 <= 100u8 && v.0 >= 0u8
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Percent<u8>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Intensity of the interior lights. 0 = Off. 100 = Full brightness.. The unit of this type is percent"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct LightIntensity {
                v: crate::v2::units::Percent<u8>,
                timestamp: crate::v2::Timestamp,
            }
            impl LightIntensity {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Intensity of the interior lights. 0 = Off. 100 = Full brightness.. The unit of this type is percent"]
                pub fn value(&self) -> &crate::v2::units::Percent<u8> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Intensity of the interior lights. 0 = Off. 100 = Full brightness.. The unit of this type is percent"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Percent<u8>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v2::units::Percent<u8>) -> bool {
                    v.0 <= 100u8 && v.0 >= 0u8
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Percent<u8>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod spotlight {}
        }
        #[allow(non_snake_case)]
        pub mod rearviewmirror {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Dimming level of rearview mirror. 0 = undimmed. 100 = fully dimmed.. The unit of this type is percent"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct DimmingLevel {
                v: crate::v2::units::Percent<u8>,
                timestamp: crate::v2::Timestamp,
            }
            impl DimmingLevel {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Dimming level of rearview mirror. 0 = undimmed. 100 = fully dimmed.. The unit of this type is percent"]
                pub fn value(&self) -> &crate::v2::units::Percent<u8> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Dimming level of rearview mirror. 0 = undimmed. 100 = fully dimmed.. The unit of this type is percent"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Percent<u8>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v2::units::Percent<u8>) -> bool {
                    v.0 <= 100u8 && true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Percent<u8>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod sunroof {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Sunroof position. 0 = Fully closed 100 = Fully opened. -100 = Fully tilted.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Position {
                v: i8,
                timestamp: crate::v2::Timestamp,
            }
            impl Position {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Sunroof position. 0 = Fully closed 100 = Fully opened. -100 = Fully tilted.. This type has no unit defined"]
                pub fn value(&self) -> &i8 {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Sunroof position. 0 = Fully closed 100 = Fully opened. -100 = Fully tilted.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: i8, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &i8) -> bool {
                    *v <= 100i8 && *v >= -100i8
                }
                #[doc = r" create a new instance"]
                pub fn new(value: i8, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Switch controlling sliding action such as window, sunroof, or shade.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Switch {
                v: String,
                timestamp: crate::v2::Timestamp,
            }
            impl Switch {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Switch controlling sliding action such as window, sunroof, or shade.. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Switch controlling sliding action such as window, sunroof, or shade.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: String,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod shade {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Switch controlling sliding action such as window, sunroof, or blind.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Switch {
                    v: String,
                    timestamp: crate::v2::Timestamp,
                }
                impl Switch {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Switch controlling sliding action such as window, sunroof, or blind.. This type has no unit defined"]
                    pub fn value(&self) -> &String {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Switch controlling sliding action such as window, sunroof, or blind.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Position of window blind. 0 = Fully retracted. 100 = Fully deployed.. The unit of this type is percent"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Position {
                    v: crate::v2::units::Percent<u8>,
                    timestamp: crate::v2::Timestamp,
                }
                impl Position {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Position of window blind. 0 = Fully retracted. 100 = Fully deployed.. The unit of this type is percent"]
                    pub fn value(&self) -> &crate::v2::units::Percent<u8> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Position of window blind. 0 = Fully retracted. 100 = Fully deployed.. The unit of this type is percent"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Percent<u8>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v2::units::Percent<u8>) -> bool {
                        v.0 <= 100u8 && v.0 >= 0u8
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Percent<u8>,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod infotainment {
            #[allow(non_snake_case)]
            pub mod hmi {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "ISO 639-1 standard language code for the current HMI. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct CurrentLanguage {
                    v: String,
                    timestamp: crate::v2::Timestamp,
                }
                impl CurrentLanguage {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "ISO 639-1 standard language code for the current HMI. This type has no unit defined"]
                    pub fn value(&self) -> &String {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "ISO 639-1 standard language code for the current HMI. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Date format used in the current HMI. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct DateFormat {
                    v: String,
                    timestamp: crate::v2::Timestamp,
                }
                impl DateFormat {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Date format used in the current HMI. This type has no unit defined"]
                    pub fn value(&self) -> &String {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Date format used in the current HMI. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Time format used in the current HMI. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct TimeFormat {
                    v: String,
                    timestamp: crate::v2::Timestamp,
                }
                impl TimeFormat {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Time format used in the current HMI. This type has no unit defined"]
                    pub fn value(&self) -> &String {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Time format used in the current HMI. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Distance unit used in the current HMI. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct DistanceUnit {
                    v: String,
                    timestamp: crate::v2::Timestamp,
                }
                impl DistanceUnit {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Distance unit used in the current HMI. This type has no unit defined"]
                    pub fn value(&self) -> &String {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Distance unit used in the current HMI. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Fuel economy unit used in the current HMI. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct FuelEconomyUnits {
                    v: String,
                    timestamp: crate::v2::Timestamp,
                }
                impl FuelEconomyUnits {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Fuel economy unit used in the current HMI. This type has no unit defined"]
                    pub fn value(&self) -> &String {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Fuel economy unit used in the current HMI. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "EV fuel economy unit used in the current HMI. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct EVEconomyUnits {
                    v: String,
                    timestamp: crate::v2::Timestamp,
                }
                impl EVEconomyUnits {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "EV fuel economy unit used in the current HMI. This type has no unit defined"]
                    pub fn value(&self) -> &String {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "EV fuel economy unit used in the current HMI. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Temperature unit used in the current HMI. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct TemperatureUnit {
                    v: String,
                    timestamp: crate::v2::Timestamp,
                }
                impl TemperatureUnit {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Temperature unit used in the current HMI. This type has no unit defined"]
                    pub fn value(&self) -> &String {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Temperature unit used in the current HMI. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Current display theme. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct DayNightMode {
                    v: String,
                    timestamp: crate::v2::Timestamp,
                }
                impl DayNightMode {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Current display theme. This type has no unit defined"]
                    pub fn value(&self) -> &String {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Current display theme. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod navigation {
                #[allow(non_snake_case)]
                pub mod destinationset {
                    use cdds_derive::Topic;
                    use cyclonedds_rs::*;
                    #[doc = "Latitude of destination in WGS 84 geodetic coordinates.. The unit of this type is degrees"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Latitude {
                        v: f64,
                        timestamp: crate::v2::Timestamp,
                    }
                    impl Latitude {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Latitude of destination in WGS 84 geodetic coordinates.. The unit of this type is degrees"]
                        pub fn value(&self) -> &f64 {
                            &self.v
                        }
                        #[doc = r" Set the"]
                        #[doc = "Latitude of destination in WGS 84 geodetic coordinates.. The unit of this type is degrees"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: f64,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. Return true if the value is"]
                        #[doc = r"within bounds."]
                        pub fn bounds_check(v: &f64) -> bool {
                            *v <= 90f64 && *v >= -90f64
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: f64,
                            timestamp: Option<crate::v2::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Longitude of destination in WGS 84 geodetic coordinates.. The unit of this type is degrees"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Longitude {
                        v: f64,
                        timestamp: crate::v2::Timestamp,
                    }
                    impl Longitude {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Longitude of destination in WGS 84 geodetic coordinates.. The unit of this type is degrees"]
                        pub fn value(&self) -> &f64 {
                            &self.v
                        }
                        #[doc = r" Set the"]
                        #[doc = "Longitude of destination in WGS 84 geodetic coordinates.. The unit of this type is degrees"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: f64,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. Return true if the value is"]
                        #[doc = r"within bounds."]
                        pub fn bounds_check(v: &f64) -> bool {
                            *v <= 180f64 && *v >= -180f64
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: f64,
                            timestamp: Option<crate::v2::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod media {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Tells if the media was. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Action {
                    v: String,
                    timestamp: crate::v2::Timestamp,
                }
                impl Action {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Tells if the media was. This type has no unit defined"]
                    pub fn value(&self) -> &String {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Tells if the media was. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "URI of suggested media that was declined. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct DeclinedURI {
                    v: String,
                    timestamp: crate::v2::Timestamp,
                }
                impl DeclinedURI {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "URI of suggested media that was declined. This type has no unit defined"]
                    pub fn value(&self) -> &String {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "URI of suggested media that was declined. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "URI of suggested media that was selected. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct SelectedURI {
                    v: String,
                    timestamp: crate::v2::Timestamp,
                }
                impl SelectedURI {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "URI of suggested media that was selected. This type has no unit defined"]
                    pub fn value(&self) -> &String {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "URI of suggested media that was selected. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Current Media Volume. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Volume {
                    v: u8,
                    timestamp: crate::v2::Timestamp,
                }
                impl Volume {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Current Media Volume. This type has no unit defined"]
                    pub fn value(&self) -> &u8 {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Current Media Volume. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: u8,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &u8) -> bool {
                        *v <= 100u8 && *v >= 0u8
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(value: u8, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[allow(non_snake_case)]
                pub mod played {
                    use cdds_derive::Topic;
                    use cyclonedds_rs::*;
                    #[doc = "Media selected for playback. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Source {
                        v: String,
                        timestamp: crate::v2::Timestamp,
                    }
                    impl Source {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Media selected for playback. This type has no unit defined"]
                        pub fn value(&self) -> &String {
                            &self.v
                        }
                        #[doc = r" Set the"]
                        #[doc = "Media selected for playback. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: String,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &String) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: String,
                            timestamp: Option<crate::v2::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Name of artist being played. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Artist {
                        v: String,
                        timestamp: crate::v2::Timestamp,
                    }
                    impl Artist {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Name of artist being played. This type has no unit defined"]
                        pub fn value(&self) -> &String {
                            &self.v
                        }
                        #[doc = r" Set the"]
                        #[doc = "Name of artist being played. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: String,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &String) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: String,
                            timestamp: Option<crate::v2::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Name of album being played. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Album {
                        v: String,
                        timestamp: crate::v2::Timestamp,
                    }
                    impl Album {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Name of album being played. This type has no unit defined"]
                        pub fn value(&self) -> &String {
                            &self.v
                        }
                        #[doc = r" Set the"]
                        #[doc = "Name of album being played. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: String,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &String) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: String,
                            timestamp: Option<crate::v2::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Name of track being played. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Track {
                        v: String,
                        timestamp: crate::v2::Timestamp,
                    }
                    impl Track {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Name of track being played. This type has no unit defined"]
                        pub fn value(&self) -> &String {
                            &self.v
                        }
                        #[doc = r" Set the"]
                        #[doc = "Name of track being played. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: String,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &String) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: String,
                            timestamp: Option<crate::v2::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "User Resource associated with the media. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct URI {
                        v: String,
                        timestamp: crate::v2::Timestamp,
                    }
                    impl URI {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "User Resource associated with the media. This type has no unit defined"]
                        pub fn value(&self) -> &String {
                            &self.v
                        }
                        #[doc = r" Set the"]
                        #[doc = "User Resource associated with the media. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: String,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &String) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: String,
                            timestamp: Option<crate::v2::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod hvac {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Is recirculation active.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsRecirculationActive {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsRecirculationActive {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is recirculation active.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Is recirculation active.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Is front defroster active.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsFrontDefrosterActive {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsFrontDefrosterActive {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is front defroster active.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Is front defroster active.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Is rear defroster active.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsRearDefrosterActive {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsRearDefrosterActive {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is rear defroster active.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Is rear defroster active.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Is Air conditioning active.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsAirConditioningActive {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsAirConditioningActive {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is Air conditioning active.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Is Air conditioning active.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Ambient air temperature inside the vehicle.. The unit of this type is celsius"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct AmbientAirTemperature {
                v: crate::v2::units::Celsius<f32>,
                timestamp: crate::v2::Timestamp,
            }
            impl AmbientAirTemperature {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Ambient air temperature inside the vehicle.. The unit of this type is celsius"]
                pub fn value(&self) -> &crate::v2::units::Celsius<f32> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Ambient air temperature inside the vehicle.. The unit of this type is celsius"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Celsius<f32>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Celsius<f32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Celsius<f32>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod station {}
        }
        #[allow(non_snake_case)]
        pub mod rearshade {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Switch controlling sliding action such as window, sunroof, or blind.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Switch {
                v: String,
                timestamp: crate::v2::Timestamp,
            }
            impl Switch {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Switch controlling sliding action such as window, sunroof, or blind.. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Switch controlling sliding action such as window, sunroof, or blind.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: String,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Position of window blind. 0 = Fully retracted. 100 = Fully deployed.. The unit of this type is percent"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Position {
                v: crate::v2::units::Percent<u8>,
                timestamp: crate::v2::Timestamp,
            }
            impl Position {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Position of window blind. 0 = Fully retracted. 100 = Fully deployed.. The unit of this type is percent"]
                pub fn value(&self) -> &crate::v2::units::Percent<u8> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Position of window blind. 0 = Fully retracted. 100 = Fully deployed.. The unit of this type is percent"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Percent<u8>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v2::units::Percent<u8>) -> bool {
                    v.0 <= 100u8 && v.0 >= 0u8
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Percent<u8>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
    }
    #[allow(non_snake_case)]
    pub mod body {
        use cdds_derive::Topic;
        use cyclonedds_rs::*;
        #[doc = "Body type code as defined by ISO 3779.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct BodyType {
            v: String,
        }
        impl BodyType {
            #[doc = r" Get the "]
            #[doc = "Body type code as defined by ISO 3779.. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Body type code as defined by ISO 3779.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "Location of the fuel cap or charge port.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct RefuelPosition {
            v: String,
        }
        impl RefuelPosition {
            #[doc = r" Get the "]
            #[doc = "Location of the fuel cap or charge port.. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Location of the fuel cap or charge port.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "Rear spoiler position, 0% = Spoiler fully stowed. 100% = Spoiler fully exposed.. The unit of this type is percent"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct RearMainSpoilerPosition {
            v: crate::v2::units::Percent<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl RearMainSpoilerPosition {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Rear spoiler position, 0% = Spoiler fully stowed. 100% = Spoiler fully exposed.. The unit of this type is percent"]
            pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Rear spoiler position, 0% = Spoiler fully stowed. 100% = Spoiler fully exposed.. The unit of this type is percent"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Percent<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. Return true if the value is"]
            #[doc = r"within bounds."]
            pub fn bounds_check(v: &crate::v2::units::Percent<f32>) -> bool {
                v.0 <= 100f32 && v.0 >= 0f32
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Percent<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod mirrors {}
        #[allow(non_snake_case)]
        pub mod lights {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Is high beam on?. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsHighBeamOn {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsHighBeamOn {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is high beam on?. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Is high beam on?. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Is low beam on?. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsLowBeamOn {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsLowBeamOn {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is low beam on?. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Is low beam on?. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Are running lights on?. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsRunningOn {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsRunningOn {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Are running lights on?. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Are running lights on?. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Is backup (reverse) light on?. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsBackupOn {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsBackupOn {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is backup (reverse) light on?. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Is backup (reverse) light on?. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Is parking light on?. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsParkingOn {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsParkingOn {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is parking light on?. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Is parking light on?. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Is brake light on?. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsBrakeOn {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsBrakeOn {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is brake light on?. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Is brake light on?. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Is rear fog light on?. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsRearFogOn {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsRearFogOn {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is rear fog light on?. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Is rear fog light on?. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Is front fog light on?. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsFrontFogOn {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsFrontFogOn {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is front fog light on?. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Is front fog light on?. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Are hazards on?. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsHazardOn {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsHazardOn {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Are hazards on?. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Are hazards on?. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Is left indicator flashing?. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsLeftIndicatorOn {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsLeftIndicatorOn {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is left indicator flashing?. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Is left indicator flashing?. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Is right indicator flashing?. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsRightIndicatorOn {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsRightIndicatorOn {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is right indicator flashing?. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Is right indicator flashing?. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod windshield {
            #[allow(non_snake_case)]
            pub mod wiping {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Wiper mode requested by user/driver. INTERVAL indicates intermittent wiping, with fixed time interval between each wipe. RAIN_SENSOR indicates intermittent wiping based on rain intensity.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Mode {
                    v: String,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key_enum]
                    position: crate::v2::Position,
                }
                impl Mode {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Wiper mode requested by user/driver. INTERVAL indicates intermittent wiping, with fixed time interval between each wipe. RAIN_SENSOR indicates intermittent wiping based on rain intensity.. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,position)"]
                    pub fn value(&self) -> (&String, &crate::v2::Position) {
                        (&self.v, &self.position)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Wiper mode requested by user/driver. INTERVAL indicates intermittent wiping, with fixed time interval between each wipe. RAIN_SENSOR indicates intermittent wiping based on rain intensity.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        position: crate::v2::Position,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.position = position;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v2::Timestamp>,
                        position: crate::v2::Position,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                position,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Relative intensity/sensitivity for interval and rain sensor mode as requested by user/driver. Has no significance if Windshield.Wiping.Mode is OFF/SLOW/MEDIUM/FAST 0 - wipers inactive. 1 - minimum intensity (lowest frequency/sensitivity, longest interval). 2/3/4/... - higher intensity (higher frequency/sensitivity, shorter interval). Maximum value supported is vehicle specific.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Intensity {
                    v: u8,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key_enum]
                    position: crate::v2::Position,
                }
                impl Intensity {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Relative intensity/sensitivity for interval and rain sensor mode as requested by user/driver. Has no significance if Windshield.Wiping.Mode is OFF/SLOW/MEDIUM/FAST 0 - wipers inactive. 1 - minimum intensity (lowest frequency/sensitivity, longest interval). 2/3/4/... - higher intensity (higher frequency/sensitivity, shorter interval). Maximum value supported is vehicle specific.. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,position)"]
                    pub fn value(&self) -> (&u8, &crate::v2::Position) {
                        (&self.v, &self.position)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Relative intensity/sensitivity for interval and rain sensor mode as requested by user/driver. Has no significance if Windshield.Wiping.Mode is OFF/SLOW/MEDIUM/FAST 0 - wipers inactive. 1 - minimum intensity (lowest frequency/sensitivity, longest interval). 2/3/4/... - higher intensity (higher frequency/sensitivity, shorter interval). Maximum value supported is vehicle specific.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: u8,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        position: crate::v2::Position,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.position = position;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &u8) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: u8,
                        timestamp: Option<crate::v2::Timestamp>,
                        position: crate::v2::Position,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                position,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Wiper wear as percent. 0 = No Wear. 100 = Worn. Replacement required. Method for calculating or estimating wiper wear is vehicle specific. For windshields with multiple wipers the wear reported shall correspond to the most worn wiper.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct WiperWear {
                    v: u8,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key_enum]
                    position: crate::v2::Position,
                }
                impl WiperWear {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Wiper wear as percent. 0 = No Wear. 100 = Worn. Replacement required. Method for calculating or estimating wiper wear is vehicle specific. For windshields with multiple wipers the wear reported shall correspond to the most worn wiper.. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,position)"]
                    pub fn value(&self) -> (&u8, &crate::v2::Position) {
                        (&self.v, &self.position)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Wiper wear as percent. 0 = No Wear. 100 = Worn. Replacement required. Method for calculating or estimating wiper wear is vehicle specific. For windshields with multiple wipers the wear reported shall correspond to the most worn wiper.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: u8,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        position: crate::v2::Position,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.position = position;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &u8) -> bool {
                        *v <= 100u8 && true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: u8,
                        timestamp: Option<crate::v2::Timestamp>,
                        position: crate::v2::Position,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                position,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Wiper wear status. True = Worn, Replacement recommended or required. False = Not Worn.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct IsWipersWorn {
                    v: bool,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key_enum]
                    position: crate::v2::Position,
                }
                impl IsWipersWorn {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Wiper wear status. True = Worn, Replacement recommended or required. False = Not Worn.. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,position)"]
                    pub fn value(&self) -> (&bool, &crate::v2::Position) {
                        (&self.v, &self.position)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Wiper wear status. True = Worn, Replacement recommended or required. False = Not Worn.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        position: crate::v2::Position,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.position = position;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v2::Timestamp>,
                        position: crate::v2::Position,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                position,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[allow(non_snake_case)]
                pub mod system {
                    use cdds_derive::Topic;
                    use cyclonedds_rs::*;
                    #[doc = "Requested mode of wiper system. STOP_HOLD means that the wipers shall move to position given by TargetPosition and then hold the position. WIPE means that wipers shall move to the position given by TargetPosition and then hold the position if no new TargetPosition is requested. PLANT_MODE means that wiping is disabled. Exact behavior is vehicle specific. EMERGENCY_STOP means that wiping shall be immediately stopped without holding the position.. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Mode {
                        v: String,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key_enum]
                        position: crate::v2::Position,
                    }
                    impl Mode {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Requested mode of wiper system. STOP_HOLD means that the wipers shall move to position given by TargetPosition and then hold the position. WIPE means that wipers shall move to the position given by TargetPosition and then hold the position if no new TargetPosition is requested. PLANT_MODE means that wiping is disabled. Exact behavior is vehicle specific. EMERGENCY_STOP means that wiping shall be immediately stopped without holding the position.. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,position)"]
                        pub fn value(&self) -> (&String, &crate::v2::Position) {
                            (&self.v, &self.position)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Requested mode of wiper system. STOP_HOLD means that the wipers shall move to position given by TargetPosition and then hold the position. WIPE means that wipers shall move to the position given by TargetPosition and then hold the position if no new TargetPosition is requested. PLANT_MODE means that wiping is disabled. Exact behavior is vehicle specific. EMERGENCY_STOP means that wiping shall be immediately stopped without holding the position.. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: String,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            position: crate::v2::Position,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.position = position;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &String) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: String,
                            timestamp: Option<crate::v2::Timestamp>,
                            position: crate::v2::Position,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    position,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Wiping frequency/speed, measured in cycles per minute. The signal concerns the actual speed of the wiper blades when moving. Intervals/pauses are excluded, i.e. the value corresponds to the number of cycles that would be completed in 1 minute if wiping permanently over default range.. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Frequency {
                        v: u8,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key_enum]
                        position: crate::v2::Position,
                    }
                    impl Frequency {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Wiping frequency/speed, measured in cycles per minute. The signal concerns the actual speed of the wiper blades when moving. Intervals/pauses are excluded, i.e. the value corresponds to the number of cycles that would be completed in 1 minute if wiping permanently over default range.. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,position)"]
                        pub fn value(&self) -> (&u8, &crate::v2::Position) {
                            (&self.v, &self.position)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Wiping frequency/speed, measured in cycles per minute. The signal concerns the actual speed of the wiper blades when moving. Intervals/pauses are excluded, i.e. the value corresponds to the number of cycles that would be completed in 1 minute if wiping permanently over default range.. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: u8,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            position: crate::v2::Position,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.position = position;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &u8) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: u8,
                            timestamp: Option<crate::v2::Timestamp>,
                            position: crate::v2::Position,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    position,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Requested position of main wiper blade for the wiper system relative to reference position. Location of reference position (0 degrees) and direction of positive/negative degrees is vehicle specific. System behavior when receiving TargetPosition depends on Mode and IsEndingWipeCycle. Supported values are vehicle specific and might be dynamically corrected. If IsEndingWipeCycle=True then wipers will complete current movement before actuating new TargetPosition. If IsEndingWipeCycle=False then wipers will directly change destination if the TargetPosition is changed.. The unit of this type is degrees"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct TargetPosition {
                        v: f32,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key_enum]
                        position: crate::v2::Position,
                    }
                    impl TargetPosition {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Requested position of main wiper blade for the wiper system relative to reference position. Location of reference position (0 degrees) and direction of positive/negative degrees is vehicle specific. System behavior when receiving TargetPosition depends on Mode and IsEndingWipeCycle. Supported values are vehicle specific and might be dynamically corrected. If IsEndingWipeCycle=True then wipers will complete current movement before actuating new TargetPosition. If IsEndingWipeCycle=False then wipers will directly change destination if the TargetPosition is changed.. The unit of this type is degrees"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,position)"]
                        pub fn value(&self) -> (&f32, &crate::v2::Position) {
                            (&self.v, &self.position)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Requested position of main wiper blade for the wiper system relative to reference position. Location of reference position (0 degrees) and direction of positive/negative degrees is vehicle specific. System behavior when receiving TargetPosition depends on Mode and IsEndingWipeCycle. Supported values are vehicle specific and might be dynamically corrected. If IsEndingWipeCycle=True then wipers will complete current movement before actuating new TargetPosition. If IsEndingWipeCycle=False then wipers will directly change destination if the TargetPosition is changed.. The unit of this type is degrees"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: f32,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            position: crate::v2::Position,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.position = position;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &f32) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: f32,
                            timestamp: Option<crate::v2::Timestamp>,
                            position: crate::v2::Position,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    position,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Actual position of main wiper blade for the wiper system relative to reference position. Location of reference position (0 degrees) and direction of positive/negative degrees is vehicle specific.. The unit of this type is degrees"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct ActualPosition {
                        v: f32,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key_enum]
                        position: crate::v2::Position,
                    }
                    impl ActualPosition {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Actual position of main wiper blade for the wiper system relative to reference position. Location of reference position (0 degrees) and direction of positive/negative degrees is vehicle specific.. The unit of this type is degrees"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,position)"]
                        pub fn value(&self) -> (&f32, &crate::v2::Position) {
                            (&self.v, &self.position)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Actual position of main wiper blade for the wiper system relative to reference position. Location of reference position (0 degrees) and direction of positive/negative degrees is vehicle specific.. The unit of this type is degrees"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: f32,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            position: crate::v2::Position,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.position = position;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &f32) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: f32,
                            timestamp: Option<crate::v2::Timestamp>,
                            position: crate::v2::Position,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    position,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Actual current used by wiper drive.. The unit of this type is A"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct DriveCurrent {
                        v: crate::v2::units::Amp<f32>,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key_enum]
                        position: crate::v2::Position,
                    }
                    impl DriveCurrent {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Actual current used by wiper drive.. The unit of this type is A"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,position)"]
                        pub fn value(&self) -> (&crate::v2::units::Amp<f32>, &crate::v2::Position) {
                            (&self.v, &self.position)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Actual current used by wiper drive.. The unit of this type is A"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: crate::v2::units::Amp<f32>,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            position: crate::v2::Position,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.position = position;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &crate::v2::units::Amp<f32>) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: crate::v2::units::Amp<f32>,
                            timestamp: Option<crate::v2::Timestamp>,
                            position: crate::v2::Position,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    position,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Indicates wiper movement. True if wiper blades are moving. Change of direction shall be considered as IsWiping if wipers will continue to move directly after the change of direction.. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct IsWiping {
                        v: bool,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key_enum]
                        position: crate::v2::Position,
                    }
                    impl IsWiping {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Indicates wiper movement. True if wiper blades are moving. Change of direction shall be considered as IsWiping if wipers will continue to move directly after the change of direction.. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,position)"]
                        pub fn value(&self) -> (&bool, &crate::v2::Position) {
                            (&self.v, &self.position)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Indicates wiper movement. True if wiper blades are moving. Change of direction shall be considered as IsWiping if wipers will continue to move directly after the change of direction.. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            position: crate::v2::Position,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.position = position;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v2::Timestamp>,
                            position: crate::v2::Position,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    position,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Indicates if current wipe movement is completed or near completion. True = Movement is completed or near completion. Changes to RequestedPosition will be executed first after reaching previous RequestedPosition, if it has not already been reached. False = Movement is not near completion. Any change to RequestedPosition will be executed immediately. Change of direction may not be allowed.. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct IsEndingWipeCycle {
                        v: bool,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key_enum]
                        position: crate::v2::Position,
                    }
                    impl IsEndingWipeCycle {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Indicates if current wipe movement is completed or near completion. True = Movement is completed or near completion. Changes to RequestedPosition will be executed first after reaching previous RequestedPosition, if it has not already been reached. False = Movement is not near completion. Any change to RequestedPosition will be executed immediately. Change of direction may not be allowed.. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,position)"]
                        pub fn value(&self) -> (&bool, &crate::v2::Position) {
                            (&self.v, &self.position)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Indicates if current wipe movement is completed or near completion. True = Movement is completed or near completion. Changes to RequestedPosition will be executed first after reaching previous RequestedPosition, if it has not already been reached. False = Movement is not near completion. Any change to RequestedPosition will be executed immediately. Change of direction may not be allowed.. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            position: crate::v2::Position,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.position = position;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v2::Timestamp>,
                            position: crate::v2::Position,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    position,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Indicates system failure. True if wiping is disabled due to system failure.. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct IsWiperError {
                        v: bool,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key_enum]
                        position: crate::v2::Position,
                    }
                    impl IsWiperError {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Indicates system failure. True if wiping is disabled due to system failure.. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,position)"]
                        pub fn value(&self) -> (&bool, &crate::v2::Position) {
                            (&self.v, &self.position)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Indicates system failure. True if wiping is disabled due to system failure.. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            position: crate::v2::Position,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.position = position;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v2::Timestamp>,
                            position: crate::v2::Position,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    position,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Indicates if a requested position has been reached. IsPositionReached refers to the previous position in case the TargetPosition is updated while IsEndingWipeCycle=True. True = Current or Previous TargetPosition reached. False = Position not (yet) reached, or wipers have moved away from the reached position.. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct IsPositionReached {
                        v: bool,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key_enum]
                        position: crate::v2::Position,
                    }
                    impl IsPositionReached {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Indicates if a requested position has been reached. IsPositionReached refers to the previous position in case the TargetPosition is updated while IsEndingWipeCycle=True. True = Current or Previous TargetPosition reached. False = Position not (yet) reached, or wipers have moved away from the reached position.. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,position)"]
                        pub fn value(&self) -> (&bool, &crate::v2::Position) {
                            (&self.v, &self.position)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Indicates if a requested position has been reached. IsPositionReached refers to the previous position in case the TargetPosition is updated while IsEndingWipeCycle=True. True = Current or Previous TargetPosition reached. False = Position not (yet) reached, or wipers have moved away from the reached position.. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            position: crate::v2::Position,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.position = position;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v2::Timestamp>,
                            position: crate::v2::Position,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    position,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Indicates if wiper movement is blocked. True = Movement blocked. False = Movement not blocked.. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct IsBlocked {
                        v: bool,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key_enum]
                        position: crate::v2::Position,
                    }
                    impl IsBlocked {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Indicates if wiper movement is blocked. True = Movement blocked. False = Movement not blocked.. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,position)"]
                        pub fn value(&self) -> (&bool, &crate::v2::Position) {
                            (&self.v, &self.position)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Indicates if wiper movement is blocked. True = Movement blocked. False = Movement not blocked.. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            position: crate::v2::Position,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.position = position;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v2::Timestamp>,
                            position: crate::v2::Position,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    position,
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Indicates if wiper system is overheated. True = Wiper system overheated. False = Wiper system not overheated.. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct IsOverheated {
                        v: bool,
                        timestamp: crate::v2::Timestamp,
                        #[topic_key_enum]
                        position: crate::v2::Position,
                    }
                    impl IsOverheated {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Indicates if wiper system is overheated. True = Wiper system overheated. False = Wiper system not overheated.. This type has no unit defined"]
                        #[doc = r" The return value is a tuple that contains a"]
                        #[doc = r" reference to the value and the additional keys the topic"]
                        #[doc = r" may have. The value is always the first entry and is"]
                        #[doc = "(value,position)"]
                        pub fn value(&self) -> (&bool, &crate::v2::Position) {
                            (&self.v, &self.position)
                        }
                        #[doc = r" Set the"]
                        #[doc = "Indicates if wiper system is overheated. True = Wiper system overheated. False = Wiper system not overheated.. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: bool,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                            position: crate::v2::Position,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            self.position = position;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &bool) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: bool,
                            timestamp: Option<crate::v2::Timestamp>,
                            position: crate::v2::Position,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                    position,
                                })
                            } else {
                                None
                            }
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod washerfluid {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Low level indication for washer fluid. True = Level Low. False = Level OK.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct IsLevelLow {
                    v: bool,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key_enum]
                    position: crate::v2::Position,
                }
                impl IsLevelLow {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Low level indication for washer fluid. True = Level Low. False = Level OK.. This type has no unit defined"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,position)"]
                    pub fn value(&self) -> (&bool, &crate::v2::Position) {
                        (&self.v, &self.position)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Low level indication for washer fluid. True = Level Low. False = Level OK.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        position: crate::v2::Position,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.position = position;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v2::Timestamp>,
                        position: crate::v2::Position,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                position,
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Washer fluid level as a percent. 0 = Empty. 100 = Full.. The unit of this type is percent"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Level {
                    v: crate::v2::units::Percent<u8>,
                    timestamp: crate::v2::Timestamp,
                    #[topic_key_enum]
                    position: crate::v2::Position,
                }
                impl Level {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Washer fluid level as a percent. 0 = Empty. 100 = Full.. The unit of this type is percent"]
                    #[doc = r" The return value is a tuple that contains a"]
                    #[doc = r" reference to the value and the additional keys the topic"]
                    #[doc = r" may have. The value is always the first entry and is"]
                    #[doc = "(value,position)"]
                    pub fn value(&self) -> (&crate::v2::units::Percent<u8>, &crate::v2::Position) {
                        (&self.v, &self.position)
                    }
                    #[doc = r" Set the"]
                    #[doc = "Washer fluid level as a percent. 0 = Empty. 100 = Full.. The unit of this type is percent"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Percent<u8>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                        position: crate::v2::Position,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        self.position = position;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v2::units::Percent<u8>) -> bool {
                        v.0 <= 100u8 && true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Percent<u8>,
                        timestamp: Option<crate::v2::Timestamp>,
                        position: crate::v2::Position,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                                position,
                            })
                        } else {
                            None
                        }
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod raindetection {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Rain intensity. 0 = Dry, No Rain. 100 = Covered.. The unit of this type is percent"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Intensity {
                v: crate::v2::units::Percent<u8>,
                timestamp: crate::v2::Timestamp,
            }
            impl Intensity {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Rain intensity. 0 = Dry, No Rain. 100 = Covered.. The unit of this type is percent"]
                pub fn value(&self) -> &crate::v2::units::Percent<u8> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Rain intensity. 0 = Dry, No Rain. 100 = Covered.. The unit of this type is percent"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Percent<u8>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v2::units::Percent<u8>) -> bool {
                    v.0 <= 100u8 && true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Percent<u8>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod horn {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Horn active or inactive. True = Active. False = Inactive.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsActive {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsActive {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Horn active or inactive. True = Active. False = Inactive.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Horn active or inactive. True = Active. False = Inactive.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod trunk {}
        #[allow(non_snake_case)]
        pub mod hood {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Hood open or closed. True = Open. False = Closed.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsOpen {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsOpen {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Hood open or closed. True = Open. False = Closed.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Hood open or closed. True = Open. False = Closed.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
    }
    #[allow(non_snake_case)]
    pub mod powertrain {
        use cdds_derive::Topic;
        use cyclonedds_rs::*;
        #[doc = "The accumulated energy from regenerative braking over lifetime.. The unit of this type is kWh"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct AccumulatedBrakingEnergy {
            v: crate::v2::units::KilowattHour<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl AccumulatedBrakingEnergy {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "The accumulated energy from regenerative braking over lifetime.. The unit of this type is kWh"]
            pub fn value(&self) -> &crate::v2::units::KilowattHour<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "The accumulated energy from regenerative braking over lifetime.. The unit of this type is kWh"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::KilowattHour<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::KilowattHour<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::KilowattHour<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Remaining range in meters using all energy sources available in the vehicle.. The unit of this type is m"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Range {
            v: crate::v2::units::Metre<u32>,
            timestamp: crate::v2::Timestamp,
        }
        impl Range {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Remaining range in meters using all energy sources available in the vehicle.. The unit of this type is m"]
            pub fn value(&self) -> &crate::v2::units::Metre<u32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Remaining range in meters using all energy sources available in the vehicle.. The unit of this type is m"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Metre<u32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Metre<u32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Metre<u32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Defines the powertrain type of the vehicle.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Type {
            v: String,
        }
        impl Type {
            #[doc = r" Get the "]
            #[doc = "Defines the powertrain type of the vehicle.. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Defines the powertrain type of the vehicle.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod fuelsystem {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "High level information of fuel types supported. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct SupportedFuelTypes {
                v: Vec<String>,
            }
            impl SupportedFuelTypes {
                #[doc = r" Get the "]
                #[doc = "High level information of fuel types supported. This type has no unit defined"]
                pub fn value(&self) -> &Vec<String> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "High level information of fuel types supported. This type has no unit defined"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: Vec<String>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &Vec<String>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: Vec<String>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Detailed information on fuels supported by the vehicle. Identifiers originating from DIN EN 16942:2021-08, appendix B, with additional suffix for octane (RON) where relevant.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct SupportedFuel {
                v: Vec<String>,
            }
            impl SupportedFuel {
                #[doc = r" Get the "]
                #[doc = "Detailed information on fuels supported by the vehicle. Identifiers originating from DIN EN 16942:2021-08, appendix B, with additional suffix for octane (RON) where relevant.. This type has no unit defined"]
                pub fn value(&self) -> &Vec<String> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Detailed information on fuels supported by the vehicle. Identifiers originating from DIN EN 16942:2021-08, appendix B, with additional suffix for octane (RON) where relevant.. This type has no unit defined"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: Vec<String>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &Vec<String>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: Vec<String>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Defines the hybrid type of the vehicle.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct HybridType {
                v: String,
            }
            impl HybridType {
                #[doc = r" Get the "]
                #[doc = "Defines the hybrid type of the vehicle.. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Defines the hybrid type of the vehicle.. This type has no unit defined"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: String) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Capacity of the fuel tank in liters.. The unit of this type is l"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct TankCapacity {
                v: crate::v2::units::Litre<f32>,
            }
            impl TankCapacity {
                #[doc = r" Get the "]
                #[doc = "Capacity of the fuel tank in liters.. The unit of this type is l"]
                pub fn value(&self) -> &crate::v2::units::Litre<f32> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Capacity of the fuel tank in liters.. The unit of this type is l"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: crate::v2::units::Litre<f32>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Litre<f32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: crate::v2::units::Litre<f32>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Level in fuel tank as percent of capacity. 0 = empty. 100 = full.. The unit of this type is percent"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Level {
                v: crate::v2::units::Percent<u8>,
                timestamp: crate::v2::Timestamp,
            }
            impl Level {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Level in fuel tank as percent of capacity. 0 = empty. 100 = full.. The unit of this type is percent"]
                pub fn value(&self) -> &crate::v2::units::Percent<u8> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Level in fuel tank as percent of capacity. 0 = empty. 100 = full.. The unit of this type is percent"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Percent<u8>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v2::units::Percent<u8>) -> bool {
                    v.0 <= 100u8 && v.0 >= 0u8
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Percent<u8>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Remaining range in meters using only liquid fuel.. The unit of this type is m"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Range {
                v: crate::v2::units::Metre<u32>,
                timestamp: crate::v2::Timestamp,
            }
            impl Range {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Remaining range in meters using only liquid fuel.. The unit of this type is m"]
                pub fn value(&self) -> &crate::v2::units::Metre<u32> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Remaining range in meters using only liquid fuel.. The unit of this type is m"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Metre<u32>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Metre<u32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Metre<u32>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Current consumption in liters per 100 km.. The unit of this type is l/100km"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct InstantConsumption {
                v: crate::v2::units::LiterPerHundredKm<f32>,
                timestamp: crate::v2::Timestamp,
            }
            impl InstantConsumption {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Current consumption in liters per 100 km.. The unit of this type is l/100km"]
                pub fn value(&self) -> &crate::v2::units::LiterPerHundredKm<f32> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Current consumption in liters per 100 km.. The unit of this type is l/100km"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::LiterPerHundredKm<f32>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v2::units::LiterPerHundredKm<f32>) -> bool {
                    true && v.0 >= 0f32
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::LiterPerHundredKm<f32>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Average consumption in liters per 100 km.. The unit of this type is l/100km"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct AverageConsumption {
                v: crate::v2::units::LiterPerHundredKm<f32>,
                timestamp: crate::v2::Timestamp,
            }
            impl AverageConsumption {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Average consumption in liters per 100 km.. The unit of this type is l/100km"]
                pub fn value(&self) -> &crate::v2::units::LiterPerHundredKm<f32> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Average consumption in liters per 100 km.. The unit of this type is l/100km"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::LiterPerHundredKm<f32>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v2::units::LiterPerHundredKm<f32>) -> bool {
                    true && v.0 >= 0f32
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::LiterPerHundredKm<f32>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Fuel amount in liters consumed since start of current trip.. The unit of this type is l"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct ConsumptionSinceStart {
                v: crate::v2::units::Litre<f32>,
                timestamp: crate::v2::Timestamp,
            }
            impl ConsumptionSinceStart {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Fuel amount in liters consumed since start of current trip.. The unit of this type is l"]
                pub fn value(&self) -> &crate::v2::units::Litre<f32> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Fuel amount in liters consumed since start of current trip.. The unit of this type is l"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Litre<f32>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Litre<f32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Litre<f32>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Time in seconds elapsed since start of current trip.. The unit of this type is s"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct TimeSinceStart {
                v: crate::v2::units::Second<u32>,
                timestamp: crate::v2::Timestamp,
            }
            impl TimeSinceStart {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Time in seconds elapsed since start of current trip.. The unit of this type is s"]
                pub fn value(&self) -> &crate::v2::units::Second<u32> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Time in seconds elapsed since start of current trip.. The unit of this type is s"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Second<u32>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Second<u32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Second<u32>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates whether eco start stop is currently enabled.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsEngineStopStartEnabled {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsEngineStopStartEnabled {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates whether eco start stop is currently enabled.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicates whether eco start stop is currently enabled.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicates that the fuel level is low (e.g. <50km range).. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsFuelLevelLow {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsFuelLevelLow {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicates that the fuel level is low (e.g. <50km range).. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicates that the fuel level is low (e.g. <50km range).. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod tractionbattery {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Battery Identification Number as assigned by OEM.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Id {
                v: String,
            }
            impl Id {
                #[doc = r" Get the "]
                #[doc = "Battery Identification Number as assigned by OEM.. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Battery Identification Number as assigned by OEM.. This type has no unit defined"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: String) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Production date of battery in ISO8601 format, e.g. YYYY-MM-DD.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct ProductionDate {
                v: String,
            }
            impl ProductionDate {
                #[doc = r" Get the "]
                #[doc = "Production date of battery in ISO8601 format, e.g. YYYY-MM-DD.. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Production date of battery in ISO8601 format, e.g. YYYY-MM-DD.. This type has no unit defined"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: String) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicating if the power (positive terminator) of the traction battery is connected to the powertrain.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsPowerConnected {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsPowerConnected {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicating if the power (positive terminator) of the traction battery is connected to the powertrain.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicating if the power (positive terminator) of the traction battery is connected to the powertrain.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Indicating if the ground (negative terminator) of the traction battery is connected to the powertrain.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsGroundConnected {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsGroundConnected {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Indicating if the ground (negative terminator) of the traction battery is connected to the powertrain.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Indicating if the ground (negative terminator) of the traction battery is connected to the powertrain.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Gross capacity of the battery.. The unit of this type is kWh"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct GrossCapacity {
                v: crate::v2::units::KilowattHour<u16>,
            }
            impl GrossCapacity {
                #[doc = r" Get the "]
                #[doc = "Gross capacity of the battery.. The unit of this type is kWh"]
                pub fn value(&self) -> &crate::v2::units::KilowattHour<u16> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Gross capacity of the battery.. The unit of this type is kWh"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: crate::v2::units::KilowattHour<u16>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::KilowattHour<u16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: crate::v2::units::KilowattHour<u16>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Total net capacity of the battery considering aging.. The unit of this type is kWh"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct NetCapacity {
                v: crate::v2::units::KilowattHour<u16>,
                timestamp: crate::v2::Timestamp,
            }
            impl NetCapacity {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Total net capacity of the battery considering aging.. The unit of this type is kWh"]
                pub fn value(&self) -> &crate::v2::units::KilowattHour<u16> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Total net capacity of the battery considering aging.. The unit of this type is kWh"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::KilowattHour<u16>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::KilowattHour<u16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::KilowattHour<u16>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Calculated battery state of health at standard conditions.. The unit of this type is percent"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct StateOfHealth {
                v: crate::v2::units::Percent<f32>,
                timestamp: crate::v2::Timestamp,
            }
            impl StateOfHealth {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Calculated battery state of health at standard conditions.. The unit of this type is percent"]
                pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Calculated battery state of health at standard conditions.. The unit of this type is percent"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Percent<f32>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v2::units::Percent<f32>) -> bool {
                    v.0 <= 100f32 && v.0 >= 0f32
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Percent<f32>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Nominal Voltage of the battery.. The unit of this type is V"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct NominalVoltage {
                v: crate::v2::units::Volt<u16>,
            }
            impl NominalVoltage {
                #[doc = r" Get the "]
                #[doc = "Nominal Voltage of the battery.. The unit of this type is V"]
                pub fn value(&self) -> &crate::v2::units::Volt<u16> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Nominal Voltage of the battery.. The unit of this type is V"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: crate::v2::units::Volt<u16>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Volt<u16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: crate::v2::units::Volt<u16>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Max allowed voltage of the battery, e.g. during charging.. The unit of this type is V"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct MaxVoltage {
                v: crate::v2::units::Volt<u16>,
            }
            impl MaxVoltage {
                #[doc = r" Get the "]
                #[doc = "Max allowed voltage of the battery, e.g. during charging.. The unit of this type is V"]
                pub fn value(&self) -> &crate::v2::units::Volt<u16> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Max allowed voltage of the battery, e.g. during charging.. The unit of this type is V"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: crate::v2::units::Volt<u16>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Volt<u16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: crate::v2::units::Volt<u16>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Current Voltage of the battery.. The unit of this type is V"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct CurrentVoltage {
                v: crate::v2::units::Volt<f32>,
                timestamp: crate::v2::Timestamp,
            }
            impl CurrentVoltage {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Current Voltage of the battery.. The unit of this type is V"]
                pub fn value(&self) -> &crate::v2::units::Volt<f32> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Current Voltage of the battery.. The unit of this type is V"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Volt<f32>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Volt<f32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Volt<f32>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Current current flowing in/out of battery. Positive = Current flowing in to battery, e.g. during charging. Negative = Current flowing out of battery, e.g. during driving.. The unit of this type is A"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct CurrentCurrent {
                v: crate::v2::units::Amp<f32>,
                timestamp: crate::v2::Timestamp,
            }
            impl CurrentCurrent {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Current current flowing in/out of battery. Positive = Current flowing in to battery, e.g. during charging. Negative = Current flowing out of battery, e.g. during driving.. The unit of this type is A"]
                pub fn value(&self) -> &crate::v2::units::Amp<f32> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Current current flowing in/out of battery. Positive = Current flowing in to battery, e.g. during charging. Negative = Current flowing out of battery, e.g. during driving.. The unit of this type is A"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Amp<f32>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Amp<f32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Amp<f32>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Current electrical energy flowing in/out of battery. Positive = Energy flowing in to battery, e.g. during charging. Negative = Energy flowing out of battery, e.g. during driving.. The unit of this type is W"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct CurrentPower {
                v: crate::v2::units::Watt<f32>,
                timestamp: crate::v2::Timestamp,
            }
            impl CurrentPower {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Current electrical energy flowing in/out of battery. Positive = Energy flowing in to battery, e.g. during charging. Negative = Energy flowing out of battery, e.g. during driving.. The unit of this type is W"]
                pub fn value(&self) -> &crate::v2::units::Watt<f32> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Current electrical energy flowing in/out of battery. Positive = Energy flowing in to battery, e.g. during charging. Negative = Energy flowing out of battery, e.g. during driving.. The unit of this type is W"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Watt<f32>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Watt<f32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Watt<f32>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "The accumulated energy delivered to the battery during charging over lifetime of the battery.. The unit of this type is kWh"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct AccumulatedChargedEnergy {
                v: crate::v2::units::KilowattHour<f32>,
                timestamp: crate::v2::Timestamp,
            }
            impl AccumulatedChargedEnergy {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "The accumulated energy delivered to the battery during charging over lifetime of the battery.. The unit of this type is kWh"]
                pub fn value(&self) -> &crate::v2::units::KilowattHour<f32> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "The accumulated energy delivered to the battery during charging over lifetime of the battery.. The unit of this type is kWh"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::KilowattHour<f32>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::KilowattHour<f32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::KilowattHour<f32>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "The accumulated energy leaving HV battery for propulsion and auxiliary loads over lifetime of the battery.. The unit of this type is kWh"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct AccumulatedConsumedEnergy {
                v: crate::v2::units::KilowattHour<f32>,
                timestamp: crate::v2::Timestamp,
            }
            impl AccumulatedConsumedEnergy {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "The accumulated energy leaving HV battery for propulsion and auxiliary loads over lifetime of the battery.. The unit of this type is kWh"]
                pub fn value(&self) -> &crate::v2::units::KilowattHour<f32> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "The accumulated energy leaving HV battery for propulsion and auxiliary loads over lifetime of the battery.. The unit of this type is kWh"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::KilowattHour<f32>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::KilowattHour<f32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::KilowattHour<f32>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "The accumulated charge throughput delivered to the battery during charging over lifetime of the battery.. The unit of this type is Ah"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct AccumulatedChargedThroughput {
                v: f32,
                timestamp: crate::v2::Timestamp,
            }
            impl AccumulatedChargedThroughput {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "The accumulated charge throughput delivered to the battery during charging over lifetime of the battery.. The unit of this type is Ah"]
                pub fn value(&self) -> &f32 {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "The accumulated charge throughput delivered to the battery during charging over lifetime of the battery.. The unit of this type is Ah"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: f32, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &f32) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: f32, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "The accumulated charge throughput leaving HV battery for propulsion and auxiliary loads over lifetime of the battery.. The unit of this type is Ah"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct AccumulatedConsumedThroughput {
                v: f32,
                timestamp: crate::v2::Timestamp,
            }
            impl AccumulatedConsumedThroughput {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "The accumulated charge throughput leaving HV battery for propulsion and auxiliary loads over lifetime of the battery.. The unit of this type is Ah"]
                pub fn value(&self) -> &f32 {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "The accumulated charge throughput leaving HV battery for propulsion and auxiliary loads over lifetime of the battery.. The unit of this type is Ah"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: f32, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &f32) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: f32, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Electrical energy lost by power dissipation to heat inside the battery.. The unit of this type is W"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct PowerLoss {
                v: crate::v2::units::Watt<f32>,
                timestamp: crate::v2::Timestamp,
            }
            impl PowerLoss {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Electrical energy lost by power dissipation to heat inside the battery.. The unit of this type is W"]
                pub fn value(&self) -> &crate::v2::units::Watt<f32> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Electrical energy lost by power dissipation to heat inside the battery.. The unit of this type is W"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Watt<f32>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Watt<f32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Watt<f32>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Remaining range in meters using only battery.. The unit of this type is m"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Range {
                v: crate::v2::units::Metre<u32>,
                timestamp: crate::v2::Timestamp,
            }
            impl Range {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Remaining range in meters using only battery.. The unit of this type is m"]
                pub fn value(&self) -> &crate::v2::units::Metre<u32> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Remaining range in meters using only battery.. The unit of this type is m"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Metre<u32>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Metre<u32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Metre<u32>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod dcdc {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Electrical energy lost by power dissipation to heat inside DC/DC converter.. The unit of this type is W"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct PowerLoss {
                    v: crate::v2::units::Watt<f32>,
                    timestamp: crate::v2::Timestamp,
                }
                impl PowerLoss {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Electrical energy lost by power dissipation to heat inside DC/DC converter.. The unit of this type is W"]
                    pub fn value(&self) -> &crate::v2::units::Watt<f32> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Electrical energy lost by power dissipation to heat inside DC/DC converter.. The unit of this type is W"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Watt<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Watt<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Watt<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Current temperature of DC/DC converter converting battery high voltage to vehicle low voltage (typically 12 Volts).. The unit of this type is celsius"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Temperature {
                    v: crate::v2::units::Celsius<f32>,
                    timestamp: crate::v2::Timestamp,
                }
                impl Temperature {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Current temperature of DC/DC converter converting battery high voltage to vehicle low voltage (typically 12 Volts).. The unit of this type is celsius"]
                    pub fn value(&self) -> &crate::v2::units::Celsius<f32> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Current temperature of DC/DC converter converting battery high voltage to vehicle low voltage (typically 12 Volts).. The unit of this type is celsius"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Celsius<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Celsius<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Celsius<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod charging {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Target charge limit (state of charge) for battery.. The unit of this type is percent"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct ChargeLimit {
                    v: crate::v2::units::Percent<u8>,
                    timestamp: crate::v2::Timestamp,
                }
                impl ChargeLimit {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Target charge limit (state of charge) for battery.. The unit of this type is percent"]
                    pub fn value(&self) -> &crate::v2::units::Percent<u8> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Target charge limit (state of charge) for battery.. The unit of this type is percent"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Percent<u8>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v2::units::Percent<u8>) -> bool {
                        v.0 <= 100u8 && v.0 >= 0u8
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Percent<u8>,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Status of the charge port cover, can potentially be controlled manually.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct ChargePortFlap {
                    v: String,
                    timestamp: crate::v2::Timestamp,
                }
                impl ChargePortFlap {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Status of the charge port cover, can potentially be controlled manually.. This type has no unit defined"]
                    pub fn value(&self) -> &String {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Status of the charge port cover, can potentially be controlled manually.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Indicates if a charging cable is physically connected to the vehicle or not.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct IsChargingCableConnected {
                    v: bool,
                    timestamp: crate::v2::Timestamp,
                }
                impl IsChargingCableConnected {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Indicates if a charging cable is physically connected to the vehicle or not.. This type has no unit defined"]
                    pub fn value(&self) -> &bool {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Indicates if a charging cable is physically connected to the vehicle or not.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Is charging cable locked to prevent removal.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct IsChargingCableLocked {
                    v: bool,
                    timestamp: crate::v2::Timestamp,
                }
                impl IsChargingCableLocked {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Is charging cable locked to prevent removal.. This type has no unit defined"]
                    pub fn value(&self) -> &bool {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Is charging cable locked to prevent removal.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Type of charge plug (charging inlet) available on the vehicle. IEC types refer to IEC 62196,  GBT refers to  GB/T 20234.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct ChargePlugType {
                    v: Vec<String>,
                }
                impl ChargePlugType {
                    #[doc = r" Get the "]
                    #[doc = "Type of charge plug (charging inlet) available on the vehicle. IEC types refer to IEC 62196,  GBT refers to  GB/T 20234.. This type has no unit defined"]
                    pub fn value(&self) -> &Vec<String> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Type of charge plug (charging inlet) available on the vehicle. IEC types refer to IEC 62196,  GBT refers to  GB/T 20234.. This type has no unit defined"]
                    #[doc = r" Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(&mut self, value: Vec<String>) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &Vec<String>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(value: Vec<String>) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self { v: value })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Control of the charge process. MANUAL means manually initiated (plug-in event, companion app, etc). TIMER means timer-based. GRID means grid-controlled (eg ISO 15118). PROFILE means controlled by profile download to vehicle.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Mode {
                    v: String,
                    timestamp: crate::v2::Timestamp,
                }
                impl Mode {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Control of the charge process. MANUAL means manually initiated (plug-in event, companion app, etc). TIMER means timer-based. GRID means grid-controlled (eg ISO 15118). PROFILE means controlled by profile download to vehicle.. This type has no unit defined"]
                    pub fn value(&self) -> &String {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Control of the charge process. MANUAL means manually initiated (plug-in event, companion app, etc). TIMER means timer-based. GRID means grid-controlled (eg ISO 15118). PROFILE means controlled by profile download to vehicle.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "True if charging is ongoing. Charging is considered to be ongoing if energy is flowing from charger to vehicle.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct IsCharging {
                    v: bool,
                    timestamp: crate::v2::Timestamp,
                }
                impl IsCharging {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "True if charging is ongoing. Charging is considered to be ongoing if energy is flowing from charger to vehicle.. This type has no unit defined"]
                    pub fn value(&self) -> &bool {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "True if charging is ongoing. Charging is considered to be ongoing if energy is flowing from charger to vehicle.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "True if discharging (vehicle to grid) is ongoing. Discharging is considered to be ongoing if energy is flowing from vehicle to charger/grid.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct IsDischarging {
                    v: bool,
                    timestamp: crate::v2::Timestamp,
                }
                impl IsDischarging {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "True if discharging (vehicle to grid) is ongoing. Discharging is considered to be ongoing if energy is flowing from vehicle to charger/grid.. This type has no unit defined"]
                    pub fn value(&self) -> &bool {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "True if discharging (vehicle to grid) is ongoing. Discharging is considered to be ongoing if energy is flowing from vehicle to charger/grid.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Start or stop the charging process.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct StartStopCharging {
                    v: String,
                    timestamp: crate::v2::Timestamp,
                }
                impl StartStopCharging {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Start or stop the charging process.. This type has no unit defined"]
                    pub fn value(&self) -> &String {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Start or stop the charging process.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: String,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &String) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: String,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Electrical energy lost by power dissipation to heat inside the AC/DC converter.. The unit of this type is W"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct PowerLoss {
                    v: crate::v2::units::Watt<f32>,
                    timestamp: crate::v2::Timestamp,
                }
                impl PowerLoss {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Electrical energy lost by power dissipation to heat inside the AC/DC converter.. The unit of this type is W"]
                    pub fn value(&self) -> &crate::v2::units::Watt<f32> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Electrical energy lost by power dissipation to heat inside the AC/DC converter.. The unit of this type is W"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Watt<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Watt<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Watt<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Current temperature of AC/DC converter converting grid voltage to battery voltage.. The unit of this type is celsius"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Temperature {
                    v: crate::v2::units::Celsius<f32>,
                    timestamp: crate::v2::Timestamp,
                }
                impl Temperature {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Current temperature of AC/DC converter converting grid voltage to battery voltage.. The unit of this type is celsius"]
                    pub fn value(&self) -> &crate::v2::units::Celsius<f32> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Current temperature of AC/DC converter converting grid voltage to battery voltage.. The unit of this type is celsius"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Celsius<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Celsius<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Celsius<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Current charging rate, as in kilometers of range added per hour.. The unit of this type is km/h"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct ChargeRate {
                    v: crate::v2::units::KilometrePerHour<f32>,
                    timestamp: crate::v2::Timestamp,
                }
                impl ChargeRate {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Current charging rate, as in kilometers of range added per hour.. The unit of this type is km/h"]
                    pub fn value(&self) -> &crate::v2::units::KilometrePerHour<f32> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Current charging rate, as in kilometers of range added per hour.. The unit of this type is km/h"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::KilometrePerHour<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::KilometrePerHour<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::KilometrePerHour<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "The time needed for the current charging process to reach Charging.ChargeLimit. 0 if charging is complete or no charging process is active or planned.. The unit of this type is s"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct TimeToComplete {
                    v: crate::v2::units::Second<u32>,
                    timestamp: crate::v2::Timestamp,
                }
                impl TimeToComplete {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "The time needed for the current charging process to reach Charging.ChargeLimit. 0 if charging is complete or no charging process is active or planned.. The unit of this type is s"]
                    pub fn value(&self) -> &crate::v2::units::Second<u32> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "The time needed for the current charging process to reach Charging.ChargeLimit. 0 if charging is complete or no charging process is active or planned.. The unit of this type is s"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Second<u32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Second<u32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Second<u32>,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[allow(non_snake_case)]
                pub mod timer {
                    use cdds_derive::Topic;
                    use cyclonedds_rs::*;
                    #[doc = "Defines timer mode for charging: INACTIVE - no timer set, charging may start as soon as battery is connected to a charger. START_TIME - charging shall start at Charging.Timer.Time. END_TIME - charging shall be finished (reach Charging.ChargeLimit) at Charging.Timer.Time. When charging is completed the vehicle shall change mode to 'inactive' or set a new Charging.Timer.Time. Charging shall start immediately if mode is 'starttime' or 'endtime' and Charging.Timer.Time is a time in the past.. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Mode {
                        v: String,
                        timestamp: crate::v2::Timestamp,
                    }
                    impl Mode {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Defines timer mode for charging: INACTIVE - no timer set, charging may start as soon as battery is connected to a charger. START_TIME - charging shall start at Charging.Timer.Time. END_TIME - charging shall be finished (reach Charging.ChargeLimit) at Charging.Timer.Time. When charging is completed the vehicle shall change mode to 'inactive' or set a new Charging.Timer.Time. Charging shall start immediately if mode is 'starttime' or 'endtime' and Charging.Timer.Time is a time in the past.. This type has no unit defined"]
                        pub fn value(&self) -> &String {
                            &self.v
                        }
                        #[doc = r" Set the"]
                        #[doc = "Defines timer mode for charging: INACTIVE - no timer set, charging may start as soon as battery is connected to a charger. START_TIME - charging shall start at Charging.Timer.Time. END_TIME - charging shall be finished (reach Charging.ChargeLimit) at Charging.Timer.Time. When charging is completed the vehicle shall change mode to 'inactive' or set a new Charging.Timer.Time. Charging shall start immediately if mode is 'starttime' or 'endtime' and Charging.Timer.Time is a time in the past.. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: String,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &String) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: String,
                            timestamp: Option<crate::v2::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Time for next charging-related action, formatted according to ISO 8601 with UTC time zone. Value has no significance if Charging.Timer.Mode is 'inactive'.. This type has no unit defined"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Time {
                        v: String,
                        timestamp: crate::v2::Timestamp,
                    }
                    impl Time {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Time for next charging-related action, formatted according to ISO 8601 with UTC time zone. Value has no significance if Charging.Timer.Mode is 'inactive'.. This type has no unit defined"]
                        pub fn value(&self) -> &String {
                            &self.v
                        }
                        #[doc = r" Set the"]
                        #[doc = "Time for next charging-related action, formatted according to ISO 8601 with UTC time zone. Value has no significance if Charging.Timer.Mode is 'inactive'.. This type has no unit defined"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: String,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &String) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: String,
                            timestamp: Option<crate::v2::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                }
                #[allow(non_snake_case)]
                pub mod chargevoltage {
                    use cdds_derive::Topic;
                    use cyclonedds_rs::*;
                    #[doc = "Current DC charging voltage at charging inlet.. The unit of this type is V"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct DC {
                        v: crate::v2::units::Volt<f32>,
                        timestamp: crate::v2::Timestamp,
                    }
                    impl DC {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Current DC charging voltage at charging inlet.. The unit of this type is V"]
                        pub fn value(&self) -> &crate::v2::units::Volt<f32> {
                            &self.v
                        }
                        #[doc = r" Set the"]
                        #[doc = "Current DC charging voltage at charging inlet.. The unit of this type is V"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: crate::v2::units::Volt<f32>,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &crate::v2::units::Volt<f32>) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: crate::v2::units::Volt<f32>,
                            timestamp: Option<crate::v2::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Current AC charging voltage (rms) at inlet for Phase 1.. The unit of this type is V"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Phase1 {
                        v: crate::v2::units::Volt<f32>,
                        timestamp: crate::v2::Timestamp,
                    }
                    impl Phase1 {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Current AC charging voltage (rms) at inlet for Phase 1.. The unit of this type is V"]
                        pub fn value(&self) -> &crate::v2::units::Volt<f32> {
                            &self.v
                        }
                        #[doc = r" Set the"]
                        #[doc = "Current AC charging voltage (rms) at inlet for Phase 1.. The unit of this type is V"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: crate::v2::units::Volt<f32>,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &crate::v2::units::Volt<f32>) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: crate::v2::units::Volt<f32>,
                            timestamp: Option<crate::v2::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Current AC charging voltage (rms) at inlet for Phase 2.. The unit of this type is V"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Phase2 {
                        v: crate::v2::units::Volt<f32>,
                        timestamp: crate::v2::Timestamp,
                    }
                    impl Phase2 {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Current AC charging voltage (rms) at inlet for Phase 2.. The unit of this type is V"]
                        pub fn value(&self) -> &crate::v2::units::Volt<f32> {
                            &self.v
                        }
                        #[doc = r" Set the"]
                        #[doc = "Current AC charging voltage (rms) at inlet for Phase 2.. The unit of this type is V"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: crate::v2::units::Volt<f32>,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &crate::v2::units::Volt<f32>) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: crate::v2::units::Volt<f32>,
                            timestamp: Option<crate::v2::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Current AC charging voltage (rms) at inlet for Phase 3.. The unit of this type is V"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Phase3 {
                        v: crate::v2::units::Volt<f32>,
                        timestamp: crate::v2::Timestamp,
                    }
                    impl Phase3 {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Current AC charging voltage (rms) at inlet for Phase 3.. The unit of this type is V"]
                        pub fn value(&self) -> &crate::v2::units::Volt<f32> {
                            &self.v
                        }
                        #[doc = r" Set the"]
                        #[doc = "Current AC charging voltage (rms) at inlet for Phase 3.. The unit of this type is V"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: crate::v2::units::Volt<f32>,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &crate::v2::units::Volt<f32>) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: crate::v2::units::Volt<f32>,
                            timestamp: Option<crate::v2::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                }
                #[allow(non_snake_case)]
                pub mod chargecurrent {
                    use cdds_derive::Topic;
                    use cyclonedds_rs::*;
                    #[doc = "Current DC charging current at inlet. Negative if returning energy to grid.. The unit of this type is A"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct DC {
                        v: crate::v2::units::Amp<f32>,
                        timestamp: crate::v2::Timestamp,
                    }
                    impl DC {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Current DC charging current at inlet. Negative if returning energy to grid.. The unit of this type is A"]
                        pub fn value(&self) -> &crate::v2::units::Amp<f32> {
                            &self.v
                        }
                        #[doc = r" Set the"]
                        #[doc = "Current DC charging current at inlet. Negative if returning energy to grid.. The unit of this type is A"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: crate::v2::units::Amp<f32>,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &crate::v2::units::Amp<f32>) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: crate::v2::units::Amp<f32>,
                            timestamp: Option<crate::v2::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Current AC charging current (rms) at inlet for Phase 1. Negative if returning energy to grid.. The unit of this type is A"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Phase1 {
                        v: crate::v2::units::Amp<f32>,
                        timestamp: crate::v2::Timestamp,
                    }
                    impl Phase1 {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Current AC charging current (rms) at inlet for Phase 1. Negative if returning energy to grid.. The unit of this type is A"]
                        pub fn value(&self) -> &crate::v2::units::Amp<f32> {
                            &self.v
                        }
                        #[doc = r" Set the"]
                        #[doc = "Current AC charging current (rms) at inlet for Phase 1. Negative if returning energy to grid.. The unit of this type is A"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: crate::v2::units::Amp<f32>,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &crate::v2::units::Amp<f32>) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: crate::v2::units::Amp<f32>,
                            timestamp: Option<crate::v2::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Current AC charging current (rms) at inlet for Phase 2. Negative if returning energy to grid.. The unit of this type is A"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Phase2 {
                        v: crate::v2::units::Amp<f32>,
                        timestamp: crate::v2::Timestamp,
                    }
                    impl Phase2 {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Current AC charging current (rms) at inlet for Phase 2. Negative if returning energy to grid.. The unit of this type is A"]
                        pub fn value(&self) -> &crate::v2::units::Amp<f32> {
                            &self.v
                        }
                        #[doc = r" Set the"]
                        #[doc = "Current AC charging current (rms) at inlet for Phase 2. Negative if returning energy to grid.. The unit of this type is A"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: crate::v2::units::Amp<f32>,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &crate::v2::units::Amp<f32>) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: crate::v2::units::Amp<f32>,
                            timestamp: Option<crate::v2::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Current AC charging current (rms) at inlet for Phase 3. Negative if returning energy to grid.. The unit of this type is A"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Phase3 {
                        v: crate::v2::units::Amp<f32>,
                        timestamp: crate::v2::Timestamp,
                    }
                    impl Phase3 {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Current AC charging current (rms) at inlet for Phase 3. Negative if returning energy to grid.. The unit of this type is A"]
                        pub fn value(&self) -> &crate::v2::units::Amp<f32> {
                            &self.v
                        }
                        #[doc = r" Set the"]
                        #[doc = "Current AC charging current (rms) at inlet for Phase 3. Negative if returning energy to grid.. The unit of this type is A"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: crate::v2::units::Amp<f32>,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &crate::v2::units::Amp<f32>) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: crate::v2::units::Amp<f32>,
                            timestamp: Option<crate::v2::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                }
                #[allow(non_snake_case)]
                pub mod maximumchargingcurrent {
                    use cdds_derive::Topic;
                    use cyclonedds_rs::*;
                    #[doc = "Maximum DC charging current at inlet that can be accepted by the system.. The unit of this type is A"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct DC {
                        v: crate::v2::units::Amp<f32>,
                        timestamp: crate::v2::Timestamp,
                    }
                    impl DC {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Maximum DC charging current at inlet that can be accepted by the system.. The unit of this type is A"]
                        pub fn value(&self) -> &crate::v2::units::Amp<f32> {
                            &self.v
                        }
                        #[doc = r" Set the"]
                        #[doc = "Maximum DC charging current at inlet that can be accepted by the system.. The unit of this type is A"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: crate::v2::units::Amp<f32>,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &crate::v2::units::Amp<f32>) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: crate::v2::units::Amp<f32>,
                            timestamp: Option<crate::v2::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Maximum AC charging current (rms) at inlet for Phase 1 that can be accepted by the system.. The unit of this type is A"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Phase1 {
                        v: crate::v2::units::Amp<f32>,
                        timestamp: crate::v2::Timestamp,
                    }
                    impl Phase1 {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Maximum AC charging current (rms) at inlet for Phase 1 that can be accepted by the system.. The unit of this type is A"]
                        pub fn value(&self) -> &crate::v2::units::Amp<f32> {
                            &self.v
                        }
                        #[doc = r" Set the"]
                        #[doc = "Maximum AC charging current (rms) at inlet for Phase 1 that can be accepted by the system.. The unit of this type is A"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: crate::v2::units::Amp<f32>,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &crate::v2::units::Amp<f32>) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: crate::v2::units::Amp<f32>,
                            timestamp: Option<crate::v2::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Maximum AC charging current (rms) at inlet for Phase 2 that can be accepted by the system.. The unit of this type is A"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Phase2 {
                        v: crate::v2::units::Amp<f32>,
                        timestamp: crate::v2::Timestamp,
                    }
                    impl Phase2 {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Maximum AC charging current (rms) at inlet for Phase 2 that can be accepted by the system.. The unit of this type is A"]
                        pub fn value(&self) -> &crate::v2::units::Amp<f32> {
                            &self.v
                        }
                        #[doc = r" Set the"]
                        #[doc = "Maximum AC charging current (rms) at inlet for Phase 2 that can be accepted by the system.. The unit of this type is A"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: crate::v2::units::Amp<f32>,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &crate::v2::units::Amp<f32>) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: crate::v2::units::Amp<f32>,
                            timestamp: Option<crate::v2::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                    #[doc = "Maximum AC charging current (rms) at inlet for Phase 3 that can be accepted by the system.. The unit of this type is A"]
                    #[allow(non_camel_case_types)]
                    #[derive(Default, Deserialize, Serialize, Topic)]
                    pub struct Phase3 {
                        v: crate::v2::units::Amp<f32>,
                        timestamp: crate::v2::Timestamp,
                    }
                    impl Phase3 {
                        pub fn timestamp(&self) -> &crate::v2::Timestamp {
                            &self.timestamp
                        }
                        #[doc = r" Get the "]
                        #[doc = "Maximum AC charging current (rms) at inlet for Phase 3 that can be accepted by the system.. The unit of this type is A"]
                        pub fn value(&self) -> &crate::v2::units::Amp<f32> {
                            &self.v
                        }
                        #[doc = r" Set the"]
                        #[doc = "Maximum AC charging current (rms) at inlet for Phase 3 that can be accepted by the system.. The unit of this type is A"]
                        #[doc = r" . Ensure that the value is within bounds as per the"]
                        #[doc = r" specification. This function will panic in case the value is out"]
                        #[doc = r" of bounds."]
                        pub fn set(
                            &mut self,
                            value: crate::v2::units::Amp<f32>,
                            maybe_timestamp: Option<crate::v2::Timestamp>,
                        ) {
                            assert!(Self::bounds_check(&value));
                            self.v = value;
                            if let Some(ts) = maybe_timestamp {
                                self.timestamp = ts;
                            }
                        }
                        #[doc = r"check if the given value is within the limits defined"]
                        #[doc = r"in the specification. This particular type has not"]
                        #[doc = r"specified the min or max limits so the function just"]
                        #[doc = r" returns true"]
                        const fn bounds_check(_v: &crate::v2::units::Amp<f32>) -> bool {
                            true
                        }
                        #[doc = r" create a new instance"]
                        pub fn new(
                            value: crate::v2::units::Amp<f32>,
                            timestamp: Option<crate::v2::Timestamp>,
                        ) -> Option<Self> {
                            if Self::bounds_check(&value) {
                                Some(Self {
                                    v: value,
                                    timestamp: timestamp.unwrap_or_default(),
                                })
                            } else {
                                None
                            }
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod stateofcharge {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Physical state of charge of the high voltage battery, relative to net capacity. This is not necessarily the state of charge being displayed to the customer.. The unit of this type is percent"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Current {
                    v: crate::v2::units::Percent<f32>,
                    timestamp: crate::v2::Timestamp,
                }
                impl Current {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Physical state of charge of the high voltage battery, relative to net capacity. This is not necessarily the state of charge being displayed to the customer.. The unit of this type is percent"]
                    pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Physical state of charge of the high voltage battery, relative to net capacity. This is not necessarily the state of charge being displayed to the customer.. The unit of this type is percent"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Percent<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v2::units::Percent<f32>) -> bool {
                        v.0 <= 100.0f32 && v.0 >= 0f32
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Percent<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "State of charge displayed to the customer.. The unit of this type is percent"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Displayed {
                    v: crate::v2::units::Percent<f32>,
                    timestamp: crate::v2::Timestamp,
                }
                impl Displayed {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "State of charge displayed to the customer.. The unit of this type is percent"]
                    pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "State of charge displayed to the customer.. The unit of this type is percent"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Percent<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v2::units::Percent<f32>) -> bool {
                        v.0 <= 100.0f32 && v.0 >= 0f32
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Percent<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod temperature {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Current average temperature of the battery cells.. The unit of this type is celsius"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Average {
                    v: crate::v2::units::Celsius<f32>,
                    timestamp: crate::v2::Timestamp,
                }
                impl Average {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Current average temperature of the battery cells.. The unit of this type is celsius"]
                    pub fn value(&self) -> &crate::v2::units::Celsius<f32> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Current average temperature of the battery cells.. The unit of this type is celsius"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Celsius<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Celsius<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Celsius<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Current minimum temperature of the battery cells, i.e. temperature of the coldest cell.. The unit of this type is celsius"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Min {
                    v: crate::v2::units::Celsius<f32>,
                    timestamp: crate::v2::Timestamp,
                }
                impl Min {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Current minimum temperature of the battery cells, i.e. temperature of the coldest cell.. The unit of this type is celsius"]
                    pub fn value(&self) -> &crate::v2::units::Celsius<f32> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Current minimum temperature of the battery cells, i.e. temperature of the coldest cell.. The unit of this type is celsius"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Celsius<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Celsius<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Celsius<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Current maximum temperature of the battery cells, i.e. temperature of the hottest cell.. The unit of this type is celsius"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Max {
                    v: crate::v2::units::Celsius<f32>,
                    timestamp: crate::v2::Timestamp,
                }
                impl Max {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Current maximum temperature of the battery cells, i.e. temperature of the hottest cell.. The unit of this type is celsius"]
                    pub fn value(&self) -> &crate::v2::units::Celsius<f32> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Current maximum temperature of the battery cells, i.e. temperature of the hottest cell.. The unit of this type is celsius"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Celsius<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Celsius<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Celsius<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod electricmotor {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Engine code designation, as specified by vehicle manufacturer.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct EngineCode {
                v: String,
            }
            impl EngineCode {
                #[doc = r" Get the "]
                #[doc = "Engine code designation, as specified by vehicle manufacturer.. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Engine code designation, as specified by vehicle manufacturer.. This type has no unit defined"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: String) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Peak power, in kilowatts, that motor(s) can generate.. The unit of this type is kW"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct MaxPower {
                v: crate::v2::units::Kilowatt<u16>,
            }
            impl MaxPower {
                #[doc = r" Get the "]
                #[doc = "Peak power, in kilowatts, that motor(s) can generate.. The unit of this type is kW"]
                pub fn value(&self) -> &crate::v2::units::Kilowatt<u16> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Peak power, in kilowatts, that motor(s) can generate.. The unit of this type is kW"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: crate::v2::units::Kilowatt<u16>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Kilowatt<u16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: crate::v2::units::Kilowatt<u16>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Peak power, in newton meter, that the motor(s) can generate.. The unit of this type is Nm"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct MaxTorque {
                v: crate::v2::units::NewtonMetre<u16>,
            }
            impl MaxTorque {
                #[doc = r" Get the "]
                #[doc = "Peak power, in newton meter, that the motor(s) can generate.. The unit of this type is Nm"]
                pub fn value(&self) -> &crate::v2::units::NewtonMetre<u16> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Peak power, in newton meter, that the motor(s) can generate.. The unit of this type is Nm"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: crate::v2::units::NewtonMetre<u16>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::NewtonMetre<u16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: crate::v2::units::NewtonMetre<u16>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Peak regen/brake power, in kilowatts, that motor(s) can generate.. The unit of this type is kW"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct MaxRegenPower {
                v: crate::v2::units::Kilowatt<u16>,
            }
            impl MaxRegenPower {
                #[doc = r" Get the "]
                #[doc = "Peak regen/brake power, in kilowatts, that motor(s) can generate.. The unit of this type is kW"]
                pub fn value(&self) -> &crate::v2::units::Kilowatt<u16> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Peak regen/brake power, in kilowatts, that motor(s) can generate.. The unit of this type is kW"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: crate::v2::units::Kilowatt<u16>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Kilowatt<u16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: crate::v2::units::Kilowatt<u16>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Peak regen/brake torque, in newton meter, that the motor(s) can generate.. The unit of this type is Nm"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct MaxRegenTorque {
                v: crate::v2::units::NewtonMetre<u16>,
            }
            impl MaxRegenTorque {
                #[doc = r" Get the "]
                #[doc = "Peak regen/brake torque, in newton meter, that the motor(s) can generate.. The unit of this type is Nm"]
                pub fn value(&self) -> &crate::v2::units::NewtonMetre<u16> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Peak regen/brake torque, in newton meter, that the motor(s) can generate.. The unit of this type is Nm"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: crate::v2::units::NewtonMetre<u16>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::NewtonMetre<u16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: crate::v2::units::NewtonMetre<u16>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Motor rotational speed measured as rotations per minute. Negative values indicate reverse driving mode.. The unit of this type is rpm"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Speed {
                v: crate::v2::units::RPM<i32>,
                timestamp: crate::v2::Timestamp,
            }
            impl Speed {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Motor rotational speed measured as rotations per minute. Negative values indicate reverse driving mode.. The unit of this type is rpm"]
                pub fn value(&self) -> &crate::v2::units::RPM<i32> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Motor rotational speed measured as rotations per minute. Negative values indicate reverse driving mode.. The unit of this type is rpm"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::RPM<i32>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::RPM<i32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::RPM<i32>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Motor temperature.. The unit of this type is celsius"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Temperature {
                v: crate::v2::units::Celsius<i16>,
                timestamp: crate::v2::Timestamp,
            }
            impl Temperature {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Motor temperature.. The unit of this type is celsius"]
                pub fn value(&self) -> &crate::v2::units::Celsius<i16> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Motor temperature.. The unit of this type is celsius"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Celsius<i16>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Celsius<i16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Celsius<i16>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Motor coolant temperature (if applicable).. The unit of this type is celsius"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct CoolantTemperature {
                v: crate::v2::units::Celsius<i16>,
                timestamp: crate::v2::Timestamp,
            }
            impl CoolantTemperature {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Motor coolant temperature (if applicable).. The unit of this type is celsius"]
                pub fn value(&self) -> &crate::v2::units::Celsius<i16> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Motor coolant temperature (if applicable).. The unit of this type is celsius"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Celsius<i16>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Celsius<i16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Celsius<i16>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Current motor power output. Negative values indicate regen mode.. The unit of this type is kW"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Power {
                v: crate::v2::units::Kilowatt<i16>,
                timestamp: crate::v2::Timestamp,
            }
            impl Power {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Current motor power output. Negative values indicate regen mode.. The unit of this type is kW"]
                pub fn value(&self) -> &crate::v2::units::Kilowatt<i16> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Current motor power output. Negative values indicate regen mode.. The unit of this type is kW"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Kilowatt<i16>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Kilowatt<i16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Kilowatt<i16>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Current motor torque. Negative values indicate regen mode.. The unit of this type is Nm"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Torque {
                v: crate::v2::units::NewtonMetre<i16>,
                timestamp: crate::v2::Timestamp,
            }
            impl Torque {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Current motor torque. Negative values indicate regen mode.. The unit of this type is Nm"]
                pub fn value(&self) -> &crate::v2::units::NewtonMetre<i16> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Current motor torque. Negative values indicate regen mode.. The unit of this type is Nm"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::NewtonMetre<i16>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::NewtonMetre<i16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::NewtonMetre<i16>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod transmission {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Transmission type.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Type {
                v: String,
            }
            impl Type {
                #[doc = r" Get the "]
                #[doc = "Transmission type.. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Transmission type.. This type has no unit defined"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: String) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Number of forward gears in the transmission. -1 = CVT.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct GearCount {
                v: i8,
            }
            impl GearCount {
                #[doc = r" Get the "]
                #[doc = "Number of forward gears in the transmission. -1 = CVT.. This type has no unit defined"]
                pub fn value(&self) -> &i8 {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Number of forward gears in the transmission. -1 = CVT.. This type has no unit defined"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: i8) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &i8) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: i8) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Drive type.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct DriveType {
                v: String,
            }
            impl DriveType {
                #[doc = r" Get the "]
                #[doc = "Drive type.. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Drive type.. This type has no unit defined"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: String) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Odometer reading, total distance travelled during the lifetime of the transmission.. The unit of this type is km"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct TravelledDistance {
                v: crate::v2::units::Kilometre<f32>,
                timestamp: crate::v2::Timestamp,
            }
            impl TravelledDistance {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Odometer reading, total distance travelled during the lifetime of the transmission.. The unit of this type is km"]
                pub fn value(&self) -> &crate::v2::units::Kilometre<f32> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Odometer reading, total distance travelled during the lifetime of the transmission.. The unit of this type is km"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Kilometre<f32>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Kilometre<f32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Kilometre<f32>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "The current gear. 0=Neutral, 1/2/..=Forward, -1/-2/..=Reverse.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct CurrentGear {
                v: i8,
                timestamp: crate::v2::Timestamp,
            }
            impl CurrentGear {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "The current gear. 0=Neutral, 1/2/..=Forward, -1/-2/..=Reverse.. This type has no unit defined"]
                pub fn value(&self) -> &i8 {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "The current gear. 0=Neutral, 1/2/..=Forward, -1/-2/..=Reverse.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: i8, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &i8) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: i8, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "The selected gear. 0=Neutral, 1/2/..=Forward, -1/-2/..=Reverse, 126=Park, 127=Drive.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct SelectedGear {
                v: i8,
                timestamp: crate::v2::Timestamp,
            }
            impl SelectedGear {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "The selected gear. 0=Neutral, 1/2/..=Forward, -1/-2/..=Reverse, 126=Park, 127=Drive.. This type has no unit defined"]
                pub fn value(&self) -> &i8 {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "The selected gear. 0=Neutral, 1/2/..=Forward, -1/-2/..=Reverse, 126=Park, 127=Drive.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: i8, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &i8) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: i8, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Is the transmission park lock engaged or not. False = Disengaged. True = Engaged.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsParkLockEngaged {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsParkLockEngaged {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is the transmission park lock engaged or not. False = Disengaged. True = Engaged.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Is the transmission park lock engaged or not. False = Disengaged. True = Engaged.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Is gearbox in low range mode or not. False = Normal/High range engaged. True = Low range engaged.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsLowRangeEngaged {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsLowRangeEngaged {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is gearbox in low range mode or not. False = Normal/High range engaged. True = Low range engaged.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Is gearbox in low range mode or not. False = Normal/High range engaged. True = Low range engaged.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Is electrical powertrain mechanically connected/engaged to the drivetrain or not. False = Disconnected/Disengaged. True = Connected/Engaged.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsElectricalPowertrainEngaged {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsElectricalPowertrainEngaged {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is electrical powertrain mechanically connected/engaged to the drivetrain or not. False = Disconnected/Disengaged. True = Connected/Engaged.. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Is electrical powertrain mechanically connected/engaged to the drivetrain or not. False = Disconnected/Disengaged. True = Connected/Engaged.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Current gearbox performance mode.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct PerformanceMode {
                v: String,
                timestamp: crate::v2::Timestamp,
            }
            impl PerformanceMode {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Current gearbox performance mode.. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Current gearbox performance mode.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: String,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Is the gearbox in automatic or manual (paddle) mode.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct GearChangeMode {
                v: String,
                timestamp: crate::v2::Timestamp,
            }
            impl GearChangeMode {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Is the gearbox in automatic or manual (paddle) mode.. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Is the gearbox in automatic or manual (paddle) mode.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: String,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "The current gearbox temperature.. The unit of this type is celsius"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Temperature {
                v: crate::v2::units::Celsius<i16>,
                timestamp: crate::v2::Timestamp,
            }
            impl Temperature {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "The current gearbox temperature.. The unit of this type is celsius"]
                pub fn value(&self) -> &crate::v2::units::Celsius<i16> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "The current gearbox temperature.. The unit of this type is celsius"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Celsius<i16>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Celsius<i16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Celsius<i16>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Clutch engagement. 0% = Clutch fully disengaged. 100% = Clutch fully engaged.. The unit of this type is percent"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct ClutchEngagement {
                v: crate::v2::units::Percent<f32>,
                timestamp: crate::v2::Timestamp,
            }
            impl ClutchEngagement {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Clutch engagement. 0% = Clutch fully disengaged. 100% = Clutch fully engaged.. The unit of this type is percent"]
                pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Clutch engagement. 0% = Clutch fully disengaged. 100% = Clutch fully engaged.. The unit of this type is percent"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Percent<f32>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v2::units::Percent<f32>) -> bool {
                    v.0 <= 100f32 && v.0 >= 0f32
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Percent<f32>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Clutch wear as a percent. 0 = no wear. 100 = worn.. The unit of this type is percent"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct ClutchWear {
                v: crate::v2::units::Percent<u8>,
                timestamp: crate::v2::Timestamp,
            }
            impl ClutchWear {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Clutch wear as a percent. 0 = no wear. 100 = worn.. The unit of this type is percent"]
                pub fn value(&self) -> &crate::v2::units::Percent<u8> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Clutch wear as a percent. 0 = no wear. 100 = worn.. The unit of this type is percent"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Percent<u8>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v2::units::Percent<u8>) -> bool {
                    v.0 <= 100u8 && true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Percent<u8>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Front Diff Lock engagement. 0% = Diff lock fully disengaged. 100% = Diff lock fully engaged.. The unit of this type is percent"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct DiffLockFrontEngagement {
                v: crate::v2::units::Percent<f32>,
                timestamp: crate::v2::Timestamp,
            }
            impl DiffLockFrontEngagement {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Front Diff Lock engagement. 0% = Diff lock fully disengaged. 100% = Diff lock fully engaged.. The unit of this type is percent"]
                pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Front Diff Lock engagement. 0% = Diff lock fully disengaged. 100% = Diff lock fully engaged.. The unit of this type is percent"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Percent<f32>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v2::units::Percent<f32>) -> bool {
                    v.0 <= 100f32 && v.0 >= 0f32
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Percent<f32>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Rear Diff Lock engagement. 0% = Diff lock fully disengaged. 100% = Diff lock fully engaged.. The unit of this type is percent"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct DiffLockRearEngagement {
                v: crate::v2::units::Percent<f32>,
                timestamp: crate::v2::Timestamp,
            }
            impl DiffLockRearEngagement {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Rear Diff Lock engagement. 0% = Diff lock fully disengaged. 100% = Diff lock fully engaged.. The unit of this type is percent"]
                pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Rear Diff Lock engagement. 0% = Diff lock fully disengaged. 100% = Diff lock fully engaged.. The unit of this type is percent"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Percent<f32>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v2::units::Percent<f32>) -> bool {
                    v.0 <= 100f32 && v.0 >= 0f32
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Percent<f32>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Torque distribution between front and rear axle in percent. -100% = Full torque to front axle, 0% = 50:50 Front/Rear, 100% = Full torque to rear axle.. The unit of this type is percent"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct TorqueDistribution {
                v: crate::v2::units::Percent<f32>,
                timestamp: crate::v2::Timestamp,
            }
            impl TorqueDistribution {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Torque distribution between front and rear axle in percent. -100% = Full torque to front axle, 0% = 50:50 Front/Rear, 100% = Full torque to rear axle.. The unit of this type is percent"]
                pub fn value(&self) -> &crate::v2::units::Percent<f32> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Torque distribution between front and rear axle in percent. -100% = Full torque to front axle, 0% = 50:50 Front/Rear, 100% = Full torque to rear axle.. The unit of this type is percent"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Percent<f32>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v2::units::Percent<f32>) -> bool {
                    v.0 <= 100f32 && v.0 >= -100f32
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Percent<f32>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod combustionengine {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Engine code designation, as specified by vehicle manufacturer.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct EngineCode {
                v: String,
            }
            impl EngineCode {
                #[doc = r" Get the "]
                #[doc = "Engine code designation, as specified by vehicle manufacturer.. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Engine code designation, as specified by vehicle manufacturer.. This type has no unit defined"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: String) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Displacement in cubic centimetres.. The unit of this type is cm^3"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Displacement {
                v: u16,
            }
            impl Displacement {
                #[doc = r" Get the "]
                #[doc = "Displacement in cubic centimetres.. The unit of this type is cm^3"]
                pub fn value(&self) -> &u16 {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Displacement in cubic centimetres.. The unit of this type is cm^3"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: u16) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &u16) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: u16) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Stroke length in millimetres.. The unit of this type is mm"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct StrokeLength {
                v: crate::v2::units::Millimetre<f32>,
            }
            impl StrokeLength {
                #[doc = r" Get the "]
                #[doc = "Stroke length in millimetres.. The unit of this type is mm"]
                pub fn value(&self) -> &crate::v2::units::Millimetre<f32> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Stroke length in millimetres.. The unit of this type is mm"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: crate::v2::units::Millimetre<f32>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Millimetre<f32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: crate::v2::units::Millimetre<f32>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Bore in millimetres.. The unit of this type is mm"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Bore {
                v: crate::v2::units::Millimetre<f32>,
            }
            impl Bore {
                #[doc = r" Get the "]
                #[doc = "Bore in millimetres.. The unit of this type is mm"]
                pub fn value(&self) -> &crate::v2::units::Millimetre<f32> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Bore in millimetres.. The unit of this type is mm"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: crate::v2::units::Millimetre<f32>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Millimetre<f32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: crate::v2::units::Millimetre<f32>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Engine configuration.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Configuration {
                v: String,
            }
            impl Configuration {
                #[doc = r" Get the "]
                #[doc = "Engine configuration.. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Engine configuration.. This type has no unit defined"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: String) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Number of cylinders.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct NumberOfCylinders {
                v: u16,
            }
            impl NumberOfCylinders {
                #[doc = r" Get the "]
                #[doc = "Number of cylinders.. This type has no unit defined"]
                pub fn value(&self) -> &u16 {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Number of cylinders.. This type has no unit defined"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: u16) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &u16) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: u16) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Number of valves per cylinder.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct NumberOfValvesPerCylinder {
                v: u16,
            }
            impl NumberOfValvesPerCylinder {
                #[doc = r" Get the "]
                #[doc = "Number of valves per cylinder.. This type has no unit defined"]
                pub fn value(&self) -> &u16 {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Number of valves per cylinder.. This type has no unit defined"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: u16) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &u16) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: u16) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Engine compression ratio, specified in the format 'X:1', e.g. '9.2:1'.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct CompressionRatio {
                v: String,
            }
            impl CompressionRatio {
                #[doc = r" Get the "]
                #[doc = "Engine compression ratio, specified in the format 'X:1', e.g. '9.2:1'.. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Engine compression ratio, specified in the format 'X:1', e.g. '9.2:1'.. This type has no unit defined"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: String) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Engine oil capacity in liters.. The unit of this type is l"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct EngineOilCapacity {
                v: crate::v2::units::Litre<f32>,
            }
            impl EngineOilCapacity {
                #[doc = r" Get the "]
                #[doc = "Engine oil capacity in liters.. The unit of this type is l"]
                pub fn value(&self) -> &crate::v2::units::Litre<f32> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Engine oil capacity in liters.. The unit of this type is l"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: crate::v2::units::Litre<f32>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Litre<f32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: crate::v2::units::Litre<f32>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Engine coolant capacity in liters.. The unit of this type is l"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct EngineCoolantCapacity {
                v: crate::v2::units::Litre<f32>,
            }
            impl EngineCoolantCapacity {
                #[doc = r" Get the "]
                #[doc = "Engine coolant capacity in liters.. The unit of this type is l"]
                pub fn value(&self) -> &crate::v2::units::Litre<f32> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Engine coolant capacity in liters.. The unit of this type is l"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: crate::v2::units::Litre<f32>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Litre<f32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: crate::v2::units::Litre<f32>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Peak power, in kilowatts, that engine can generate.. The unit of this type is kW"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct MaxPower {
                v: crate::v2::units::Kilowatt<u16>,
            }
            impl MaxPower {
                #[doc = r" Get the "]
                #[doc = "Peak power, in kilowatts, that engine can generate.. The unit of this type is kW"]
                pub fn value(&self) -> &crate::v2::units::Kilowatt<u16> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Peak power, in kilowatts, that engine can generate.. The unit of this type is kW"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: crate::v2::units::Kilowatt<u16>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Kilowatt<u16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: crate::v2::units::Kilowatt<u16>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Peak torque, in newton meter, that the engine can generate.. The unit of this type is Nm"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct MaxTorque {
                v: crate::v2::units::NewtonMetre<u16>,
            }
            impl MaxTorque {
                #[doc = r" Get the "]
                #[doc = "Peak torque, in newton meter, that the engine can generate.. The unit of this type is Nm"]
                pub fn value(&self) -> &crate::v2::units::NewtonMetre<u16> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Peak torque, in newton meter, that the engine can generate.. The unit of this type is Nm"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: crate::v2::units::NewtonMetre<u16>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::NewtonMetre<u16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: crate::v2::units::NewtonMetre<u16>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Type of aspiration (natural, turbocharger, supercharger etc).. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct AspirationType {
                v: String,
            }
            impl AspirationType {
                #[doc = r" Get the "]
                #[doc = "Type of aspiration (natural, turbocharger, supercharger etc).. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Type of aspiration (natural, turbocharger, supercharger etc).. This type has no unit defined"]
                #[doc = r" Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: String) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self { v: value })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Engine oil level.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct EngineOilLevel {
                v: String,
                timestamp: crate::v2::Timestamp,
            }
            impl EngineOilLevel {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Engine oil level.. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Engine oil level.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: String,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Remaining engine oil life in seconds. Negative values can be used to indicate that lifetime has been exceeded.. The unit of this type is s"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct OilLifeRemaining {
                v: crate::v2::units::Second<i32>,
                timestamp: crate::v2::Timestamp,
            }
            impl OilLifeRemaining {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Remaining engine oil life in seconds. Negative values can be used to indicate that lifetime has been exceeded.. The unit of this type is s"]
                pub fn value(&self) -> &crate::v2::units::Second<i32> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Remaining engine oil life in seconds. Negative values can be used to indicate that lifetime has been exceeded.. The unit of this type is s"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Second<i32>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Second<i32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Second<i32>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Engine Running. True if engine is rotating (Speed > 0).. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IsRunning {
                v: bool,
                timestamp: crate::v2::Timestamp,
            }
            impl IsRunning {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Engine Running. True if engine is rotating (Speed > 0).. This type has no unit defined"]
                pub fn value(&self) -> &bool {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Engine Running. True if engine is rotating (Speed > 0).. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &bool) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Engine speed measured as rotations per minute.. The unit of this type is rpm"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Speed {
                v: crate::v2::units::RPM<u16>,
                timestamp: crate::v2::Timestamp,
            }
            impl Speed {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Engine speed measured as rotations per minute.. The unit of this type is rpm"]
                pub fn value(&self) -> &crate::v2::units::RPM<u16> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Engine speed measured as rotations per minute.. The unit of this type is rpm"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::RPM<u16>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::RPM<u16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::RPM<u16>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Accumulated time during engine lifetime with 'engine speed (rpm) > 0'.. The unit of this type is h"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct EngineHours {
                v: crate::v2::units::Hour<f32>,
                timestamp: crate::v2::Timestamp,
            }
            impl EngineHours {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Accumulated time during engine lifetime with 'engine speed (rpm) > 0'.. The unit of this type is h"]
                pub fn value(&self) -> &crate::v2::units::Hour<f32> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Accumulated time during engine lifetime with 'engine speed (rpm) > 0'.. The unit of this type is h"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Hour<f32>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Hour<f32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Hour<f32>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Accumulated idling time during engine lifetime. Definition of idling is not standardized.. The unit of this type is h"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct IdleHours {
                v: crate::v2::units::Hour<f32>,
                timestamp: crate::v2::Timestamp,
            }
            impl IdleHours {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Accumulated idling time during engine lifetime. Definition of idling is not standardized.. The unit of this type is h"]
                pub fn value(&self) -> &crate::v2::units::Hour<f32> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Accumulated idling time during engine lifetime. Definition of idling is not standardized.. The unit of this type is h"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Hour<f32>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Hour<f32>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Hour<f32>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Engine coolant temperature.. The unit of this type is celsius"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct ECT {
                v: crate::v2::units::Celsius<i16>,
                timestamp: crate::v2::Timestamp,
            }
            impl ECT {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Engine coolant temperature.. The unit of this type is celsius"]
                pub fn value(&self) -> &crate::v2::units::Celsius<i16> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Engine coolant temperature.. The unit of this type is celsius"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Celsius<i16>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Celsius<i16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Celsius<i16>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Engine oil temperature.. The unit of this type is celsius"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct EOT {
                v: crate::v2::units::Celsius<i16>,
                timestamp: crate::v2::Timestamp,
            }
            impl EOT {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Engine oil temperature.. The unit of this type is celsius"]
                pub fn value(&self) -> &crate::v2::units::Celsius<i16> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Engine oil temperature.. The unit of this type is celsius"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Celsius<i16>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Celsius<i16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Celsius<i16>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Manifold absolute pressure possibly boosted using forced induction.. The unit of this type is kPa"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct MAP {
                v: crate::v2::units::KiloPascal<u16>,
                timestamp: crate::v2::Timestamp,
            }
            impl MAP {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Manifold absolute pressure possibly boosted using forced induction.. The unit of this type is kPa"]
                pub fn value(&self) -> &crate::v2::units::KiloPascal<u16> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Manifold absolute pressure possibly boosted using forced induction.. The unit of this type is kPa"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::KiloPascal<u16>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::KiloPascal<u16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::KiloPascal<u16>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Grams of air drawn into engine per second.. The unit of this type is g/s"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct MAF {
                v: crate::v2::units::GramPerSec<u16>,
                timestamp: crate::v2::Timestamp,
            }
            impl MAF {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Grams of air drawn into engine per second.. The unit of this type is g/s"]
                pub fn value(&self) -> &crate::v2::units::GramPerSec<u16> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Grams of air drawn into engine per second.. The unit of this type is g/s"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::GramPerSec<u16>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::GramPerSec<u16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::GramPerSec<u16>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Current throttle position.. The unit of this type is percent"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct TPS {
                v: crate::v2::units::Percent<u8>,
                timestamp: crate::v2::Timestamp,
            }
            impl TPS {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Current throttle position.. The unit of this type is percent"]
                pub fn value(&self) -> &crate::v2::units::Percent<u8> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Current throttle position.. The unit of this type is percent"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Percent<u8>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. Return true if the value is"]
                #[doc = r"within bounds."]
                pub fn bounds_check(v: &crate::v2::units::Percent<u8>) -> bool {
                    v.0 <= 100u8 && true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Percent<u8>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Engine oil pressure.. The unit of this type is kPa"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct EOP {
                v: crate::v2::units::KiloPascal<u16>,
                timestamp: crate::v2::Timestamp,
            }
            impl EOP {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Engine oil pressure.. The unit of this type is kPa"]
                pub fn value(&self) -> &crate::v2::units::KiloPascal<u16> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Engine oil pressure.. The unit of this type is kPa"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::KiloPascal<u16>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::KiloPascal<u16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::KiloPascal<u16>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Current engine power output. Shall be reported as 0 during engine breaking.. The unit of this type is kW"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Power {
                v: crate::v2::units::Kilowatt<u16>,
                timestamp: crate::v2::Timestamp,
            }
            impl Power {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Current engine power output. Shall be reported as 0 during engine breaking.. The unit of this type is kW"]
                pub fn value(&self) -> &crate::v2::units::Kilowatt<u16> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Current engine power output. Shall be reported as 0 during engine breaking.. The unit of this type is kW"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::Kilowatt<u16>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::Kilowatt<u16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::Kilowatt<u16>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[doc = "Current engine torque. Shall be reported as 0 during engine breaking.. The unit of this type is Nm"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct Torque {
                v: crate::v2::units::NewtonMetre<u16>,
                timestamp: crate::v2::Timestamp,
            }
            impl Torque {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Current engine torque. Shall be reported as 0 during engine breaking.. The unit of this type is Nm"]
                pub fn value(&self) -> &crate::v2::units::NewtonMetre<u16> {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Current engine torque. Shall be reported as 0 during engine breaking.. The unit of this type is Nm"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: crate::v2::units::NewtonMetre<u16>,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &crate::v2::units::NewtonMetre<u16>) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(
                    value: crate::v2::units::NewtonMetre<u16>,
                    timestamp: Option<crate::v2::Timestamp>,
                ) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod dieselparticulatefilter {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Inlet temperature of Diesel Particulate Filter.. The unit of this type is celsius"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct InletTemperature {
                    v: crate::v2::units::Celsius<f32>,
                    timestamp: crate::v2::Timestamp,
                }
                impl InletTemperature {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Inlet temperature of Diesel Particulate Filter.. The unit of this type is celsius"]
                    pub fn value(&self) -> &crate::v2::units::Celsius<f32> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Inlet temperature of Diesel Particulate Filter.. The unit of this type is celsius"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Celsius<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Celsius<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Celsius<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Outlet temperature of Diesel Particulate Filter.. The unit of this type is celsius"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct OutletTemperature {
                    v: crate::v2::units::Celsius<f32>,
                    timestamp: crate::v2::Timestamp,
                }
                impl OutletTemperature {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Outlet temperature of Diesel Particulate Filter.. The unit of this type is celsius"]
                    pub fn value(&self) -> &crate::v2::units::Celsius<f32> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Outlet temperature of Diesel Particulate Filter.. The unit of this type is celsius"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Celsius<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Celsius<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Celsius<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Delta Pressure of Diesel Particulate Filter.. The unit of this type is Pa"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct DeltaPressure {
                    v: crate::v2::units::Pascal<f32>,
                    timestamp: crate::v2::Timestamp,
                }
                impl DeltaPressure {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Delta Pressure of Diesel Particulate Filter.. The unit of this type is Pa"]
                    pub fn value(&self) -> &crate::v2::units::Pascal<f32> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Delta Pressure of Diesel Particulate Filter.. The unit of this type is Pa"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Pascal<f32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Pascal<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Pascal<f32>,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod dieselexhaustfluid {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Capacity in liters of the Diesel Exhaust Fluid Tank.. The unit of this type is l"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Capacity {
                    v: crate::v2::units::Litre<f32>,
                }
                impl Capacity {
                    #[doc = r" Get the "]
                    #[doc = "Capacity in liters of the Diesel Exhaust Fluid Tank.. The unit of this type is l"]
                    pub fn value(&self) -> &crate::v2::units::Litre<f32> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Capacity in liters of the Diesel Exhaust Fluid Tank.. The unit of this type is l"]
                    #[doc = r" Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(&mut self, value: crate::v2::units::Litre<f32>) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Litre<f32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(value: crate::v2::units::Litre<f32>) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self { v: value })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Level of the Diesel Exhaust Fluid tank as percent of capacity. 0 = empty. 100 = full.. The unit of this type is percent"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Level {
                    v: crate::v2::units::Percent<u8>,
                    timestamp: crate::v2::Timestamp,
                }
                impl Level {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Level of the Diesel Exhaust Fluid tank as percent of capacity. 0 = empty. 100 = full.. The unit of this type is percent"]
                    pub fn value(&self) -> &crate::v2::units::Percent<u8> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Level of the Diesel Exhaust Fluid tank as percent of capacity. 0 = empty. 100 = full.. The unit of this type is percent"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Percent<u8>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. Return true if the value is"]
                    #[doc = r"within bounds."]
                    pub fn bounds_check(v: &crate::v2::units::Percent<u8>) -> bool {
                        v.0 <= 100u8 && v.0 >= 0u8
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Percent<u8>,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Remaining range in meters of the Diesel Exhaust Fluid present in the vehicle.. The unit of this type is m"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Range {
                    v: crate::v2::units::Metre<u32>,
                    timestamp: crate::v2::Timestamp,
                }
                impl Range {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Remaining range in meters of the Diesel Exhaust Fluid present in the vehicle.. The unit of this type is m"]
                    pub fn value(&self) -> &crate::v2::units::Metre<u32> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Remaining range in meters of the Diesel Exhaust Fluid present in the vehicle.. The unit of this type is m"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: crate::v2::units::Metre<u32>,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Metre<u32>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: crate::v2::units::Metre<u32>,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Indicates if the Diesel Exhaust Fluid level is low. True if level is low. Definition of low is vehicle dependent.. This type has no unit defined"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct IsLevelLow {
                    v: bool,
                    timestamp: crate::v2::Timestamp,
                }
                impl IsLevelLow {
                    pub fn timestamp(&self) -> &crate::v2::Timestamp {
                        &self.timestamp
                    }
                    #[doc = r" Get the "]
                    #[doc = "Indicates if the Diesel Exhaust Fluid level is low. True if level is low. Definition of low is vehicle dependent.. This type has no unit defined"]
                    pub fn value(&self) -> &bool {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Indicates if the Diesel Exhaust Fluid level is low. True if level is low. Definition of low is vehicle dependent.. This type has no unit defined"]
                    #[doc = r" . Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(
                        &mut self,
                        value: bool,
                        maybe_timestamp: Option<crate::v2::Timestamp>,
                    ) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                        if let Some(ts) = maybe_timestamp {
                            self.timestamp = ts;
                        }
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &bool) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(
                        value: bool,
                        timestamp: Option<crate::v2::Timestamp>,
                    ) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self {
                                v: value,
                                timestamp: timestamp.unwrap_or_default(),
                            })
                        } else {
                            None
                        }
                    }
                }
            }
        }
    }
    #[allow(non_snake_case)]
    pub mod currentlocation {
        use cdds_derive::Topic;
        use cyclonedds_rs::*;
        #[doc = "Timestamp from GNSS system for current location, formatted according to ISO 8601 with UTC time zone.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Timestamp {
            v: String,
            timestamp: crate::v2::Timestamp,
        }
        impl Timestamp {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Timestamp from GNSS system for current location, formatted according to ISO 8601 with UTC time zone.. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Timestamp from GNSS system for current location, formatted according to ISO 8601 with UTC time zone.. This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String, maybe_timestamp: Option<crate::v2::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Current latitude of vehicle in WGS 84 geodetic coordinates, as measured at the position of GNSS receiver antenna.. The unit of this type is degrees"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Latitude {
            v: f64,
            timestamp: crate::v2::Timestamp,
        }
        impl Latitude {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Current latitude of vehicle in WGS 84 geodetic coordinates, as measured at the position of GNSS receiver antenna.. The unit of this type is degrees"]
            pub fn value(&self) -> &f64 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Current latitude of vehicle in WGS 84 geodetic coordinates, as measured at the position of GNSS receiver antenna.. The unit of this type is degrees"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: f64, maybe_timestamp: Option<crate::v2::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. Return true if the value is"]
            #[doc = r"within bounds."]
            pub fn bounds_check(v: &f64) -> bool {
                *v <= 90f64 && *v >= -90f64
            }
            #[doc = r" create a new instance"]
            pub fn new(value: f64, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Current longitude of vehicle in WGS 84 geodetic coordinates, as measured at the position of GNSS receiver antenna.. The unit of this type is degrees"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Longitude {
            v: f64,
            timestamp: crate::v2::Timestamp,
        }
        impl Longitude {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Current longitude of vehicle in WGS 84 geodetic coordinates, as measured at the position of GNSS receiver antenna.. The unit of this type is degrees"]
            pub fn value(&self) -> &f64 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Current longitude of vehicle in WGS 84 geodetic coordinates, as measured at the position of GNSS receiver antenna.. The unit of this type is degrees"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: f64, maybe_timestamp: Option<crate::v2::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. Return true if the value is"]
            #[doc = r"within bounds."]
            pub fn bounds_check(v: &f64) -> bool {
                *v <= 180f64 && *v >= -180f64
            }
            #[doc = r" create a new instance"]
            pub fn new(value: f64, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Current heading relative to geographic north. 0 = North, 90 = East, 180 = South, 270 = West.. The unit of this type is degrees"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Heading {
            v: f64,
            timestamp: crate::v2::Timestamp,
        }
        impl Heading {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Current heading relative to geographic north. 0 = North, 90 = East, 180 = South, 270 = West.. The unit of this type is degrees"]
            pub fn value(&self) -> &f64 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Current heading relative to geographic north. 0 = North, 90 = East, 180 = South, 270 = West.. The unit of this type is degrees"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: f64, maybe_timestamp: Option<crate::v2::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. Return true if the value is"]
            #[doc = r"within bounds."]
            pub fn bounds_check(v: &f64) -> bool {
                *v <= 360f64 && *v >= 0f64
            }
            #[doc = r" create a new instance"]
            pub fn new(value: f64, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Accuracy of the latitude and longitude coordinates.. The unit of this type is m"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct HorizontalAccuracy {
            v: crate::v2::units::Metre<f64>,
            timestamp: crate::v2::Timestamp,
        }
        impl HorizontalAccuracy {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Accuracy of the latitude and longitude coordinates.. The unit of this type is m"]
            pub fn value(&self) -> &crate::v2::units::Metre<f64> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Accuracy of the latitude and longitude coordinates.. The unit of this type is m"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Metre<f64>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Metre<f64>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Metre<f64>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Current altitude relative to WGS 84 reference ellipsoid, as measured at the position of GNSS receiver antenna.. The unit of this type is m"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Altitude {
            v: crate::v2::units::Metre<f64>,
            timestamp: crate::v2::Timestamp,
        }
        impl Altitude {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Current altitude relative to WGS 84 reference ellipsoid, as measured at the position of GNSS receiver antenna.. The unit of this type is m"]
            pub fn value(&self) -> &crate::v2::units::Metre<f64> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Current altitude relative to WGS 84 reference ellipsoid, as measured at the position of GNSS receiver antenna.. The unit of this type is m"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Metre<f64>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Metre<f64>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Metre<f64>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Accuracy of altitude.. The unit of this type is m"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct VerticalAccuracy {
            v: crate::v2::units::Metre<f64>,
            timestamp: crate::v2::Timestamp,
        }
        impl VerticalAccuracy {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Accuracy of altitude.. The unit of this type is m"]
            pub fn value(&self) -> &crate::v2::units::Metre<f64> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Accuracy of altitude.. The unit of this type is m"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::Metre<f64>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::Metre<f64>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::Metre<f64>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[allow(non_snake_case)]
        pub mod gnssreceiver {
            use cdds_derive::Topic;
            use cyclonedds_rs::*;
            #[doc = "Fix status of GNSS receiver.. This type has no unit defined"]
            #[allow(non_camel_case_types)]
            #[derive(Default, Deserialize, Serialize, Topic)]
            pub struct FixType {
                v: String,
                timestamp: crate::v2::Timestamp,
            }
            impl FixType {
                pub fn timestamp(&self) -> &crate::v2::Timestamp {
                    &self.timestamp
                }
                #[doc = r" Get the "]
                #[doc = "Fix status of GNSS receiver.. This type has no unit defined"]
                pub fn value(&self) -> &String {
                    &self.v
                }
                #[doc = r" Set the"]
                #[doc = "Fix status of GNSS receiver.. This type has no unit defined"]
                #[doc = r" . Ensure that the value is within bounds as per the"]
                #[doc = r" specification. This function will panic in case the value is out"]
                #[doc = r" of bounds."]
                pub fn set(
                    &mut self,
                    value: String,
                    maybe_timestamp: Option<crate::v2::Timestamp>,
                ) {
                    assert!(Self::bounds_check(&value));
                    self.v = value;
                    if let Some(ts) = maybe_timestamp {
                        self.timestamp = ts;
                    }
                }
                #[doc = r"check if the given value is within the limits defined"]
                #[doc = r"in the specification. This particular type has not"]
                #[doc = r"specified the min or max limits so the function just"]
                #[doc = r" returns true"]
                const fn bounds_check(_v: &String) -> bool {
                    true
                }
                #[doc = r" create a new instance"]
                pub fn new(value: String, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                    if Self::bounds_check(&value) {
                        Some(Self {
                            v: value,
                            timestamp: timestamp.unwrap_or_default(),
                        })
                    } else {
                        None
                    }
                }
            }
            #[allow(non_snake_case)]
            pub mod mountingposition {
                use cdds_derive::Topic;
                use cyclonedds_rs::*;
                #[doc = "Mounting position of GNSS receiver antenna relative to vehicle coordinate system. Axis definitions according to ISO 8855. Origin at center of (first) rear axle. Positive values = forward of rear axle. Negative values = backward of rear axle.. The unit of this type is mm"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct X {
                    v: crate::v2::units::Millimetre<i16>,
                }
                impl X {
                    #[doc = r" Get the "]
                    #[doc = "Mounting position of GNSS receiver antenna relative to vehicle coordinate system. Axis definitions according to ISO 8855. Origin at center of (first) rear axle. Positive values = forward of rear axle. Negative values = backward of rear axle.. The unit of this type is mm"]
                    pub fn value(&self) -> &crate::v2::units::Millimetre<i16> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Mounting position of GNSS receiver antenna relative to vehicle coordinate system. Axis definitions according to ISO 8855. Origin at center of (first) rear axle. Positive values = forward of rear axle. Negative values = backward of rear axle.. The unit of this type is mm"]
                    #[doc = r" Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(&mut self, value: crate::v2::units::Millimetre<i16>) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Millimetre<i16>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(value: crate::v2::units::Millimetre<i16>) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self { v: value })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Mounting position of GNSS receiver antenna relative to vehicle coordinate system. Axis definitions according to ISO 8855. Origin at center of (first) rear axle. Positive values = left of origin. Negative values = right of origin. Left/Right is as seen from driver perspective, i.e. by a person looking forward.. The unit of this type is mm"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Y {
                    v: crate::v2::units::Millimetre<i16>,
                }
                impl Y {
                    #[doc = r" Get the "]
                    #[doc = "Mounting position of GNSS receiver antenna relative to vehicle coordinate system. Axis definitions according to ISO 8855. Origin at center of (first) rear axle. Positive values = left of origin. Negative values = right of origin. Left/Right is as seen from driver perspective, i.e. by a person looking forward.. The unit of this type is mm"]
                    pub fn value(&self) -> &crate::v2::units::Millimetre<i16> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Mounting position of GNSS receiver antenna relative to vehicle coordinate system. Axis definitions according to ISO 8855. Origin at center of (first) rear axle. Positive values = left of origin. Negative values = right of origin. Left/Right is as seen from driver perspective, i.e. by a person looking forward.. The unit of this type is mm"]
                    #[doc = r" Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(&mut self, value: crate::v2::units::Millimetre<i16>) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Millimetre<i16>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(value: crate::v2::units::Millimetre<i16>) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self { v: value })
                        } else {
                            None
                        }
                    }
                }
                #[doc = "Mounting position of GNSS receiver on Z-axis. Axis definitions according to ISO 8855. Origin at center of (first) rear axle. Positive values = above center of rear axle. Negative values = below center of rear axle.. The unit of this type is mm"]
                #[allow(non_camel_case_types)]
                #[derive(Default, Deserialize, Serialize, Topic)]
                pub struct Z {
                    v: crate::v2::units::Millimetre<i16>,
                }
                impl Z {
                    #[doc = r" Get the "]
                    #[doc = "Mounting position of GNSS receiver on Z-axis. Axis definitions according to ISO 8855. Origin at center of (first) rear axle. Positive values = above center of rear axle. Negative values = below center of rear axle.. The unit of this type is mm"]
                    pub fn value(&self) -> &crate::v2::units::Millimetre<i16> {
                        &self.v
                    }
                    #[doc = r" Set the"]
                    #[doc = "Mounting position of GNSS receiver on Z-axis. Axis definitions according to ISO 8855. Origin at center of (first) rear axle. Positive values = above center of rear axle. Negative values = below center of rear axle.. The unit of this type is mm"]
                    #[doc = r" Ensure that the value is within bounds as per the"]
                    #[doc = r" specification. This function will panic in case the value is out"]
                    #[doc = r" of bounds."]
                    pub fn set(&mut self, value: crate::v2::units::Millimetre<i16>) {
                        assert!(Self::bounds_check(&value));
                        self.v = value;
                    }
                    #[doc = r"check if the given value is within the limits defined"]
                    #[doc = r"in the specification. This particular type has not"]
                    #[doc = r"specified the min or max limits so the function just"]
                    #[doc = r" returns true"]
                    const fn bounds_check(_v: &crate::v2::units::Millimetre<i16>) -> bool {
                        true
                    }
                    #[doc = r" create a new instance"]
                    pub fn new(value: crate::v2::units::Millimetre<i16>) -> Option<Self> {
                        if Self::bounds_check(&value) {
                            Some(Self { v: value })
                        } else {
                            None
                        }
                    }
                }
            }
        }
    }
    #[allow(non_snake_case)]
    pub mod trailer {
        use cdds_derive::Topic;
        use cyclonedds_rs::*;
        #[doc = "Signal indicating if trailer is connected or not.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct IsConnected {
            v: bool,
            timestamp: crate::v2::Timestamp,
        }
        impl IsConnected {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Signal indicating if trailer is connected or not.. This type has no unit defined"]
            pub fn value(&self) -> &bool {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Signal indicating if trailer is connected or not.. This type has no unit defined"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: bool, maybe_timestamp: Option<crate::v2::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &bool) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: bool, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
    }
    #[allow(non_snake_case)]
    pub mod angularvelocity {
        use cdds_derive::Topic;
        use cyclonedds_rs::*;
        #[doc = "Vehicle rotation rate along X (longitudinal).. The unit of this type is degrees/s"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Roll {
            v: f32,
            timestamp: crate::v2::Timestamp,
        }
        impl Roll {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Vehicle rotation rate along X (longitudinal).. The unit of this type is degrees/s"]
            pub fn value(&self) -> &f32 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Vehicle rotation rate along X (longitudinal).. The unit of this type is degrees/s"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: f32, maybe_timestamp: Option<crate::v2::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &f32) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: f32, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Vehicle rotation rate along Y (lateral).. The unit of this type is degrees/s"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Pitch {
            v: f32,
            timestamp: crate::v2::Timestamp,
        }
        impl Pitch {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Vehicle rotation rate along Y (lateral).. The unit of this type is degrees/s"]
            pub fn value(&self) -> &f32 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Vehicle rotation rate along Y (lateral).. The unit of this type is degrees/s"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: f32, maybe_timestamp: Option<crate::v2::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &f32) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: f32, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Vehicle rotation rate along Z (vertical).. The unit of this type is degrees/s"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Yaw {
            v: f32,
            timestamp: crate::v2::Timestamp,
        }
        impl Yaw {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Vehicle rotation rate along Z (vertical).. The unit of this type is degrees/s"]
            pub fn value(&self) -> &f32 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Vehicle rotation rate along Z (vertical).. The unit of this type is degrees/s"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: f32, maybe_timestamp: Option<crate::v2::Timestamp>) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &f32) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: f32, timestamp: Option<crate::v2::Timestamp>) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
    }
    #[allow(non_snake_case)]
    pub mod acceleration {
        use cdds_derive::Topic;
        use cyclonedds_rs::*;
        #[doc = "Vehicle acceleration in X (longitudinal acceleration).. The unit of this type is m/s^2"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Longitudinal {
            v: crate::v2::units::MeterPerSecondSq<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl Longitudinal {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Vehicle acceleration in X (longitudinal acceleration).. The unit of this type is m/s^2"]
            pub fn value(&self) -> &crate::v2::units::MeterPerSecondSq<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Vehicle acceleration in X (longitudinal acceleration).. The unit of this type is m/s^2"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::MeterPerSecondSq<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::MeterPerSecondSq<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::MeterPerSecondSq<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Vehicle acceleration in Y (lateral acceleration).. The unit of this type is m/s^2"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Lateral {
            v: crate::v2::units::MeterPerSecondSq<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl Lateral {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Vehicle acceleration in Y (lateral acceleration).. The unit of this type is m/s^2"]
            pub fn value(&self) -> &crate::v2::units::MeterPerSecondSq<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Vehicle acceleration in Y (lateral acceleration).. The unit of this type is m/s^2"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::MeterPerSecondSq<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::MeterPerSecondSq<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::MeterPerSecondSq<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
        #[doc = "Vehicle acceleration in Z (vertical acceleration).. The unit of this type is m/s^2"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Vertical {
            v: crate::v2::units::MeterPerSecondSq<f32>,
            timestamp: crate::v2::Timestamp,
        }
        impl Vertical {
            pub fn timestamp(&self) -> &crate::v2::Timestamp {
                &self.timestamp
            }
            #[doc = r" Get the "]
            #[doc = "Vehicle acceleration in Z (vertical acceleration).. The unit of this type is m/s^2"]
            pub fn value(&self) -> &crate::v2::units::MeterPerSecondSq<f32> {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Vehicle acceleration in Z (vertical acceleration).. The unit of this type is m/s^2"]
            #[doc = r" . Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(
                &mut self,
                value: crate::v2::units::MeterPerSecondSq<f32>,
                maybe_timestamp: Option<crate::v2::Timestamp>,
            ) {
                assert!(Self::bounds_check(&value));
                self.v = value;
                if let Some(ts) = maybe_timestamp {
                    self.timestamp = ts;
                }
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &crate::v2::units::MeterPerSecondSq<f32>) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(
                value: crate::v2::units::MeterPerSecondSq<f32>,
                timestamp: Option<crate::v2::Timestamp>,
            ) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self {
                        v: value,
                        timestamp: timestamp.unwrap_or_default(),
                    })
                } else {
                    None
                }
            }
        }
    }
    #[allow(non_snake_case)]
    pub mod vehicleidentification {
        use cdds_derive::Topic;
        use cyclonedds_rs::*;
        #[doc = "17-character Vehicle Identification Number (VIN) as defined by ISO 3779.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct VIN {
            v: String,
        }
        impl VIN {
            #[doc = r" Get the "]
            #[doc = "17-character Vehicle Identification Number (VIN) as defined by ISO 3779.. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "17-character Vehicle Identification Number (VIN) as defined by ISO 3779.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "3-character World Manufacturer Identification (WMI) as defined by ISO 3780.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct WMI {
            v: String,
        }
        impl WMI {
            #[doc = r" Get the "]
            #[doc = "3-character World Manufacturer Identification (WMI) as defined by ISO 3780.. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "3-character World Manufacturer Identification (WMI) as defined by ISO 3780.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "Vehicle brand or manufacturer.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Brand {
            v: String,
        }
        impl Brand {
            #[doc = r" Get the "]
            #[doc = "Vehicle brand or manufacturer.. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Vehicle brand or manufacturer.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "Vehicle model.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Model {
            v: String,
        }
        impl Model {
            #[doc = r" Get the "]
            #[doc = "Vehicle model.. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Vehicle model.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "Model year of the vehicle.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Year {
            v: u16,
        }
        impl Year {
            #[doc = r" Get the "]
            #[doc = "Model year of the vehicle.. This type has no unit defined"]
            pub fn value(&self) -> &u16 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Model year of the vehicle.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u16) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u16) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u16) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "The ACRISS Car Classification Code is a code used by many car rental companies.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct AcrissCode {
            v: String,
        }
        impl AcrissCode {
            #[doc = r" Get the "]
            #[doc = "The ACRISS Car Classification Code is a code used by many car rental companies.. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "The ACRISS Car Classification Code is a code used by many car rental companies.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "Indicates the design and body style of the vehicle (e.g. station wagon, hatchback, etc.).. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct BodyType {
            v: String,
        }
        impl BodyType {
            #[doc = r" Get the "]
            #[doc = "Indicates the design and body style of the vehicle (e.g. station wagon, hatchback, etc.).. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Indicates the design and body style of the vehicle (e.g. station wagon, hatchback, etc.).. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "The date in ISO 8601 format of the first registration of the vehicle with the respective public authorities.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct DateVehicleFirstRegistered {
            v: String,
        }
        impl DateVehicleFirstRegistered {
            #[doc = r" Get the "]
            #[doc = "The date in ISO 8601 format of the first registration of the vehicle with the respective public authorities.. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "The date in ISO 8601 format of the first registration of the vehicle with the respective public authorities.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "Indicates that the vehicle meets the respective emission standard.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct MeetsEmissionStandard {
            v: String,
        }
        impl MeetsEmissionStandard {
            #[doc = r" Get the "]
            #[doc = "Indicates that the vehicle meets the respective emission standard.. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Indicates that the vehicle meets the respective emission standard.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "The date in ISO 8601 format of production of the item, e.g. vehicle.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct ProductionDate {
            v: String,
        }
        impl ProductionDate {
            #[doc = r" Get the "]
            #[doc = "The date in ISO 8601 format of production of the item, e.g. vehicle.. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "The date in ISO 8601 format of production of the item, e.g. vehicle.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "The date in ISO 8601 format of the item e.g. vehicle was purchased by the current owner.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct PurchaseDate {
            v: String,
        }
        impl PurchaseDate {
            #[doc = r" Get the "]
            #[doc = "The date in ISO 8601 format of the item e.g. vehicle was purchased by the current owner.. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "The date in ISO 8601 format of the item e.g. vehicle was purchased by the current owner.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "The release date in ISO 8601 format of a vehicle model (often used to differentiate versions of the same make and model).. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct VehicleModelDate {
            v: String,
        }
        impl VehicleModelDate {
            #[doc = r" Get the "]
            #[doc = "The release date in ISO 8601 format of a vehicle model (often used to differentiate versions of the same make and model).. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "The release date in ISO 8601 format of a vehicle model (often used to differentiate versions of the same make and model).. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "A short text indicating the configuration of the vehicle, e.g. '5dr hatchback ST 2.5 MT 225 hp' or 'limited edition'.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct VehicleConfiguration {
            v: String,
        }
        impl VehicleConfiguration {
            #[doc = r" Get the "]
            #[doc = "A short text indicating the configuration of the vehicle, e.g. '5dr hatchback ST 2.5 MT 225 hp' or 'limited edition'.. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "A short text indicating the configuration of the vehicle, e.g. '5dr hatchback ST 2.5 MT 225 hp' or 'limited edition'.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "The number of passengers that can be seated in the vehicle, both in terms of the physical space available, and in terms of limitations set by law.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct VehicleSeatingCapacity {
            v: u16,
        }
        impl VehicleSeatingCapacity {
            #[doc = r" Get the "]
            #[doc = "The number of passengers that can be seated in the vehicle, both in terms of the physical space available, and in terms of limitations set by law.. This type has no unit defined"]
            pub fn value(&self) -> &u16 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "The number of passengers that can be seated in the vehicle, both in terms of the physical space available, and in terms of limitations set by law.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u16) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u16) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u16) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "Indicates whether the vehicle has been used for special purposes, like commercial rental, driving school.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct VehicleSpecialUsage {
            v: String,
        }
        impl VehicleSpecialUsage {
            #[doc = r" Get the "]
            #[doc = "Indicates whether the vehicle has been used for special purposes, like commercial rental, driving school.. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Indicates whether the vehicle has been used for special purposes, like commercial rental, driving school.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "The color or color combination of the interior of the vehicle.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct VehicleInteriorColor {
            v: String,
        }
        impl VehicleInteriorColor {
            #[doc = r" Get the "]
            #[doc = "The color or color combination of the interior of the vehicle.. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "The color or color combination of the interior of the vehicle.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "The type or material of the interior of the vehicle (e.g. synthetic fabric, leather, wood, etc.).. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct VehicleInteriorType {
            v: String,
        }
        impl VehicleInteriorType {
            #[doc = r" Get the "]
            #[doc = "The type or material of the interior of the vehicle (e.g. synthetic fabric, leather, wood, etc.).. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "The type or material of the interior of the vehicle (e.g. synthetic fabric, leather, wood, etc.).. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "A textual description of known damages, both repaired and unrepaired.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct KnownVehicleDamages {
            v: String,
        }
        impl KnownVehicleDamages {
            #[doc = r" Get the "]
            #[doc = "A textual description of known damages, both repaired and unrepaired.. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "A textual description of known damages, both repaired and unrepaired.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
    }
    #[allow(non_snake_case)]
    pub mod versionvss {
        use cdds_derive::Topic;
        use cyclonedds_rs::*;
        #[doc = "Supported Version of VSS - Major version.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Major {
            v: u32,
        }
        impl Major {
            #[doc = r" Get the "]
            #[doc = "Supported Version of VSS - Major version.. This type has no unit defined"]
            pub fn value(&self) -> &u32 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Supported Version of VSS - Major version.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u32) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u32) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u32) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "Supported Version of VSS - Minor version.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Minor {
            v: u32,
        }
        impl Minor {
            #[doc = r" Get the "]
            #[doc = "Supported Version of VSS - Minor version.. This type has no unit defined"]
            pub fn value(&self) -> &u32 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Supported Version of VSS - Minor version.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u32) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u32) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u32) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "Supported Version of VSS - Patch version.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Patch {
            v: u32,
        }
        impl Patch {
            #[doc = r" Get the "]
            #[doc = "Supported Version of VSS - Patch version.. This type has no unit defined"]
            pub fn value(&self) -> &u32 {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Supported Version of VSS - Patch version.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: u32) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &u32) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: u32) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
        #[doc = "Label to further describe the version.. This type has no unit defined"]
        #[allow(non_camel_case_types)]
        #[derive(Default, Deserialize, Serialize, Topic)]
        pub struct Label {
            v: String,
        }
        impl Label {
            #[doc = r" Get the "]
            #[doc = "Label to further describe the version.. This type has no unit defined"]
            pub fn value(&self) -> &String {
                &self.v
            }
            #[doc = r" Set the"]
            #[doc = "Label to further describe the version.. This type has no unit defined"]
            #[doc = r" Ensure that the value is within bounds as per the"]
            #[doc = r" specification. This function will panic in case the value is out"]
            #[doc = r" of bounds."]
            pub fn set(&mut self, value: String) {
                assert!(Self::bounds_check(&value));
                self.v = value;
            }
            #[doc = r"check if the given value is within the limits defined"]
            #[doc = r"in the specification. This particular type has not"]
            #[doc = r"specified the min or max limits so the function just"]
            #[doc = r" returns true"]
            const fn bounds_check(_v: &String) -> bool {
                true
            }
            #[doc = r" create a new instance"]
            pub fn new(value: String) -> Option<Self> {
                if Self::bounds_check(&value) {
                    Some(Self { v: value })
                } else {
                    None
                }
            }
        }
    }
}
